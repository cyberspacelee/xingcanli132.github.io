{"meta":{"title":"Cyberspace Cloner","subtitle":"","description":"","author":"LI Xingcan","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-02-08T08:35:54.040Z","updated":"2020-02-08T08:35:54.040Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-08T08:41:42.719Z","updated":"2020-02-08T08:41:42.719Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"接口、多态","slug":"10-接口、多态","date":"2020-03-26T07:23:42.000Z","updated":"2020-04-02T08:43:51.796Z","comments":true,"path":"2020/03/26/10-接口、多态/","link":"","permalink":"http://yoursite.com/2020/03/26/10-%E6%8E%A5%E5%8F%A3%E3%80%81%E5%A4%9A%E6%80%81/","excerpt":"接口、多态1.接口","text":"接口、多态1.接口 1.1概述接口，是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是封装了方法，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8），私有方法（JDK 9）。接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。引用数据类型：数组，类，接口。接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的类（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。接口就是多个类的公共规范。 1.2定义格式123public interface 接口名称 &#123; // 接口内容&#125; 1.3在任何版本的Java中，接口都能定义抽象方法格式： public abstract 返回值类型 方法名称(参数列表); 注意事项： 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract 这两个关键字修饰符，可以选择性地省略。 方法的三要素，可以随意定义。 举例： 123456789101112131415161718package demo01;public interface MyInterfaceAbstract &#123; &#x2F;&#x2F; 这是一个抽象方法 public abstract void methodAbs1(); &#x2F;&#x2F; 这也是抽象方法 abstract void methodAbs2(); &#x2F;&#x2F; 这也是抽象方法 public void methodAbs3(); &#x2F;&#x2F; 这也是抽象方法 void methodAbs4();&#125; 1.4在任何版本的Java中，接口都能定义常量接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。从效果上看，这其实就是接口的【常量】。 格式： public static final 数据类型 常量名称 = 数据值; 备注： 一旦使用final关键字进行修饰，说明不可改变。 注意事项： 接口当中的常量，可以省略public static final，注意：不写也照样是这样。 接口当中的常量，必须进行赋值；不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则） 举例： 123456public interface MyInterfaceConst &#123; // 这其实就是一个常量，一旦赋值，不可以修改 public static final int NUM_OF_MY_CLASS = 12;&#125; 1.5接口使用步骤：1：接口不能直接使用，必须有一个“实现类”来“实现”该接口。格式： 123public class 实现类名称 implements 接口名称 &#123; // ...&#125; 2：接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。实现：去掉abstract关键字，加上方法体大括号。3：创建实现类的对象，进行使用。 2：接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。实现：去掉abstract关键字，加上方法体大括号。3：创建实现类的对象，进行使用。 注意事项： 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。 代码举例 定义接口 1234567891011package demo01;public interface LiveAble &#123; //定义常量 public static final int NUM_OF_MY_CLASS = 12; // 定义抽象方法 public abstract void eat(); public abstract void sleep();&#125; 定义实现类 12345678910111213package demo01;//定义实现类，实现接口public class Animal implements LiveAble &#123; @Override public void eat() &#123; System.out.println(\"吃东西\"); &#125; @Override public void sleep() &#123; System.out.println(\"晚上睡\"); &#125;&#125; 定义测试类 1234567891011121314package demo01;public class InterfaceDemo &#123; public static void main(String[] args) &#123; // 创建实现类对象 Animal a = new Animal(); // 访问接口当中的常量 System.out.println(LiveAble.NUM_OF_MY_CLASS);//12 // 调用实现后的方法 a.eat();// 吃东西 a.sleep();// 晚上睡 &#125;&#125; 1.6从Java 8开始，接口里允许定义默认方法格式： 123public default 返回值类型 方法名称(参数列表) &#123; //方法体&#125; 备注：接口当中的默认方法，可以解决接口升级的问题。 默认方法的使用 可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。 举例： 定义接口 123456789package demo01;public interface MyInterfaceDefault &#123; // 添加默认方法 public default void methodDefault() &#123; System.out.println(\"这是新添加的默认方法\"); &#125;&#125; 定义实现类，继承默认方法，代码如下： 1234package demo01;public class MyInterfaceDefaultA implements MyInterfaceDefault &#123; &#125; 定义实现类，重写默认方法，代码如下： 12345678910package demo01;public class MyInterfaceDefaultB implements MyInterfaceDefault &#123; @Override public void methodDefault() &#123; System.out.println(\"实现类B覆盖重写了接口的默认方法\"); &#125;&#125; 定义测试类 12345678910111213141516171819202122package demo01;/*1. 接口的默认方法，可以通过接口实现类对象，直接调用。2. 接口的默认方法，也可以被接口实现类进行覆盖重写。 */public class Demo02Interface &#123; public static void main(String[] args) &#123; // 创建了实现类对象 MyInterfaceDefaultA a = new MyInterfaceDefaultA(); // 调用默认方法，如果实现类当中没有，会向上找接口 a.methodDefault(); // 这是新添加的默认方法 // 创建了实现类对象 MyInterfaceDefaultB b = new MyInterfaceDefaultB(); b.methodDefault(); // 实现类B覆盖重写了接口的默认方法 &#125;&#125; 1.7从Java 8开始，接口当中允许定义静态方法格式： 123public static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 静态方法的使用 静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用 举例 定义接口 1234567public interface MyInterfaceStatic &#123; public static void methodStatic() &#123; System.out.println(\"这是接口的静态方法！\"); &#125;&#125; 定义测试类 1234567891011121314151617package demo01;/*注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。正确用法：通过接口名称，直接调用其中的静态方法。格式：接口名称.静态方法名(参数); */public class Demo03Interface &#123; public static void main(String[] args) &#123; ; // 直接通过接口名称调用静态方法 MyInterfaceStatic.methodStatic();//这是接口的静态方法！ &#125;&#125; 1.8从Java 9开始，接口当中允许定义私有方法 普通私有方法，解决多个默认方法之间重复代码问题格式： 123private 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 静态私有方法，解决多个静态方法之间重复代码问题格式： 123private static 返回值类型 方法名称(参数列表) &#123; 方法体&#125; 如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。 私有方法的使用 私有方法：只有默认方法可以调用。 私有静态方法：默认方法和静态方法可以调用。 举例： 1234567891011121314151617181920212223public interface Demo &#123; default void func() &#123; func2(); func3(); &#125; static void func1() &#123; func3(); &#125; //只有默认方法可以调用。 private void func2() &#123; System.out.println(\"跑起来~~~\"); &#125; //默认方法和静态方法可以调用。 private static void func3() &#123; System.out.println(\"跑起来~~~\"); &#125;&#125; 1.9使用接口的时候，需要注意：1：接口是没有静态代码块或者构造方法的。2：一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。格式： 123public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB &#123; // 覆盖重写所有抽象方法&#125; 3：如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。4：如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。5：如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。6：一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。 3：如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。4：如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。5：如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。6：一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。 1.10接口的多实现 类与类之间是单继承的。直接父类只有一个。 类与接口之间是多实现的。一个类可以实现多个接口。 接口与接口之间是多继承的。 注意事项： 多个父接口当中的抽象方法如果重复，没关系。 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。 2.多态2.1概述多态是继封装、继承之后，面向对象的第三大特性。生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。 2.2定义多态： 是指同一行为，具有多个不同表现形式。 2.3前提 继承或者实现【二选一】 方法的重写【意义体现：不重写，无意义】 父类引用指向子类对象【格式体现】 2.4多态的体现多态体现的格式： 12父类类型 变量名 = new 子类对象;变量名.方法名(); 父类类型：指子类对象继承的父类类型，或者实现的父类接口类型。 代码如下： 12Fu f = new Zi();f.method(); 2.5多态情况下，成员变量的访问访问成员变量的两种方式： 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。 2.6多态情况下，成员方法的访问当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。 代码举例： 定义父类 1234567891011121314151617181920package demo02;public class Fu /*extends Object*/ &#123; int num = 10; public void showNum() &#123; System.out.println(num); &#125; public void method() &#123; System.out.println(\"父类方法\"); &#125; public void methodFu() &#123; System.out.println(\"父类特有方法\"); &#125;&#125; 定义子类 12345678910111213141516171819202122package demo02;public class Zi extends Fu &#123; int num = 20; int age = 16; @Override public void showNum() &#123; System.out.println(num); &#125; @Override public void method() &#123; System.out.println(\"子类方法\"); &#125; public void methodZi() &#123; System.out.println(\"子类特有方法\"); &#125;&#125; 定义测试类 1234567891011121314151617181920package demo02;public class Test &#123; public static void main(String[] args) &#123; // 使用多态的写法，父类引用指向子类对象 Fu obj = new Zi(); System.out.println(obj.num); // 10 // 子类没有覆盖重写，就是父：10子类，如果覆盖重写，就是子：20 obj.showNum();//20 // 父子都有，优先用子 obj.method();//子类方法 // 子类没有，父类有，向上找到父类 obj.methodFu();//父类特有方法 // 编译看左边，左边是Fu，Fu当中没有methodZi方法，所以编译报错。obj.methodZi(); 错误写法！ &#125;&#125; 2.7多态的好处实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。代码如下： 定义父类： 12345package demo03;public abstract class Animal &#123; public abstract void eat();&#125; 定义子类Cat 1234567package demo03;class Cat extends Animal &#123; public void eat() &#123; System.out.println(\"吃鱼\"); &#125;&#125; 定义子类Dog 1234567package demo03;class Dog extends Animal &#123; public void eat() &#123; System.out.println(\"吃骨头\"); &#125;&#125; 定义测试类 123456789101112131415161718192021222324252627282930package demo03;public class Test &#123; public static void main(String[] args) &#123; // 多态形式，创建对象 Cat c = new Cat(); Dog d = new Dog(); // 调用showCatEat showCatEat(c); // 调用showDogEat showDogEat(d); /*以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代 而执行效果一致 */ showAnimalEat(c); showAnimalEat(d); &#125; public static void showCatEat(Cat c) &#123; c.eat(); &#125; public static void showDogEat(Dog d) &#123; d.eat(); &#125; public static void showAnimalEat(Animal a) &#123; a.eat(); &#125;&#125; 由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。 2.8多态的弊端当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，不能调用子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 2.9引用类型转换多态的转型分为向上转型与向下转型两种： 向上转型 向上转型：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 当父类引用指向一个子类对象时，便是向上转型。 使用格式 12父类类型 变量名 = new 子类类型();如：Animal a = new Cat(); 2.10向下转型向下转型：父类类型向子类类型向下转换的过程，这个过程是强制的。一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。 使用格式： 12子类类型 变量名 = 子类类型 父类变量名;如：Cat c = (Cat) a; 2.11转型的异常转型的过程中，一不小心就会遇到这样的问题，请看如下代码： 12345678910public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 Dog d = (Dog) a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【运行报错】 &#125;&#125; 这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系，不符合类型转换的定义。为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下： 123变量名 instanceof 数据类型如果变量属于该数据类型，返回true；如果变量不属于该数据类型，返回fase。 所以，转换前，我们最好先做一个判断，代码如下： 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); a.eat(); // 调用的是 Cat 的 eat // 向下转型 if (a instanceof Cat) &#123; Cat c = (Cat) a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; else if (a instanceof Dog) &#123; Dog d = (Dog) a; d.watchHouse(); // 调用的是 Dog 的 watchHouse &#125; &#125;&#125; 3.接口多态的综合案例笔记本电脑笔记本电脑（laptop）通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口，但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。 案例分析进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘 USB接口，包含开启功能、关闭功能 笔记本类，包含运行功能、关机功能、使用USB设备功能 鼠标类，要实现USB接口，并具备点击的方法 键盘类，要实现USB接口，具备敲击的方法 案例实现定义USB接口： 1234567package demo04;interface USB &#123; void open();// 开启功能 void close();// 关闭功能&#125; 定义鼠标类： 123456789101112131415package demo04;class Mouse implements USB &#123; public void open() &#123; System.out.println(\"鼠标开启，红灯闪一闪\"); &#125; public void close() &#123; System.out.println(\"鼠标关闭，红灯熄灭\"); &#125; public void click() &#123; System.out.println(\"鼠标单击\"); &#125;&#125; 定义键盘类： 123456789101112131415package demo04;class KeyBoard implements USB &#123; public void open() &#123; System.out.println(&quot;键盘开启，绿灯闪一闪&quot;); &#125; public void close() &#123; System.out.println(&quot;键盘关闭，绿灯熄灭&quot;); &#125; public void type() &#123; System.out.println(&quot;键盘打字&quot;); &#125;&#125; 定义笔记本类： 1234567891011121314151617181920212223242526272829package demo04;public class Laptop &#123; &#x2F;&#x2F; 笔记本开启运行功能 public void run() &#123; System.out.println(&quot;笔记本运行&quot;); &#125; &#x2F;&#x2F; 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备 public void useUSB(USB usb) &#123; &#x2F;&#x2F; 判断是否有USB设备 if (usb !&#x3D; null) &#123; usb.open(); &#x2F;&#x2F; 类型转换,调用特有方法 if (usb instanceof Mouse) &#123; Mouse m &#x3D; (Mouse) usb; m.click(); &#125; else if (usb instanceof KeyBoard) &#123; KeyBoard kb &#x3D; (KeyBoard) usb; kb.type(); &#125; usb.close(); &#125; &#125; public void shutDown() &#123; System.out.println(&quot;笔记本关闭&quot;); &#125;&#125; 测试类，代码如下： 1234567891011121314151617181920package demo04;public class Test &#123; public static void main(String[] args) &#123; // 创建笔记本实体对象 Laptop lt = new Laptop(); // 笔记本开启 lt.run(); // 创建鼠标实体对象 USB u = new Mouse(); // 笔记本使用鼠标 lt.useUSB(u); // 创建键盘实体对象 KeyBoard kb = new KeyBoard(); // 笔记本使用键盘 lt.useUSB(kb); // 笔记本关闭 lt.shutDown(); &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"8-String类、static关键字、Arrays类、 Math类","slug":"8-String类、static关键字、Arrays类、-Math类","date":"2020-03-18T14:31:09.000Z","updated":"2020-03-18T14:52:02.913Z","comments":true,"path":"2020/03/18/8-String类、static关键字、Arrays类、-Math类/","link":"","permalink":"http://yoursite.com/2020/03/18/8-String%E7%B1%BB%E3%80%81static%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81Arrays%E7%B1%BB%E3%80%81-Math%E7%B1%BB/","excerpt":"String类、static关键字、Arrays类、 Math类1.String类","text":"String类、static关键字、Arrays类、 Math类1.String类 1.1概述java.lang.String 类代表字符串。Java程序中所有的字符串文字（例如 “abc” ）都可以被看作是实现此类的实例。类 String 中包括用于检查各个字符串的方法，比如用于比较字符串，搜索字符串，提取子字符串以及创建具有翻译为大写或小写的所有字符的字符串的副本。 1.2特点 字符串不变：字符串的值在创建后不能被更改 12345678910111213141516public class Demo &#123; public static void main(String[] args) &#123; /* 下面这种写法，字符串的内容仍然是没有改变的 下面有两个字符串：\"Hello\"，\"Java\" strA当中保存的是地址值 本来地址值是Hello地址值 后来地址值变成了Java的地址值 */ String strA = \"Hello\"; System.out.println(strA); // Hello strA = \"Java\"; System.out.println(strA); // Java &#125; &#125; 因为String对象是不可变的，所以它们可以被共享。 1234//字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中。 常量池中的的字符串可以共享使用String s1 = \"abc\";String s2 = \"abc\"; // 内存中只有一个\"abc\"对象被创建，同时被s1和s2共享。 字符串效果上相当于是char[]字符数组，例如：”abc” 等效于 char[] data={ ‘a’ , ‘b’ , ‘c’ } 。但是底层原理是byte[]字节数组。 123456//例如：String str = \"abc\"; //相当于：char data[] = &#123;'a', 'b', 'c'&#125;; String str = new String(data); // String底层是靠字符数组实现的。 1.3使用步骤查看类 java.lang.String ：此类不需要导入。 查看构造方法 public String() ：初始化新创建的 String对象，以使其表示空字符序列。 public String(char[] value) ：通过当前参数中的字符数组来构造新的String。 public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的String。 注意： 直接写上双引号，就是字符串对象。也是一种创建字符串对象的方法。 构造举例，代码如下： 12345678910111213141516171819202122232425package demo01;public class Demo01String &#123; public static void main(String[] args) &#123; // 使用空参构造，小括号留空，说明字符串什么内容都没有。 String str1 = new String(); System.out.println(\"第1个字符串：\" + str1);//第1个字符串： // 根据字符数组创建字符串 char[] charArray = &#123;'A', 'B', 'C'&#125;; String str2 = new String(charArray); System.out.println(\"第2个字符串：\" + str2);//第2个字符串：ABC // 根据字节数组创建字符串 byte[] byteArray = &#123;97, 98, 99&#125;; String str3 = new String(byteArray); System.out.println(\"第3个字符串：\" + str3);//第3个字符串：abc // 直接创建 String str4 = \"Hello\"; System.out.println(\"第4个字符串：\" + str4);//第4个字符串：Hello &#125;&#125; 1.4判断功能的方法 public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。 public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小写。 注意事项： 任何对象都能用Object进行接收。 equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。推荐：”abc”.equals(str) 不推荐：str.equals(“abc”) Object 是” 对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中。 方法演示，代码如下： 1234567891011121314151617181920package demo02;public class String_Demo01 &#123; public static void main(String[] args) &#123; // 创建字符串对象 String s1 = \"hello\"; String s2 = \"hello\"; String s3 = \"HELLO\"; // boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(s1.equals(s2));// true System.out.println(s1.equals(s3)); // false //boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 System.out.println(s1.equalsIgnoreCase(s2)); // true System.out.println(s1.equalsIgnoreCase(s3)); // true // 注意，只有英文字母区分大小写，其他都不区分大小写 System.out.println(\"abc一123\".equalsIgnoreCase(\"abc壹123\")); // false &#125;&#125; 1.5获取功能的方法 public int length () ：返回此字符串的长度。 public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 public char charAt (int index) ：返回指定索引处的 char值。 public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 如果根本没有，返回-1值 方法演示，代码如下： 12345678910111213141516171819202122232425package demo02;public class String_Demo02 &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = \"hello world\"; // int length():获取字符串的长度，其实也就是字符个数 System.out.println(s.length());//11 // String concat (String str):将将指定的字符串连接到该字符串的末尾. String s1 = s.concat(\"1234\"); System.out.println(s1);//hello world1234 // char charAt(int index):获取指定索引处的字符 System.out.println(s.charAt(0)); //h System.out.println(s.charAt(1));//e // int indexOf(String str):获取str在字符串对象中第一次出现的索引,没有返回‐1 System.out.println(s.indexOf(\"l\"));//2 System.out.println(s.indexOf(\"owo\"));//-1 System.out.println(s.indexOf(\"ak\"));//-1 &#125;&#125; 1.6字符串的截取方法： public String substring(int index)：截取从参数位置一直到字符串末尾，返回新字符串。 public String substring(int begin, int end)：截取从begin开始，一直到end结束，中间的字符串。备注：[begin,end)，包含左边，不包含右边。 方法演示，代码如下 123456789101112131415161718package demo02;public class Demo03Substring &#123; public static void main(String[] args) &#123; String str1 = \"HelloWorld\"; //// String substring(int start):从start开始截取字符串到字符串结尾 String str2 = str1.substring(5); System.out.println(str1); // HelloWorld System.out.println(str2); // World // String substring(int start,int end):从start到end截取字符串。含start，不含end。 String str3 = str1.substring(4, 7); System.out.println(str3); // oWo &#125;&#125; 1.7转换功能的方法 public char[] toCharArray () ：将此字符串转换为新的字符数组。 public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。 public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。备注：CharSequence 是一个接口，也是一种引用类型。作为参数类型，可以把String对象传递到方法中。 方法演示，代码如下： 1234567891011121314151617181920212223242526package demo02;public class Demo04StringConvert &#123; public static void main(String[] args) &#123; // 转换成为字符数组 char[] chars = \"Hello\".toCharArray(); System.out.println(chars[0]); // H System.out.println(chars.length); // 5 // 转换成为字节数组 byte[] bytes = \"abc\".getBytes(); for (int i = 0; i &lt; bytes.length; i++) &#123; System.out.println(bytes[i]); &#125; // 字符串的内容替换 String str1 = \"How do you do?\"; String str2 = str1.replace(\"o\", \"*\"); System.out.println(str1); // How do you do? System.out.println(str2); // H*w d* y*u d*? &#125;&#125; 1.8分割字符串的方法： public String[] split(String regex)：按照参数的规则，将字符串切分成为若干部分。 注意事项： split方法的参数其实是一个“正则表达式”。 如果按照英文句点“.”进行切分，必须写”\\.”（两个反斜杠） 方法演示，代码如下 123456789101112package demo02;public class Demo05StringSplit &#123; public static void main(String[] args) &#123; //创建字符串对象 String s = \"aa bb cc\"; String[] strArray = s.split(\" \"); for (int x = 0; x &lt; strArray.length; x++) &#123; System.out.print(strArray[x]); // aa bb cc &#125; &#125;&#125; 1.9练习键盘输入一个字符串，并且统计其中各种字符出现的次数。种类有：大写字母、小写字母、数字、其他 代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package demo02;import java.util.Scanner;/*思路：1. 既然用到键盘输入，肯定是Scanner2. 键盘输入的是字符串，那么：String str = sc.next();3. 定义四个变量，分别代表四种字符各自的出现次数。4. 需要对字符串一个字、一个字检查，String--&gt;char[]，方法就是toCharArray()5. 遍历char[]字符数组，对当前字符的种类进行判断，并且用四个变量进行++动作。6. 打印输出四个变量，分别代表四种字符出现次数。 */public class Demo07StringCount &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入一个字符串：\"); String input = sc.next(); // 获取键盘输入的一个字符串 int countUpper = 0; // 大写字母 int countLower = 0; // 小写字母 int countNumber = 0; // 数字 int countOther = 0; // 其他字符 char[] charArray = input.toCharArray(); for (int i = 0; i &lt; charArray.length; i++) &#123; char ch = charArray[i]; // 当前单个字符 if ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z') &#123; countUpper++; &#125; else if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z') &#123; countLower++; &#125; else if ('0' &lt;= ch &amp;&amp; ch &lt;= '9') &#123; countNumber++; &#125; else &#123; countOther++; &#125; &#125; System.out.println(\"大写字母有：\" + countUpper); System.out.println(\"小写字母有：\" + countLower); System.out.println(\"数字有：\" + countNumber); System.out.println(\"其他字符有：\" + countOther); &#125;&#125; 2.static关键字2.1概述关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 2.2类变量当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。 类变量：使用 static关键字修饰的成员变量。 定义格式： 1static 数据类型 变量名 举例： 1static int numberID 比如说，基础班新班开班，学员报到。现在想为每一位新来报到的同学编学号（sid），从第一名同学开始，sid为1，以此类推。学号必须是唯一的，连续的，并且与班级的人数相符，这样以便知道，要分配给下一名新同学的学号是多少。这样我们就需要一个变量，与单独的每一个学生对象无关，而是与整个班级同学数量有关。所以，我们可以这样定义一个静态变量numberOfStudent，代码如下： 12345678910111213141516171819202122package demo03;public class Student &#123; private String name; private int age; // 学生的id private int sid; // 类变量，记录学生数量，分配学号 public static int numberOfStudent = 0; public Student(String name, int age) &#123; this.name = name; this.age = age; // 通过 numberOfStudent 给学生分配学号 this.sid = ++numberOfStudent; &#125; // 打印属性值 public void show() &#123; System.out.println(\"Student : name=\" + name + \", age=\" + age + \", sid=\" + sid); &#125;&#125; 定义测试类 12345678910111213141516package demo03;public class StuDemo &#123; public static void main(String[] args) &#123; Student s1 = new Student(\"张三\", 23); Student s2 = new Student(\"李四\", 24); Student s3 = new Student(\"王五\", 25); Student s4 = new Student(\"赵六\", 26); s1.show(); // Student : name=张三, age=23, sid=1 s2.show(); // Student : name=李四, age=24, sid=2 s3.show(); // Student : name=王五, age=25, sid=3 s4.show(); // Student : name=赵六, age=26, sid=4 &#125;&#125; 2.3静态方法当 static 修饰成员方法时，该方法称为类方法 。静态方法在声明中有 static ，建议使用类名来调用，而不需要创建类的对象。调用方式非常简单。 类方法：使用 static关键字修饰的成员方法，习惯称为静态方法。 定义格式： 123修饰符 static 返回值类型 方法名 （参数列表）&#123; //执行语句&#125; 举例：在Students类中定义静态方法 123public static void showNumber()&#123; System.out.println(\"num\" + numberOfstudent);&#125; 注意事项： 静态不能直接访问非静态。原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。 静态方法当中不能用this。原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。 2.4调用被static修饰的成员可以并且建议通过类名直接访问。虽然也可以通过对象名访问静态成员，原因即多个对象均属于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。 格式： 12345// 访问类变量类名.类变量名 // 调用静态方法类名.静态方法名（参数） 调用演示，代码如下： 12345678public class StuDemo2&#123; public static void main(String[] args)&#123; // 访问类变量 System.out.println(Student.numberOfStudent); // 调用静态方法 Student.showNum(); &#125;&#125; 2.5静态原理图解static 修饰的内容： 是随着类的加载而加载的，且只加载一次。 存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 它优先于对象存在，所以，可以被所有对象共享。 2.6静态代码块静态代码块：定义在成员位置，使用static修饰的代码块{ }。 位置：类中方法外。 执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。 格式： 12345public class ClassName&#123; static &#123; //执行语句 &#125;&#125; 作用：给类变量进行初始化赋值。用法演示，代码如下： 123456789101112131415import java.util.ArrayList;public class Demo &#123; public static int number; public static ArrayList&lt;String&gt; list; static &#123; &#x2F;&#x2F; 给类变量赋值 number &#x3D; 2; list &#x3D; new ArrayList&lt;String&gt;(); &#x2F;&#x2F; 添加元素到集合中 list.add(&quot;张三&quot;); list.add(&quot;李四&quot;); &#125;&#125; 3.Arrays类3.1概述java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 3.2操作数组的方法 public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。 123456789101112131415import java.util.ArrayList;import java.util.Arrays;public class Demo &#123; public static void main(String[] args) &#123; // 定义int 数组 int[] arr = &#123;2, 34, 35, 4, 657, 8, 69, 9&#125;; // 打印数组,输出地址值 System.out.println(arr); // [I@2ac1fdc4 // 数组内容转为字符串 String s = Arrays.toString(arr); // 打印字符串,输出内容 System.out.println(s); // [2, 34, 35, 4, 657, 8, 69, 9] &#125;&#125; public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。 备注： 如果是数值，sort默认按照升序从小到大 如果是字符串，sort默认按照字母升序 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。 方法演示，代码如下 12345678910111213import java.util.ArrayList;import java.util.Arrays;public class Demo &#123; public static void main(String[] args) &#123; &#x2F;&#x2F; 定义int 数组 int[] arr &#x3D; &#123;24, 7, 5, 48, 4, 46, 35, 11, 6, 2&#125;; System.out.println(&quot;排序前:&quot;+ Arrays.toString(arr)); &#x2F;&#x2F; 排序前:[24, 7, 5, 48, 4, 46, 35, 11, 6, 2] &#x2F;&#x2F; 升序排序 Arrays.sort(arr); System.out.println(&quot;排序后:&quot;+ Arrays.toString(arr));&#x2F;&#x2F; 排序后:[2, 4, 5, 6, 7, 11, 24, 35, 46, 48] &#125;&#125; 3.3练习1234567891011121314151617181920212223242526package demo04;import java.util.Arrays;/*题目：请使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。 */public class Demo02ArraysPractise &#123; public static void main(String[] args) &#123; String str = \"asv76agfqwdfvasdfvjh\"; // 如何进行升序排列：sort // 必须是一个数组，才能用Arrays.sort方法 // String --&gt; 数组，用toCharArray char[] chars = str.toCharArray(); Arrays.sort(chars); // 对字符数组进行升序排列 // 需要倒序遍历 for (int i = chars.length - 1; i &gt;= 0; i--) &#123; System.out.println(chars[i]); &#125; &#125;&#125; 4.Math类4.1概述java.lang.Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。成员变量，Math.PI代表近似的圆周率常量（double）。 4.2常用方法 public static double abs(double num)：获取绝对值。有多种重载。 public static double ceil(double num)：向上取整。 public static double floor(double num)：向下取整。 public static long round(double num)：四舍五入。 方法演示，代码如下 12345678910111213141516171819202122232425262728package demo04;public class Demo03Math &#123; public static void main(String[] args) &#123; // 获取绝对值 System.out.println(Math.abs(3.14)); // 3.14 System.out.println(Math.abs(0)); // 0 System.out.println(Math.abs(-2.5)); // 2.5 System.out.println(\"================\"); // 向上取整 System.out.println(Math.ceil(3.9)); // 4.0 System.out.println(Math.ceil(3.1)); // 4.0 System.out.println(Math.ceil(3.0)); // 3.0 System.out.println(\"================\"); // 向下取整，抹零 System.out.println(Math.floor(30.1)); // 30.0 System.out.println(Math.floor(30.9)); // 30.0 System.out.println(Math.floor(31.0)); // 31.0 System.out.println(\"================\"); System.out.println(Math.round(20.4)); // 20 System.out.println(Math.round(10.5)); // 11 &#125;&#125; 4.2练习12345678910111213141516171819202122232425262728293031323334353637package demo04;/*题目：计算在-10.8到5.9之间，绝对值大于6或者小于2.1的整数有多少个？分析：1. 既然已经确定了范围，for循环2. 起点位置-10.8应该转换成为-10，两种办法： 2.1 可以使用Math.ceil方法，向上（向正方向）取整 2.2 强转成为int，自动舍弃所有小数位3. 每一个数字都是整数，所以步进表达式应该是num++，这样每次都是+1的。4. 如何拿到绝对值：Math.abs方法。5. 一旦发现了一个数字，需要让计数器++进行统计。备注：如果使用Math.ceil方法，-10.8可以变成-10.0。注意double也是可以进行++的。 */public class Demo04MathPractise &#123; public static void main(String[] args) &#123; int count = 0; // 符合要求的数量 double min = -10.8; double max = 5.9; // 这样处理，变量i就是区间之内所有的整数 for (int i = (int) min; i &lt; max; i++) &#123; int abs = Math.abs(i); // 绝对值 if (abs &gt; 6 || abs &lt; 2.1) &#123; System.out.println(i); count++; &#125; &#125; System.out.println(\"总共有：\" + count); // 总共有：9 &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"1-常识、入门程序、常量、变量","slug":"1-常识、入门程序、常量、变量","date":"2020-03-18T13:49:05.000Z","updated":"2020-03-18T13:55:39.727Z","comments":true,"path":"2020/03/18/1-常识、入门程序、常量、变量/","link":"","permalink":"http://yoursite.com/2020/03/18/1-%E5%B8%B8%E8%AF%86%E3%80%81%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F/","excerpt":"常识、入门程序、常量、变量1.常识","text":"常识、入门程序、常量、变量1.常识 1.1什么是Java语言Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。 1.2Java语言发展历史 1995年Sun公司发布Java1.0版本 1997年发布Java 1.1版本 1998年发布Java 1.2版本 2000年发布Java 1.3版本 2002年发布Java 1.4版本 2004年发布Java 5版本 2006年发布Java 6版本 2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java 7版本 2014年发布Java 8版本 2017年发布Java 9版本 1.3Java语言能做什么Java语言主要应用在互联网程序的开发领域。常见的互联网程序比如天猫、京东、物流系统、网银系统等，以及服务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。 1.4计算机基础知识二进制 计算机中的数据不同于人们生活中的数据，人们生活采用十进制数，而计算机中全部采用二进制数表示，它只包含0、1两个数，逢二进一，1+1=10。每一个0或者每一个1，叫做一个bit（比特）。 下面了解一下十进制和二进制数据之间的转换计算。 十进制数据转成二进制数据：使用除以2获取余数的方式 二进制数据转成十进制数据：使用8421编码的方式 字节 字节是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性，我们可以查看文件的字节大小。8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B，1 Byte = 8 bit。常见的存储单元换算关系如下： 1 KB = 1024 Byte 1 MB = 1024 KB 1 GB = 1024 MB 1 TB = 1024 GB 1 PB = 1024 TB 1 EB = 1024 PB 1 ZB = 1024 EB 1.5键盘按键示意图在开发Java语言之前，我们必须对键盘上的常用按键进行了解，如下图所示。 1.6DOS操作系统Java语言的初学者，学习一些DOS命令，会非常有帮助。DOS是一个早期的操作系统，现在已经被Windows系统取代，对于我们开发人员，目前需要在DOS中完成一些事情，因此就需要掌握一些必要的命令。 进入DOS操作窗口 按下Windows+R键盘，打开运行窗口，输入cmd回车，进入到DOS的操作窗口。 打开DOS命令行后，看到一个路径 c:\\user 就表示我们现在操作的磁盘是c盘。 常用命令 2.Java语言开发环境搭建在开发Java语言之前，我们必须了解一下Java中相应的名词及如何搭建开发环境 2.1什么是JRE 丶JDK 丶JVM？ JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。 JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。 我们想要运行一个已有的Java程序，那么只需安装 JRE 即可。 JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 我们想要开发一个全新的Java程序，那么必须安装 JDK 。 三者关系： JDK &gt; JRE &gt; JVM 如下图所示 2.2Java语言最重要的特性跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。 2.3JDK的下载与安装进入官网https://www.oracle.com/technetwork/java/javase/archive-139210.html下载自己想要的版本进行安装。 1：双击下载好的软件包，进入如下界面 2：点击下一步 注意： 我们可以点击更改选择自己安装的路径，路径中不建议包含有中文和空格。 因为JDK包含了JRE，因此我们可以取消公共JRE的安装 3：点击下一步，等待安装完成。 2.4JAVA_HOME环境变量的配置配置环境变量作用 开发Java程序，需要使用JDK中提供的工具，工具在JDK9安装目录的 bin 目录下。 在DOS命令行下使用这些工具，就要先进入到JDK的bin目录下，这个过程就会非常的麻烦。 为了开发方便，我们想在任意的目录下都可以使用JDK的开发工具，则必须要配置环境变量，配置环境变量的意义在于告诉操作系统，我们使用的JDK开发工具在哪个目录下。 2.5配置环境变量步骤Windows 10 版本 文件资源管理器 –&gt; 此电脑鼠标右键 –&gt; 选择 属性 选择 高级系统设置 –&gt; 选择 环境变量 点击下方系统变量的 新建 ，创建新的环境变量，变量名输入 JAVA_HOME ，变量值输入JDK9的安装目录D:\\02_DevelopTools\\Java\\jdk-9.0.1 （安装目录的路径以自己电脑上的为准） 选中 Path 环境变量， 双击 或者 点击编辑 点击 新建 ，键入 %JAVA_HOME%\\bin ，必须是英文格式。选中该行，上移到最上方，点击确定。 环境变量配置完成，重新开启DOS命令行，在任意目录下输入 javac 命令。 3.HelloWorld入门程序3.1程序开发步骤说明开发环境已经搭建完毕，可以开发我们第一个Java程序了。Java程序开发三步骤：编写、编译、运行。 3.2：编写Java源程序首先：在 d:\\day01 目录下新建文本文件，完整的文件名修改为 HelloWorld.java ，其中文件名为 HelloWorld ，后缀名必须为 .java 。 之后：用记事本打开 最后：在文件中键入代码并保存，代码如下： 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"hello world\"); &#125;&#125; tips： 我们必须保证文件名和类的名字是一致的，注意大小写。每个字母和符号必须与示例代码一模一样。 第一个 HelloWord 源程序就编写完成了，但是这个文件是程序员编写的，JVM是看不懂的，也就不能运行，因此我们必须将编写好的 Java源文件 编译成JVM可以看懂的 字节码文件 。 3.3：编译Java源文件在DOS命令行中，进入Java源文件的目录，使用 javac 命令进行编译。 命令： 编译成功后，命令行没有任何提示。打开 d:\\day01 目录，发现产生了一个新的文件 HelloWorld.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。Java源文件的编译工具 javac.exe ，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目录下使用。 3.4：运行Java程序在DOS命令行中，进入Java源文件的目录，使用 java 命令进行运行。 命令： Java程序 .class文件的运行工具 java.exe ，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目录下使用。 3.5入门程序说明编译和运行是两回事 编译：是指将我们编写的Java源文件翻译成JVM认识的class文件，在这个过程中， javac 编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。 运行：是指将 class文件 交给JVM去运行，此时JVM就会去执行我们编写的程序了。 3.6关于main方法 main方法：称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多少程序，JVM在运行的时候，都会从main方法这里开始执行。 3.7添加注释comment 注释：就是对代码的解释和说明。其目的是让人们能够更加轻松地了解代码。为代码添加注释，是十分必须要的，它不影响程序的编译和运行。 Java中有单行注释和多行注释 单行注释：以 //开头 换行结束 多行注释：以 /*开头 以*/结束 我们以刚才的HelloWorld案例进行注释的演示 1234567891011//类是Java当中所有源代码的基本组织单位。public class HelloWorld &#123; /* 称为主方法。写法是固定格式不可以更改。main方法是程序的入口点或起始点，无论我们编写多 少程序，JVM在运行的时候，都会从main方法这里开始执行。 */ public static void main(String[] args) &#123; //打印输出语句（其实就是屏幕显示） System.out.println(\"hello world\"); &#125;&#125; 3.8关键字keywords关键字：是指在程序中，Java已经定义好的单词，具有特殊含义。HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被Java定义好，全部都是小写字母，智能开发工具中颜色特殊。关键字比较多，不能死记硬背，学到哪里记到哪里即可。 3.9标识符 标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。HelloWorld案例中，出现的标识符有类名字 HelloWorld 。 命名规则： 硬性要求 标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 标识符不能以数字开头。 标识符不能是关键字。 命名规范： 软性建议 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 变量名规范：全部小写。 4.常量4.1概念 常量：是指在Java程序中固定不变的数据。 常量的分类如下图所示 代码演示，输出各种类型的常量 12345678910111213141516171819202122232425262728293031323334353637383940/*常量：在程序运行期间，固定不变的量。常量的分类：1. 字符串常量：凡是用双引号引起来的部分，叫做字符串常量。例如：\"abc\"、\"Hello\"、\"123\"2. 整数常量：直接写上的数字，没有小数点。例如：100、200、0、-2503. 浮点数常量：直接写上的数字，有小数点。例如：2.5、-3.14、0.04. 字符常量：凡是用单引号引起来的单个字符，就做字符常量。例如：'A'、'b'、'9'、'中'5. 布尔常量：只有量中取值。true、false。6. 空常量：null。代表没有任何数据。*/public class Demo01Const &#123; public static void main(String[] args) &#123; // 字符串常量 System.out.println(\"ABC\");//ABC // 字符串两个双引号中间的内容可以为空 System.out.println(\"\"); System.out.println(\"XYZ\");//XYZ // 整数常量 System.out.println(30);//30 System.out.println(-500);//-500 // 浮点数常量（小数） System.out.println(3.14);//3.14 System.out.println(-2.5);//-2.5 // 字符常量 System.out.println('A');//A System.out.println('6');//6 // System.out.println(''); 错误，两个单引号中间必须有且仅有一个字符，没有不行。 // System.out.println('AB'); 错误 两个单引号中间必须有且仅有一个字符，有两个不行。 // 布尔常量 System.out.println(true);//true System.out.println(false);//false // System.out.println(null);错误 空常量不能直接用来打印输出。 &#125;&#125; 5.数据类型Java的数据类型分为两大类： 基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。 引用数据类型：包括 类 、 数组 、 接口等等 。 5.1基本数据类型四类八种基本数据类型如下图所示： 注意事项： 字符串不是基本类型，而是引用类型。 浮点型可能只是一个近似值，并非精确的值。 数据范围与字节数不一定相关，例如float数据范围比long更加广泛，但是float是4字节，long是8字节。 浮点数当中默认类型是double。如果一定要使用float类型，需要加上一个后缀F。如果是整数，默认为int类型，如果一定要使用long类型，需要加上一个后缀L。推荐使用大写字母后缀。 6.变量6.1概念变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。数学中，可以使用字母代替数字运算,例如 x=1+5 或者 6=x+5。程序中，可以使用字母保存数字的方式进行运算，提高计算能力，可以解决更多的问题。比如x保存5，x也可以保存6，这样x保存的数据是可以改变的，也就是我们所讲解的变量。Java中要求一个变量每次只能保存一个数据，必须要明确保存的数据类型。 6.2变量的定义变量定义的格式包括三个要素： 数据类型 、 变量名 、 数据值 。 格式1： 数据类型 变量名称; 含义： 创建了一个变量 变量名称 = 数据值; 含义：将右边的数据值，赋值交给左边的变量 举例： 1234567891011121314public class Demo &#123; public static void main(String[] args) &#123; // 创建一个变量age 格式：数据类型 变量名称; int age; // 向变量age当中存入一个数据 格式：变量名称 = 数据值; age = 10; // 当打印输出变量名称的时候，显示出来的是变量的内容 System.out.println(age); // 10 // 改变变量当中本来的数字，变成新的数字 age = 20; System.out.println(age); // 20 &#125;&#125; 格式2： 数据类型 变量名称 = 数据值; 含义：在创建一个变量的同时，立刻放入指定的数据值 举例 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; // 创建一个变量age,并且向它里面存储数据 格式：数据类型 变量名称 = 数据值; int age = 25; // 当打印输出变量名称的时候，显示出来的是变量的内容 System.out.println(age); // 25 // 改变变量当中本来的数字，变成新的数字 age = 20; System.out.println(age); // 20 &#125;&#125; 代码演示，定义所有基本数据类型的变量并且打印输出 1234567891011121314151617181920212223242526272829303132333435public class Variable &#123; public static void main(String[] args) &#123; //定义字节型变量 byte b = 100; System.out.println(b);//100 //定义短整型变量 short s = 1000; System.out.println(s);//1000 //定义整型变量 int i = 123456; System.out.println(i);//123456 //定义长整型变量 long l = 12345678900L; System.out.println(l);//12345678900 //定义单精度浮点型变量 float f = 5.5F; System.out.println(f);//5.5 //定义双精度浮点型变量 double d = 8.5; System.out.println(d);//8.5 //定义布尔型变量 boolean bool = false; System.out.println(bool);//false //定义字符型变量 char c = 'A'; System.out.println(c);//A &#125;&#125; 6.3使用变量的注意事项： 如果创建多个变量，那么在同一个大括号范围内，变量的名字不可以相同。 对于float和long类型来说，字母后缀F和L不要丢掉。 变量右侧的数据值不能超过左侧类型的范围。 没有进行赋值的变量，不能直接使用；一定要赋值之后，才能使用。 变量使用不能超过作用域的范围。【作用域】：从定义变量的一行开始，一直到直接所属的大括号结束为止。 可以通过一个语句来创建多个变量，但是一般情况不推荐这么写。 代码演示，变量的注意事项： 123456789101112131415161718192021222324252627282930313233343536373839public class Demo03VariableNotice &#123; public static void main(String[] args) &#123; // 创建了一个新的变量，名叫num1 int num1 = 10; // int num1 = 20; 同一大括号里 又创建了另一个新的变量，名字也叫num1，错误！名字重复 //int num2 = 25454564654564650; 错误。右侧的数据值不能超过左侧类型的范围。 int num3; // 定义了一个变量，但是没有进行赋值 // System.out.println(num3); 错误，没有进行赋值的变量，不能直接使用；一定要赋值之后，才能使用。 // System.out.println(num4); 错误，在创建变量之前，不能使用这个变量 int num4 = 500; //此时num4变量，已经创建并且赋值，可以使用 System.out.println(num4);//500 &#123; int num5 = 60; System.out.println(num5); // 60 &#125; // System.out.println(num6); 已经超出了大括号的范围，超出了作用域，变量不能再使用了，我们可以当做这个变量不存在了。 // 同时创建了三个全都是int类型的变量，不推荐这么写。 int a, b, c; // 各自分别赋值 a = 10; b = 20; c = 30; System.out.println(a); // 10 System.out.println(b); // 20 System.out.println(c); // 30 // 同时创建三个int变量，并且同时各自赋值，不推荐这么写。 int x = 100, y = 200, z = 300; System.out.println(x); // 100 System.out.println(y); // 200 System.out.println(z); // 300 &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"六、Scrapy-Redis(2)——分布式爬虫组件","slug":"六、Scrapy-Redis-2-——分布式爬虫组件","date":"2020-02-14T12:46:49.000Z","updated":"2020-03-15T20:20:46.840Z","comments":true,"path":"2020/02/14/六、Scrapy-Redis-2-——分布式爬虫组件/","link":"","permalink":"http://yoursite.com/2020/02/14/%E5%85%AD%E3%80%81Scrapy-Redis-2-%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%AB%E7%BB%84%E4%BB%B6/","excerpt":"Scrapy-Redis分布式爬虫组件","text":"Scrapy-Redis分布式爬虫组件 Scrapy是一个框架，他本身是不支持分布式的。如果我们想要做分布式的爬虫，就需要借助一个组件叫做 Scrapy-Redis，这个组件正是利用了Redis可以分布式的功能，集成到 Scrapy框架中，使得爬虫可以进行分布式。可以充分的利用资源(多个ip、更多带宽、同步爬取)来提高爬虫的爬行效率。 分布式爬虫的优点： 可以充分利用多台机器的带宽。 可以充分利用多台机器的ip地址。 多台机器做，爬取效率更高。 分布式爬虫必须要解决的问题： 分布式爬虫是好几台机器在同时运行，如何保证不同的机器爬取页面的时候不会出现重复爬取的问题。 同样，分布式爬虫在不同的机器上运行，在把数据爬完后如何保证保存在同一个地方。 安装通过 pip install scrapy-redis 即可安装 Scrapy-Redis架构Scrapy架构图： Scrapy-Redis架构图： 分布式爬虫架构图： 以上两个图片对比我们可以发现。Item Pipeline在接收到数据后发送给了Redis、Scheduler调度器调度数据也是从Redis中来的、并且其实数据去重也是在Redis中做的。 编写Scrapy-Redis分布式爬虫要将一个Scrapy项目变成一个Scrapy-Redis项目只需修改以下三点就可以了： 1、将爬虫的类从scrap.Spider变成scrapy_redis.spiders.RedisSpider或者是从scrapy.CrawlSpider变成scrapy_redis.spiders.RedisCrawlSpider。 2、将爬虫中的start_urls删掉。增加一个redis_key=&quot;xxx&quot;。这个redis_key是为了以后在redis中控制爬虫启动的。爬虫的第一个url，就是在redis中通过这个发送出去的。 3、在配置文件中增加如下配置： 1# Scrapy-Redis 相关配置``# 确保 request 存储到redis 中``SCHEDULER ``=` `\"scrapy_redis.scheduler.Scheduler\"` `# 确保所有爬虫共享相同的去重指纹``DUPEFILTER_CLASS ``=` `\"scrapy_redis.dupefilter.RFPDupeFilter\"` `# 设置redis为item pipeline``ITEM_PIPELINES ``=` `&#123;`` ``'scrapy_redis.pipelines.RedisPipeline'``: ``300``,``&#125;` `# 在redis中保持 scrapy-redis用到的队列，不会清理redis中的队列，从而可以实现暂停和恢复的功能。``SCHEDULER_PERSIST ``=` `True` `# 设置连接redis信息``REDIS_HOST ``=` `'192.168.1.9'``REDIS_PORT ``=` `6379 4、运行爬虫 在爬虫服务器上，进入爬虫所在的路径，然后输入命令：scrapy runspider [爬虫名字]。 1scrapy runspider sfw.py 在Redis服务器上，推入一个开始的url链接：redis-cli&gt; lpush [redis_key] start_url开始爬取。 1lpush fang:start_urls https:``//www``.fang.com``/SoufunFamily``.htm","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"六、Scrapy-Redis(1)——redis介绍","slug":"六、Scrapy-Redis-1-——redis介绍","date":"2020-02-14T12:45:38.000Z","updated":"2020-03-15T20:21:10.365Z","comments":true,"path":"2020/02/14/六、Scrapy-Redis-1-——redis介绍/","link":"","permalink":"http://yoursite.com/2020/02/14/%E5%85%AD%E3%80%81Scrapy-Redis-1-%E2%80%94%E2%80%94redis%E4%BB%8B%E7%BB%8D/","excerpt":"redis教程","text":"redis教程 概述redis是一种支持分布式的nosql数据库，他的数据库是保存在内存中，同时redis可以定时把内在数据同步到磁盘，即可以将数据持久化。并且他比memcached支持更多的数据结构(string，list列表[队列和栈],set[集合]，sorted set[有序集合]，hash(hash表))。 相关参考文档：http://redisdoc.com/index.html redis使用场景 登录会话存储：存储在 redis中，与 memcached相比，数据不会丢失。 排行榜/计数器：比如一些秀场类的项目，经常会有一些前多少名的主播排名。还有一些文章阅读量的技术，或者新浪微博的占赞数等。 作为消息队列：比如celery就是使用redis作为中间件。 当前在线人数：还是之前的秀场例子，会显示当前系统有多少在线人数。 一些常用的数据缓存：比如我们的BBS论坛，板块不会经常变化的，但是每次访问首页都要从mysql中获取，可以在redis中缓存起来，不用每次请求数据库。 把前200篇文章缓存或者评论缓存：一般用户浏览网站，只会浏览前面一部分文章或者评论，那么可以把前面200篇文章和对应的评论缓存起来。用户访问超过的，就访问数据库，并且以后文章超过200篇，则把之前的文章删除。 好友关系：微博的好友关系使用redis 实现。 发布和订阅功能：可以用来做聊天软件。 redis 和 memcached 的比较 memcached Redis 类型 纯内存数据库 内存磁盘同步数据库 数据类型 在定义value时就要固定数据类型 不需要 虚拟内存 不支持 支持 过期策略 支持 支持 存储数据安全 不支持 可以将数据同步到dump.db中 灾难恢复 不支持 可以将磁盘中的数据恢复到内存中 分布式 支持 主从同步 订阅与发布 不支持 支持 redis 在 ubuntu 系统中的安装与启动 安装： 1sudo apt-get install redis-server 卸载： 1sudo apt-get purge --auto-remove redis-server 启动： redis 安装后，默认会自动启动，可以通过以下命令查看： 1ps aux | grep redis 如果想自己手动启动，可以通过以下命令进行启动： 1sudo service redis-server start 停止： 1sudo service redis-server stop redis 在 windows 系统中的安装与启动 下载：redis官方是不支持windows操作系统的。但是微软的开源部门将redis移植到了windows上。因此下载地址不是在redis官网上。而是在github上：https://github.com/MicrosoftArchive/redis/releases 安装：点击下一步安装就可以了。 运行：进入到redis所在的安装路径然后执行redis-server.exe redis.windows.conf就可以运行了。 连接：redis和mysql以及mongo是一样的，都提供了一个客户端进行连接。输入命令redis-cli(前提是redis安装路径已经加入到环境变量中了)就可以连接到redis服务器了。 其他机器访问本地redis服务器想要让其他机器访问本机的redis服务器，那么要修改redis.conf的配置文件。将bind改成bind[自己的ip地址或者0.0.0.0]，其他机器才能访问。 注意：bind绑定的是本机网卡的ip地址，而不是想让其他机器连接的ip地址。如果有多块网卡，那么可以绑定多个网卡的ip地址。如果绑定到的是0.0.0.0，那么意味着其他机器可以通过本机所有的ip地址进行访问。 对 redis 的操作对 redis 的操作可以用两种方式，第一种方式采用 redis-cli ，第二种方式采用编程语言，比如 Python、PHP和JAVA 等。 使用 redis-cli 对 redis 进行字符串操作： 启动 redis： 1sudo service redis-server start 连接上 redis-server： 12redis-cli -h [ip] -p [端口]# redis-cli -h 192.168.1.8 -p 6379 字符串操作 添加： 123set key value如：set username xiaotuo 将字符串值value关联到key。如果key已经持有其他值，set命令就覆写旧值，无视其类型。并且默认的过期时间是永久，即永远不会过期。 删除： 123del key如：del username 设置过期时间： 1expire key timeout(单位为秒) 也可以在设置值的时候，一同指定过期时间： 123set key value EX timeout或：setex key timeout value 查看过期时间： 123ttl key如：ttl username 查看当前 redis 中的所有key： 1key * 列表操作： 在列表左边添加元素： 1lpush key value 将值 value插入到列表key的表头。如果key不存在，一个空列表会被创建并执行lpush操作。当key存在但不是列表类型时，将返回一个错误。 在列表右边添加元素： 1rpush key value 将值 value插入到列表key的末尾。如果key不存在，一个空列表会被创建并执行rpush操作。当key存在但不是列表类型时，将返回一个错误。 查看列表中的元素： 1lrange key start stop 返回列表key中指定区间内的元素，区间以偏移量start和stop指定。如果要左边的第一个到最后的一个lrange key 0 -1。 移除列表中的元素： 移除并返回列表key的头元素： 1lpop key 移除并返回列表的尾元素： 1rpop key 移除并返回列表key的中间元素： 1lrem key count value 将删除key这个列表中，count个值为value的元素。 指定返回第几个元素： 1lindex key index 将返回key这个列表中，索引为index的这个元素。 获取列表中的元素个数： 123llen key如：llen languages 删除指定的元素： 123lrem key count value如：lrem languages 0 php 根据参数count的值，移除列表中与参数value相等的元素。count的值可以是以下几种： Count &gt; 0：从表头开始向表尾搜索，移除与value相等的元素，数量为count。 Count &lt; 0：从表尾开始向表头搜索，移除与value相等的元素，数量为count的绝对值。 Count = 0：移除表中所有与value相等的值。 set集合的操作： 添加元素： 123sadd set value1 value2...如：sadd team xiaotuo datuo 查看元素： 123smembers set如：smembers team 移除元素： 123srem set member...如：srem team xiaotuo datuo 查看集合中的元素个数： 123scard set如：scard team1 获取多个集合的交集： 123sinter set1 set2如：sinter team1 team2 获取各个集合的并集： 123sunion set1 set2如：sunion team1 team2 获取两个集合的差集： 123sdiff set1 set2如：sdiff team1 team2 Hash 哈希操作： 添加一个新值： 123hset key field value如：hset website baidu baidu.com 将哈希表key中的域field的值设为value。 如果key不存在，一个新的哈希表被创建并进行HSET操作。如果域field已经存在于哈希表中，旧值将被覆盖。 获取哈希中的field对应的值： 123hget key field如：hget website baidu 删除field中的某个value 123hdel key field如：hdel website baidu 获取某个哈希中所有的field和value： 123hgetall key如：hgetall website 获取某个哈希中所有field： 123hkeys key如：hkeys website 获取某个哈希中所有的值： 123hvals key如：hvals website 判断哈希中是否存在某个field： 123hexists key field如：hexists website baidu 获取哈希中总共的键值对： 123hlen field如：hlen website 事务操作：Redis事务可以一次执行多个命令，事务具有以下特征： 隔离操作：事务中的所有命令都会序列化、按顺序地执行，不会被其他命令打扰。 原子操作：事务中的命令要么全部被执行，要么全部都不执行。 开启一个事务： 1multi 以后执行的所有命令，都在这个事务中执行的。 执行事务： 1exec 会将在multi和exec中的操作一并提交。 取消事务： 1discard 会将multi后的所有命令取消。 监视一个或者多个key： 1watch key... 监视一个(或多个)key，如果在事务执行之前这个(或这些)key被其他命令所改动，那么事务将被打断。 取消所有key的监视： 1unwatch 发布/订阅操作： 给某个频道发布消息： 1publish channel message 订阅某个频道的消息： 1subscribe channel","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"五、Scrapy框架(8)——scrapy爬虫实战","slug":"五、Scrapy框架-8-——scrapy爬虫实战","date":"2020-02-14T12:44:11.000Z","updated":"2020-02-14T12:45:05.664Z","comments":true,"path":"2020/02/14/五、Scrapy框架-8-——scrapy爬虫实战/","link":"","permalink":"http://yoursite.com/2020/02/14/%E4%BA%94%E3%80%81Scrapy%E6%A1%86%E6%9E%B6-8-%E2%80%94%E2%80%94scrapy%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98/","excerpt":"小程序社区爬虫","text":"小程序社区爬虫 数据保存到json文件中。使用 CrawlSpider 模拟登录豆瓣网爬虫发送 post 请求模拟登录 图片下载爬虫汽车之家宝马5系爬虫 BOSS直聘爬虫BOSS直聘有很高的反爬虫机制，只要用同 个IP访问多个职位列表页，就会被封掉IP。采用代理ip的方式可解决问题。 简书网站整站爬虫数据保存到mysql数据库中 将 selenium + chromedriver集成到scrapy 一、页面解析 在终端中创建项目 123scrapy startproject jianshu_spidercd jianshu_spiderscrapy genspider -t crawl js &quot;jianshu.com&quot; 用Pycharm打开项目，修改settings.py配置，打开请求头 1234567ROBOTSTXT_OBEY &#x3D; FalseDEFAULT_REQUEST_HEADERS &#x3D; &#123; &#39;Accept&#39;: &#39;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8&#39;, &#39;Accept-Language&#39;: &#39;en&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;73.0.3683.86 Safari&#x2F;537.36&#39;&#125; 新建 start.py文件，用于启动项目 12from scrapy import cmdlinecmdline.execute(&quot;scrapy crawl js&quot;.split()) 分析网页，选择要爬虫的项目，在items.py创建ArticleItem类 12345678910import scrapyclass ArticleItem(scrapy.Item): title &#x3D; scrapy.Field() # 标题 content &#x3D; scrapy.Field() # 内容 article_id &#x3D; scrapy.Field() # 文章id origin_url &#x3D; scrapy.Field() # 原始地址 author &#x3D; scrapy.Field() # 作者 avatar &#x3D; scrapy.Field() # 头像 pub_time &#x3D; scrapy.Field() # 发布时间 开始写爬虫js.py 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom jianshu_spider.items import ArticleItemclass JsSpider(CrawlSpider): name &#x3D; &#39;js&#39; allowed_domains &#x3D; [&#39;jianshu.com&#39;] start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.jianshu.com&#x2F;&#39;] rules &#x3D; ( Rule(LinkExtractor(allow&#x3D;r&#39;.*&#x2F;p&#x2F;[0-9a-z]&#123;12&#125;&#39;), callback&#x3D;&#39;parse_detail&#39;, follow&#x3D;True), ) def parse_detail(self, response): title &#x3D; response.xpath(&quot;&#x2F;&#x2F;h1[@class&#x3D;&#39;title&#39;]&#x2F;text()&quot;).get() avatar &#x3D; response.xpath(&quot;&#x2F;&#x2F;a[@class&#x3D;&#39;avatar&#39;]&#x2F;img&#x2F;@src&quot;).get() author &#x3D; response.xpath(&quot;&#x2F;&#x2F;span[@class&#x3D;&#39;name&#39;]&#x2F;a&#x2F;&#x2F;text()&quot;).get() pub_time &#x3D; response.xpath(&quot;&#x2F;&#x2F;span[@class&#x3D;&#39;publish-time&#39;]&#x2F;&#x2F;text()&quot;).get() # https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;66aeb8473df1?&#x2F;u&#x2F;052e3bd4d2bc?utm_campaign&#x3D;maleskine&amp;utm_content&#x3D;user&amp;utm_medium&#x3D;seo_notes&amp;utm_source&#x3D;recommendation url &#x3D; response.url url1 &#x3D; url.split(&quot;?&quot;)[0] article_id &#x3D; url1.split(&#39;&#x2F;&#39;)[-1] content &#x3D; response.xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;show-content&#39;]&quot;).get() item &#x3D; ArticleItem( title&#x3D;title, avatar&#x3D;avatar, author&#x3D;author, pub_time&#x3D;pub_time, article_id&#x3D;article_id, origin_url&#x3D;response.url, content&#x3D;content ) yield item 二、数据保存到Mysql数据库 在settings.py中打开 ITEM_PIPELINES设置 123456ITEM_PIPELINES &#x3D; &#123; &#39;jianshu_spider.pipelines.JianshuSpiderPipeline&#39;: 300,&#125;# 下载延迟3秒钟DOWNLOAD_DELAY &#x3D; 3 在mysql中创建 jianshu数据库，新建 article表 编写pipelines.py，连接数据库 123456789101112131415161718192021222324252627282930313233import pymysqlfrom pymysql import cursorsclass JianshuSpiderPipeline(object): def __init__(self): dbparams &#x3D; &#123; &#39;host&#39;: &#39;127.0.0.1&#39;, &#39;port&#39;: 3306, &#39;user&#39;: &#39;root&#39;, &#39;password&#39;: &#39;root&#39;, &#39;database&#39;: &#39;jianshu&#39;, &#39;charset&#39;: &#39;utf8&#39; &#125; self.conn &#x3D; pymysql.connect(**dbparams) self.cursor &#x3D; self.conn.cursor() self._sql &#x3D; None def process_item(self, item, spider): self.cursor.execute(self.sql, ( item[&#39;title&#39;], item[&#39;content&#39;], item[&#39;author&#39;], item[&#39;avatar&#39;], item[&#39;pub_time&#39;], item[&#39;origin_url&#39;], item[&#39;article_id&#39;])) self.conn.commit() return item @property def sql(self): if not self._sql: self._sql &#x3D; &quot;&quot;&quot; insert into article(title,content,author,avatar,pub_time,origin_url,article_id) values(%s,%s,%s,%s,%s,%s,%s) &quot;&quot;&quot; return self._sql return self._sql 改成异常处理,pipelines.py 12345678910111213141516171819202122232425262728293031323334353637383940import pymysqlfrom twisted.enterprise import adbapifrom pymysql import cursorsclass JianshuTwistedPipeline(object): def __init__(self): dbparams &#x3D; &#123; &#39;host&#39;: &#39;127.0.0.1&#39;, &#39;port&#39;: 3306, &#39;user&#39;: &#39;root&#39;, &#39;password&#39;: &#39;root&#39;, &#39;database&#39;: &#39;jianshu&#39;, &#39;charset&#39;: &#39;utf8&#39;, &#39;cursorclass&#39;: cursors.DictCursor &#125; self.dbpool &#x3D; adbapi.ConnectionPool(&#39;pymysql&#39;, **dbparams) self._sql &#x3D; None @property def sql(self): if not self._sql: self._sql &#x3D; &quot;&quot;&quot; insert into article(title,content,author,avatar,pub_time,origin_url,article_id) values(%s,%s,%s,%s,%s,%s,%s) &quot;&quot;&quot; return self._sql return self._sql def process_item(self, item, spider): defer &#x3D; self.dbpool.runInteraction(self.insert_item, item) defer.addErrback(self.handle_error,item,spider) def insert_item(self, cursor, item): cursor.execute(self.sql,( item[&#39;title&#39;], item[&#39;content&#39;], item[&#39;author&#39;], item[&#39;avatar&#39;], item[&#39;pub_time&#39;], item[&#39;origin_url&#39;], item[&#39;article_id&#39;])) def handle_error(self, error, item, spider): print(&#39;&#x3D;&#39;*10+&quot;error&quot;+&#39;&#x3D;&#39;*10) print(error) print(&#39;&#x3D;&#39;*10+&quot;error&quot;+&#39;&#x3D;&#39;*10) 把settings.py中的ITEM_PIPELINES改一下 1234ITEM_PIPELINES &#x3D; &#123; # &#39;jianshu_spider.pipelines.JianshuSpiderPipeline&#39;: 300, &#39;jianshu_spider.pipelines.JianshuTwistedPipeline&#39;: 300,&#125; 三、爬取ajax数据将 selenium + chromedriver集成到scrapy 在数据库加入阅读、喜欢、字数、专题、评论数 字段 在items.py中添加字段 12345678910111213141516import scrapyclass ArticleItem(scrapy.Item): title &#x3D; scrapy.Field() # 标题 content &#x3D; scrapy.Field() # 内容 article_id &#x3D; scrapy.Field() # 文章id origin_url &#x3D; scrapy.Field() # 原始地址 author &#x3D; scrapy.Field() # 作者 avatar &#x3D; scrapy.Field() # 头像 pub_time &#x3D; scrapy.Field() # 发布时间 read_count &#x3D; scrapy.Field() # 阅读量 like_count &#x3D; scrapy.Field() # 喜欢 word_count &#x3D; scrapy.Field() # 字数 comment_count &#x3D; scrapy.Field() # 评论数 subjects &#x3D; scrapy.Field() # 专题 编写 middlewares.py 123456789101112131415161718192021222324from scrapy.http import HtmlResponsefrom selenium import webdriverimport timeclass SeleniumDownloadMiddleware(object): def __init__(self): self.driver &#x3D; webdriver.Chrome(executable_path&#x3D;&quot;&#x2F;Users&#x2F;ren&#x2F;Applications&#x2F;chromedriver&quot;) def process_request(self, request, spider): self.driver.get(request.url) time.sleep(1) try: while True : showMore &#x3D; self.driver.find_elements_by_class_name(&#39;show-more&#39;) showMore.click() time.sleep(0.3) if not showMore: break except: pass source &#x3D; self.driver.page_source response &#x3D; HtmlResponse(url&#x3D;self.driver.current_url, body&#x3D;source, request&#x3D;request) return response 优化 js.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: utf-8 -*-import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom jianshu_spider.items import ArticleItemclass JsSpider(CrawlSpider): name &#x3D; &#39;js&#39; allowed_domains &#x3D; [&#39;jianshu.com&#39;] start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.jianshu.com&#x2F;&#39;] rules &#x3D; ( Rule(LinkExtractor(allow&#x3D;r&#39;.*&#x2F;p&#x2F;[0-9a-z]&#123;12&#125;&#39;), callback&#x3D;&#39;parse_detail&#39;, follow&#x3D;True), ) def parse_detail(self, response): title &#x3D; response.xpath(&quot;&#x2F;&#x2F;h1[@class&#x3D;&#39;title&#39;]&#x2F;text()&quot;).get() avatar &#x3D; response.xpath(&quot;&#x2F;&#x2F;a[@class&#x3D;&#39;avatar&#39;]&#x2F;img&#x2F;@src&quot;).get() author &#x3D; response.xpath(&quot;&#x2F;&#x2F;span[@class&#x3D;&#39;name&#39;]&#x2F;a&#x2F;&#x2F;text()&quot;).get() pub_time &#x3D; response.xpath(&quot;&#x2F;&#x2F;span[@class&#x3D;&#39;publish-time&#39;]&#x2F;&#x2F;text()&quot;).get() # https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;66aeb8473df1?&#x2F;u&#x2F;052e3bd4d2bc?utm_campaign&#x3D;maleskine&amp;utm_content&#x3D;user&amp;utm_medium&#x3D;seo_notes&amp;utm_source&#x3D;recommendation url &#x3D; response.url url1 &#x3D; url.split(&quot;?&quot;)[0] article_id &#x3D; url1.split(&#39;&#x2F;&#39;)[-1] content &#x3D; response.xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;show-content&#39;]&quot;).get() word_count &#x3D; response.xpath(&quot;&#x2F;&#x2F;span[@class&#x3D;&#39;wordage&#39;]&#x2F;text()&quot;).get() comment_count &#x3D; response.xpath(&quot;&#x2F;&#x2F;span[@class&#x3D;&#39;comments-count&#39;]&#x2F;text()&quot;).get() read_count &#x3D; response.xpath(&quot;&#x2F;&#x2F;span[@class&#x3D;&#39;views-count&#39;]&#x2F;text()&quot;).get() like_count &#x3D; response.xpath(&quot;&#x2F;&#x2F;span[@class&#x3D;&#39;likes-count&#39;]&#x2F;text()&quot;).get() subjects &#x3D; &quot;,&quot;.join(response.xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;include-collection&#39;]&#x2F;a&#x2F;div&#x2F;text()&quot;).getall()) item &#x3D; ArticleItem( title&#x3D;title, avatar&#x3D;avatar, author&#x3D;author, pub_time&#x3D;pub_time, article_id&#x3D;article_id, origin_url&#x3D;response.url, content&#x3D;content, word_count&#x3D;word_count, read_count&#x3D;read_count, like_count&#x3D;like_count, comment_count&#x3D;comment_count, subjects&#x3D;subjects ) yield item 把下载中间件加到 settings.py中 123DOWNLOADER_MIDDLEWARES &#x3D; &#123; &#39;jianshu_spider.middlewares.SeleniumDownloadMiddleware&#39;: 543,&#125;","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"五、Scrapy框架(7)——下载器中间件","slug":"五、Scrapy框架-7-——下载器中间件","date":"2020-02-14T12:42:57.000Z","updated":"2020-02-14T12:43:38.717Z","comments":true,"path":"2020/02/14/五、Scrapy框架-7-——下载器中间件/","link":"","permalink":"http://yoursite.com/2020/02/14/%E4%BA%94%E3%80%81Scrapy%E6%A1%86%E6%9E%B6-7-%E2%80%94%E2%80%94%E4%B8%8B%E8%BD%BD%E5%99%A8%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"Downloader Middlewares(下载器中间件)","text":"Downloader Middlewares(下载器中间件) 下载器中间件是引擎和下载器之间通信的中间件。在这个中间件中我们可以设置代理、更换请求头等来达到反的爬虫的目的。更写下载器中间件，可以在下载器中实现两个方法。一个process_request(self,request,spider)，这个方法是在请求发送之前会执行，还有一个是process_response(self, request, response, spider)，这个方法是数据下载到引擎之间执行。 process_request(self,request,spider)这个方法是下载器在发送请求之前会执行的。一般可以在这个里面设置随机代理ip等。 参数： request：发送请求的request对象 spider：发送请求的spider对象 返回值： 返回None：如果返回None，Scrapy将继续处理该request，执行其他中间件中的相应方法，直到合适的下载器处理函数被调用。 返回Response对象：Scrapy将不会调用任何其他的 process_request方法，将直接返回这个response对象。已经激活的中间件的process_response()方法则会在每个response返回时被调用。 返回Request对象：不再使用之前的request对象去下载数据，而是根据现在返回的request对象返回数据。 如果这个方法抛出了异常，则会调用process_exception方法。 process_response(self, request, response, spider)这个是下载器下载的数据到引擎中间会执行的方法。 参数： request：request对象 response：被处理的response对象 spider：spider对象 返回值： 返回Response对象：会将这个新的response对象传给其他中间件，最终传给爬虫。 返回Request对象：下载器链接被切断，返回的request会重新被下载器调度下载。 如果抛出一个异常，那么调用request的errback方法，如果没有指定这个方法，那么会抛出一个异常。 随机请求头中间件爬虫在频繁访问一个页面的时候，这个请求头如果一直保持一致。那么很容易被服务器发现，从而禁止掉这个请求头的访问。因此我们要在访问这个页面之前随机的更改请求头，这样才可以避免爬虫被抓。随机更改请求头，可以在下载中间件中实现。在请求发送给服务器之前，随机的选择一个请求头。这样就可以避免总使用一个请求头了。示例代码如下： 12345678class UserAgentDownloadMiddleware(object): USER_AGENTS &#x3D; [ &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;73.0.3683.86 Safari&#x2F;537.36&#39;, &#39;Mozilla&#x2F;4.0 (compatible;MSIE 8.0;Windows NT 6.0;Trident&#x2F;4.0)&#39; ] def process_request(self,request,spider): user_agent &#x3D; random.choice(self.USER_AGENTS) request.headers[&#39;User-Agent&#39;] &#x3D; user_agent user-agent列表：http://www.useragentstring.com/pages/useragentstring.php?typ=Browser ip代理池中间件购买代理 在以下代理商中购买代理： 芝麻代理：http://http.zhimaruanjian.com/ 太阳代理：http://http.taiyangruanjian.com 快代理：http://www.kuaidaili.com 讯代理：http://www.xdaili.com 蚂蚁代理：http://www.mayidaili.com 等购买代理。 使用ip代理池1.示例代码如下： 12345678910111213class IPProxyDownloadMiddleware(object): PROXIES &#x3D; [ &quot;5.196.189.50:8080&quot;, &#39;134.17.141.44:8080&#39;, &quot;178.49.136.84:8080&quot;, &quot;45.55.132.29:82&quot;, &quot;178.44.185.15:8080&quot; ] def process_request(self,request,spider): proxy &#x3D; &quot;121.199.6.124:16816&quot; user_password&#x3D; &quot;970138074:rcdj35ur&quot; request.meta[&#39;proxy&#39;] &#x3D; proxy request.headers[&#39;Proxy-Authorization&#39;] &#x3D; &#39;Basic&#39; + base64.b64encode(user_password.encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;) 2.独享代理池设置 1234567class IPProxyDownloadMiddleware(object): def process_request(self,request,spider): proxy &#x3D; &quot;121.199.6.124:16816&quot; user_password&#x3D; &quot;970138074:rcdj35ur&quot; request.meta[&quot;proxy&quot;] &#x3D; proxy b64_user_passwrod &#x3D; base64.b64encode(user_password.encode(&#39;utf-8&#39;)) request.headers[&#39;Proxy-Authorization&#39;] &#x3D; &#39;Basic&#39; + b64_user_passwrod.decode(&#39;utf-8&#39;)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"五、Scrapy框架(6)——下载文件和图片","slug":"五、Scrapy框架-6-——下载文件和图片","date":"2020-02-14T12:41:32.000Z","updated":"2020-02-14T12:42:19.592Z","comments":true,"path":"2020/02/14/五、Scrapy框架-6-——下载文件和图片/","link":"","permalink":"http://yoursite.com/2020/02/14/%E4%BA%94%E3%80%81Scrapy%E6%A1%86%E6%9E%B6-6-%E2%80%94%E2%80%94%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E5%92%8C%E5%9B%BE%E7%89%87/","excerpt":"下载文件和图片","text":"下载文件和图片 Scrapy为下载item中包含的文件(比如在爬取到产品时，同时也想保存对应的图片)提供了一个可重用的item pipelines。这些 pipeline有些共同的方法和结构(我们称之为 media pipeline)。一般来说会使用 Files pipeline或者 Image Pipeline。 为什么要选择使用 scrapy 内置的下载文件的方法 避免重新下载最近已经下载过的数据。 可以方便的指定文件存储的路径。 可以将下载的图片转换成通用的格式。比如png或jpg。 可以方便的生成缩略图。 可以方便的检测图片的宽和高，确保他们满足最小限制。 异步下载，效率非常高。 下载文件的 Files Pipeline当使用Files Pipeline 下载文件的时候，按照以下步骤来完成： 定义好一个Items ，然后在这个 item 中定义两个属性，分别为 file_urls 以及 files。file_urls是用来存储需要下载的图片的url链接，需要给一个列表。 当文件下载完成后，会把文件下载的相关信息存储到item的files属性中。比如下载路径、下载的url和文件的校验码等。 在配置文件 settings.py中配置 FILES_STORE，这个配置是用来设置文件下载下来的路径。 启动 pipeline：在 ITEM_PIPELINES中设置 scrapy.pipelines.files.FilesPipeline:1。 下载图片的 Image Pipeline当使用Image Pipeline下载文件的时候，按照以下步骤来完成： 定义好一个Item，然后在这个 Item 中定义两个属性，分别为 image_urls以及 images。image_urls是用来存储需要下载的图片的url链接，需要给一个列表。 当文件下载完成后，会把文件下载的相关信息存储到item的images属性中。比如下载路径、下载的url和文件的校验码等。 在配置文件 settings.py中配置 IMAGES_STORE，这个配置是用来设置文件下载下来的路径。 启动 pipeline：在 ITEM_PIPELINES中设置 scrapy.pipelines.images.ImagesPipeline:1。","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"五、Scrapy框架(5)——Request和Response对象","slug":"五、Scrapy框架-5-——Request和Response对象","date":"2020-02-14T12:35:46.000Z","updated":"2020-02-14T12:40:05.710Z","comments":true,"path":"2020/02/14/五、Scrapy框架-5-——Request和Response对象/","link":"","permalink":"http://yoursite.com/2020/02/14/%E4%BA%94%E3%80%81Scrapy%E6%A1%86%E6%9E%B6-5-%E2%80%94%E2%80%94Request%E5%92%8CResponse%E5%AF%B9%E8%B1%A1/","excerpt":"Request和Response对象","text":"Request和Response对象 Request对象123456789101112131415161718192021222324252627 1 class Request(object_ref): 2 3 def __init__(self, url, callback&#x3D;None, method&#x3D;&#39;GET&#39;, headers&#x3D;None, body&#x3D;None, 4 cookies&#x3D;None, meta&#x3D;None, encoding&#x3D;&#39;utf-8&#39;, priority&#x3D;0, 5 dont_filter&#x3D;False, errback&#x3D;None, flags&#x3D;None): 6 7 self._encoding &#x3D; encoding # this one has to be set first 8 self.method &#x3D; str(method).upper() 9 self._set_url(url)10 self._set_body(body)11 assert isinstance(priority, int), &quot;Request priority not an integer: %r&quot; % priority12 self.priority &#x3D; priority13 14 if callback is not None and not callable(callback):15 raise TypeError(&#39;callback must be a callable, got %s&#39; % type(callback).__name__)16 if errback is not None and not callable(errback):17 raise TypeError(&#39;errback must be a callable, got %s&#39; % type(errback).__name__)18 assert callback or not errback, &quot;Cannot use errback without a callback&quot;19 self.callback &#x3D; callback20 self.errback &#x3D; errback21 22 self.cookies &#x3D; cookies or &#123;&#125;23 self.headers &#x3D; Headers(headers or &#123;&#125;, encoding&#x3D;encoding)24 self.dont_filter &#x3D; dont_filter25 26 self._meta &#x3D; dict(meta) if meta else None27 self.flags &#x3D; [] if flags is None else list(flags) Request对象在我们写爬虫，爬取一面的数据需要重新发送一个请求的时候调用。这个类需要传递一些参数，其中比较常用的参数有： url：这个request对象发送请求的url。 callback：在下载器下载完相应的数据后执行的回调函数。 method：请求的方法。默认为GET方法，可以设置为其他方法。 headers：请求头，对于一些固定的设置，放在settings.py中指定就可以了。对于那些非固定的，可以在发送请求的时候指定。 meta：比较常用。用于在不同的请求之间传递数据用的。 encoding：编码。默认的为utf-8，使用默认的就可以了。 dont_filter：表示不由调度器过滤。在执行多次重复的请求的时候用得比较多。 errback：在发生错误的时候执行的函数。 Response对象Response对象一般是由scrapy给你自动构建的。因此开发者不需要关心如何创建Response对象，而是如何使用它。Response对象有很多属性，可以用来提取数据的。主要有以下属性： meta：从其他请求传过来的meta属性，可以用来保持多个请求之间的数据连接。 encoding：返回当前字符串编码和解码的格式。 text：将返回来的数据作为unicode字符串返回。 body：将返回的数据作为bytes字符串返回。 xpath：xpath选择器。 css：css选择器。 发送POST请求有时候我们想要在请求数据的时候发送post请求，那么这时候需要使用 Request的子类和FormRequest 来实现。如果想要在爬虫一开始的时候就发送 POST 请求，那么需要在爬虫类中重写 start_requests(self) 方法，并且不再调用 start_urls 里的url。 模拟登录案例一：模拟登录人人网 想要发送post请求，那么推荐使用scrapy.FormRequest方法。可以方便的指定表单数据。 如果想在爬虫一开始的时候就发送post请求，那么应该重写start_requests方法。在这个方法中，发送post请求。 renren.py 12345678910111213141516171819202122# -*- coding: utf-8 -*-import scrapyclass RenrenSpider(scrapy.Spider): name &#x3D; &#39;renren&#39; allowed_domains &#x3D; [&#39;renren.com&#39;] start_urls &#x3D; [&#39;http:&#x2F;&#x2F;renren.com&#x2F;&#39;] def start_requests(self): url &#x3D; &#39;http:&#x2F;&#x2F;www.renren.com&#x2F;PLogin.do&#39; data &#x3D; &#123;&quot;email&quot;: &quot;renjy185911222@126.com&quot;, &#39;password&#39;: &#39;caonima001&#39;&#125; request &#x3D; scrapy.FormRequest(url, formdata&#x3D;data, callback&#x3D;self.parse_page) yield request def parse_page(self, response): request &#x3D; scrapy.Request(url&#x3D;&#39;http:&#x2F;&#x2F;www.renren.com&#x2F;880151247&#x2F;profile&#39;,callback&#x3D;self.parse_profile) yield request def parse_profile(self,response): with open(&#39;dp.html&#39;,&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;) as fp: fp.write(response.text) settings.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 1 # -*- coding: utf-8 -*- 2 3 # Scrapy settings for renren_login project 4 # 5 # For simplicity, this file contains only settings considered important or 6 # commonly used. You can find more settings consulting the documentation: 7 # 8 # https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;settings.html 9 # https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;downloader-middleware.html10 # https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;spider-middleware.html11 12 BOT_NAME &#x3D; &#39;renren_login&#39;13 14 SPIDER_MODULES &#x3D; [&#39;renren_login.spiders&#39;]15 NEWSPIDER_MODULE &#x3D; &#39;renren_login.spiders&#39;16 17 # Crawl responsibly by identifying yourself (and your website) on the user-agent18 # USER_AGENT &#x3D; &#39;renren_login (+http:&#x2F;&#x2F;www.yourdomain.com)&#39;19 20 # Obey robots.txt rules21 ROBOTSTXT_OBEY &#x3D; False22 23 # Configure maximum concurrent requests performed by Scrapy (default: 16)24 # CONCURRENT_REQUESTS &#x3D; 3225 26 # Configure a delay for requests for the same website (default: 0)27 # See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;settings.html#download-delay28 # See also autothrottle settings and docs29 # DOWNLOAD_DELAY &#x3D; 330 # The download delay setting will honor only one of:31 # CONCURRENT_REQUESTS_PER_DOMAIN &#x3D; 1632 # CONCURRENT_REQUESTS_PER_IP &#x3D; 1633 34 # Disable cookies (enabled by default)35 # COOKIES_ENABLED &#x3D; False36 37 # Disable Telnet Console (enabled by default)38 # TELNETCONSOLE_ENABLED &#x3D; False39 40 # Override the default request headers:41 DEFAULT_REQUEST_HEADERS &#x3D; &#123;42 &#39;Accept&#39;: &#39;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8&#39;,43 &#39;Accept-Language&#39;: &#39;en&#39;,44 &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;73.0.3683.86 Safari&#x2F;537.36&#39;45 &#125;46 47 # Enable or disable spider middlewares48 # See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;spider-middleware.html49 # SPIDER_MIDDLEWARES &#x3D; &#123;50 # &#39;renren_login.middlewares.RenrenLoginSpiderMiddleware&#39;: 543,51 # &#125;52 53 # Enable or disable downloader middlewares54 # See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;downloader-middleware.html55 # DOWNLOADER_MIDDLEWARES &#x3D; &#123;56 # &#39;renren_login.middlewares.RenrenLoginDownloaderMiddleware&#39;: 543,57 # &#125;58 59 # Enable or disable extensions60 # See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;extensions.html61 # EXTENSIONS &#x3D; &#123;62 # &#39;scrapy.extensions.telnet.TelnetConsole&#39;: None,63 # &#125;64 65 # Configure item pipelines66 # See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;item-pipeline.html67 # ITEM_PIPELINES &#x3D; &#123;68 # &#39;renren_login.pipelines.RenrenLoginPipeline&#39;: 300,69 # &#125;70 71 # Enable and configure the AutoThrottle extension (disabled by default)72 # See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;autothrottle.html73 # AUTOTHROTTLE_ENABLED &#x3D; True74 # The initial download delay75 # AUTOTHROTTLE_START_DELAY &#x3D; 576 # The maximum download delay to be set in case of high latencies77 # AUTOTHROTTLE_MAX_DELAY &#x3D; 6078 # The average number of requests Scrapy should be sending in parallel to79 # each remote server80 # AUTOTHROTTLE_TARGET_CONCURRENCY &#x3D; 1.081 # Enable showing throttling stats for every response received:82 # AUTOTHROTTLE_DEBUG &#x3D; False83 84 # Enable and configure HTTP caching (disabled by default)85 # See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;downloader-middleware.html#httpcache-middleware-settings86 # HTTPCACHE_ENABLED &#x3D; True87 # HTTPCACHE_EXPIRATION_SECS &#x3D; 088 # HTTPCACHE_DIR &#x3D; &#39;httpcache&#39;89 # HTTPCACHE_IGNORE_HTTP_CODES &#x3D; []90 # HTTPCACHE_STORAGE &#x3D; &#39;scrapy.extensions.httpcache.FilesystemCacheStorage&#39; Start.py 123from scrapy import cmdlinecmdline.execute(&quot;scrapy crawl renren&quot;.split()) 案例二：模拟登录豆瓣网(识别验证码)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"五、Scrapy框架(4)——Scrapy Shell","slug":"五、Scrapy框架-4-——Scrapy-Shell","date":"2020-02-14T12:33:30.000Z","updated":"2020-02-14T12:35:58.582Z","comments":true,"path":"2020/02/14/五、Scrapy框架-4-——Scrapy-Shell/","link":"","permalink":"http://yoursite.com/2020/02/14/%E4%BA%94%E3%80%81Scrapy%E6%A1%86%E6%9E%B6-4-%E2%80%94%E2%80%94Scrapy-Shell/","excerpt":"Scrapy Shell","text":"Scrapy Shell 我们想要在爬虫中使用xpath、beautifulsoup、正则表达式、css选择器等来提取想要的数据。但是因为scrapy是一个比较重的框架。每次运行起来都要等待一段时间。因此要去验证我们写的提取规则是否正确，是一个比较麻烦的事情。因此Scrapy提供了一个shell，用来方便的测试规则。当然也不仅仅局限于这一个功能。 打开Scrapy Shell：打开cmd终端，进入到Scrapy项目所在的目录，然后进入到scrapy框架所在的虚拟环境中，输入命令scrapy shell [链接]。就会进入到scrapy的shell环境中。在这个环境中，你可以跟在爬虫的parse方法中一样使用了。 Scrapy Shell笔记 可以方便我们做一些数据提取的测试代码。 如果想要执行scrapy命令，那么毫无疑问，肯定是要先进入到 scrapy所在的环境中。 如果想要读取某个项目的配置信息，那么应该先进入到这个项目中，再执行scrapy shell命令。","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"五、Scrapy框架(3)——CrawlSpider","slug":"五、Scrapy框架-3-——CrawlSpider","date":"2020-02-14T12:31:53.000Z","updated":"2020-02-14T12:36:04.542Z","comments":true,"path":"2020/02/14/五、Scrapy框架-3-——CrawlSpider/","link":"","permalink":"http://yoursite.com/2020/02/14/%E4%BA%94%E3%80%81Scrapy%E6%A1%86%E6%9E%B6-3-%E2%80%94%E2%80%94CrawlSpider/","excerpt":"CrawlSpider","text":"CrawlSpider 在上一个糗事百科的爬虫案例中。我们是自己在解析完整个页面后获取下一页的url，然后重新发送一个请求。有时候我们想要这样做，只要满足某个条件的url，都给我进行爬取。那么这时候我们就可以通过CrawlSpider来帮我们完成了。CrawlSpider继承自Spider，只不过是在之前的基础之上增加了新的功能，可以定义爬取的url的规则，以后scrapy碰到满足条件的url都进行爬取，而不用手动的yield Request。 CrawlSpider爬虫：创建CrawlSpider爬虫：之前创建爬虫的方式是通过scrapy genspider [爬虫名字] [域名]的方式创建的。如果想要创建CrawlSpider爬虫，那么应该通过以下命令创建： 1scrapy genspider -c crawl [爬虫名字] [域名] LinkExtractors链接提取器：使用LinkExtractors可以不用程序员自己提取想要的url，然后发送请求。这些工作都可以交给LinkExtractors，他会在所有爬的页面中找到满足规则的url，实现自动的爬取。以下对LinkExtractors类做一个简单的介绍： 12345678910111213class scrapy.linkextractors.LinkExtractor( allow &#x3D; (), deny &#x3D; (), allow_domains &#x3D; (), deny_domains &#x3D; (), deny_extensions &#x3D; None, restrict_xpaths &#x3D; (), tags &#x3D; (&#39;a&#39;,&#39;area&#39;), attrs &#x3D; (&#39;href&#39;), canonicalize &#x3D; True, unique &#x3D; True, process_value &#x3D; None) 主要参数讲解： allow：允许的url。所有满足这个正则表达式的url都会被提取。 deny：禁止的url。所有满足这个正则表达式的url都不会被提取。 allow_domains：允许的域名。只有在这个里面指定的域名的url才会被提取。 deny_domains：禁止的域名。所有在这个里面指定的域名的url都不会被提取。 restrict_xpaths：严格的xpath。和allow共同过滤链接。 Rule规则类：定义爬虫的规则类。以下对这个类做一个简单的介绍： 12345678class scrapy.spiders.Rule( link_extractor, callback &#x3D; None, cb_kwargs &#x3D; None, follow &#x3D; None, process_links &#x3D; None, process_request &#x3D; None) 主要参数讲解： link_extractor：一个LinkExtractor对象，用于定义爬取规则。 callback：满足这个规则的url，应该要执行哪个回调函数。因为CrawlSpider使用了parse作为回调函数，因此不要覆盖parse作为回调函数自己的回调函数。 follow：指定根据该规则从response中提取的链接是否需要跟进。 process_links：从link_extractor中获取到链接后会传递给这个函数，用来过滤不需要爬取的链接。 微信小程序社区CrawlSpider案例创建项目在文件夹内创建项目 1234scrapy startproject wxappcd wxapp# 使用 crawl 作为模板创建爬虫scrapy genspider -t crawl wxapp_spider &quot;wxapp-union.com&quot; CrawlSpider：需要使用LinkExtractor和Rule。这两个东西决定爬虫的具体走向。 allow设置规则的方法：要能够限制在我们想要的url上面，不要跟其他的url产生相同的正则表达式即可。 什么情况下使用follow：如果在爬取页面的时候需要将满足当前条件的url再进行跟进，那么就设置为True,否则设置为False。 什么情况下该指定callback：如果这个url对应的页面，只是为了获取更多的url，并不需要里面的数据，那么可以不指定callback。如果想要获取url对应页面中的数据，那么就需要指定一个callback。 Wxapp_spider.py 1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import scrapyfrom scrapy.linkextractors import LinkExtractorfrom scrapy.spiders import CrawlSpider, Rulefrom wxapp.items import WxappItemclass WxappSpiderSpider(CrawlSpider): name &#x3D; &#39;wxapp_spider&#39; allowed_domains &#x3D; [&#39;wxapp-union.com&#39;] start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.wxapp-union.com&#x2F;portal.php?mod&#x3D;list&amp;catid&#x3D;2&amp;page&#x3D;1&#39;] rules &#x3D; ( Rule(LinkExtractor(allow&#x3D;r&#39;.+mod&#x3D;list&amp;catid&#x3D;2&amp;page&#x3D;\\d&#39;), follow&#x3D;True), Rule(LinkExtractor(allow&#x3D;r&quot;.+article-.+\\.html&quot;), callback&#x3D;&quot;parse_detail&quot;, follow&#x3D;False) ) def parse_detail(self, response): title &#x3D; response.xpath(&quot;&#x2F;&#x2F;h1[@class&#x3D;&#39;ph&#39;]&#x2F;text()&quot;).get() author_p &#x3D; response.xpath(&quot;&#x2F;&#x2F;p[@class&#x3D;&#39;authors&#39;]&quot;) author &#x3D; author_p.xpath(&quot;.&#x2F;&#x2F;a&#x2F;text()&quot;).get() pub_time &#x3D; author_p.xpath(&quot;.&#x2F;&#x2F;span&#x2F;text()&quot;).get() article_content &#x3D; response.xpath(&quot;&#x2F;&#x2F;td[@id&#x3D;&#39;article_content&#39;]&#x2F;&#x2F;text()&quot;).getall() content &#x3D; &quot;&quot;.join(article_content).strip() item &#x3D; WxappItem(title&#x3D;title, author&#x3D;author, pub_time&#x3D;pub_time, content&#x3D;content) yield item items.py 123456789import scrapyclass WxappItem(scrapy.Item): # define the fields for your item here like: title &#x3D; scrapy.Field() author &#x3D; scrapy.Field() pub_time &#x3D; scrapy.Field() content &#x3D; scrapy.Field() settings.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# -*- coding: utf-8 -*-# Scrapy settings for wxapp project## For simplicity, this file contains only settings considered important or# commonly used. You can find more settings consulting the documentation:## https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;settings.html# https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;downloader-middleware.html# https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;spider-middleware.htmlBOT_NAME &#x3D; &#39;wxapp&#39;SPIDER_MODULES &#x3D; [&#39;wxapp.spiders&#39;]NEWSPIDER_MODULE &#x3D; &#39;wxapp.spiders&#39;# Crawl responsibly by identifying yourself (and your website) on the user-agent# USER_AGENT &#x3D; &#39;wxapp (+http:&#x2F;&#x2F;www.yourdomain.com)&#39;# Obey robots.txt rulesROBOTSTXT_OBEY &#x3D; False# Configure maximum concurrent requests performed by Scrapy (default: 16)# CONCURRENT_REQUESTS &#x3D; 32# Configure a delay for requests for the same website (default: 0)# See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;settings.html#download-delay# See also autothrottle settings and docsDOWNLOAD_DELAY &#x3D; 1# The download delay setting will honor only one of:# CONCURRENT_REQUESTS_PER_DOMAIN &#x3D; 16# CONCURRENT_REQUESTS_PER_IP &#x3D; 16# Disable cookies (enabled by default)# COOKIES_ENABLED &#x3D; False# Disable Telnet Console (enabled by default)# TELNETCONSOLE_ENABLED &#x3D; False# Override the default request headers:DEFAULT_REQUEST_HEADERS &#x3D; &#123; &#39;Accept&#39;: &#39;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8&#39;, &#39;Accept-Language&#39;: &#39;en&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;73.0.3683.86 Safari&#x2F;537.36&#39;&#125;# Enable or disable spider middlewares# See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;spider-middleware.html# SPIDER_MIDDLEWARES &#x3D; &#123;# &#39;wxapp.middlewares.WxappSpiderMiddleware&#39;: 543,# &#125;# Enable or disable downloader middlewares# See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;downloader-middleware.html# DOWNLOADER_MIDDLEWARES &#x3D; &#123;# &#39;wxapp.middlewares.WxappDownloaderMiddleware&#39;: 543,# &#125;# Enable or disable extensions# See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;extensions.html# EXTENSIONS &#x3D; &#123;# &#39;scrapy.extensions.telnet.TelnetConsole&#39;: None,# &#125;# Configure item pipelines# See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;item-pipeline.htmlITEM_PIPELINES &#x3D; &#123; &#39;wxapp.pipelines.WxappPipeline&#39;: 300,&#125;# Enable and configure the AutoThrottle extension (disabled by default)# See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;autothrottle.html# AUTOTHROTTLE_ENABLED &#x3D; True# The initial download delay# AUTOTHROTTLE_START_DELAY &#x3D; 5# The maximum download delay to be set in case of high latencies# AUTOTHROTTLE_MAX_DELAY &#x3D; 60# The average number of requests Scrapy should be sending in parallel to# each remote server# AUTOTHROTTLE_TARGET_CONCURRENCY &#x3D; 1.0# Enable showing throttling stats for every response received:# AUTOTHROTTLE_DEBUG &#x3D; False# Enable and configure HTTP caching (disabled by default)# See https:&#x2F;&#x2F;doc.scrapy.org&#x2F;en&#x2F;latest&#x2F;topics&#x2F;downloader-middleware.html#httpcache-middleware-settings# HTTPCACHE_ENABLED &#x3D; True# HTTPCACHE_EXPIRATION_SECS &#x3D; 0# HTTPCACHE_DIR &#x3D; &#39;httpcache&#39;# HTTPCACHE_IGNORE_HTTP_CODES &#x3D; []# HTTPCACHE_STORAGE &#x3D; &#39;scrapy.extensions.httpcache.FilesystemCacheStorage&#39; pipelines.py 12345678910111213from scrapy.exporters import JsonLinesItemExporterclass WxappPipeline(object): def __init__(self): self.fp &#x3D; open(&#39;wxjc.json&#39;,&#39;wb&#39;) self.exporter &#x3D; JsonLinesItemExporter(self.fp,ensure_ascii&#x3D;False,encoding&#x3D;&#39;utf-8&#39;) def process_item(self, item, spider): self.exporter.export_item(item) return item def close_spider(self,spider): self.fp.close() Start.py：启动项目 123from scrapy import cmdlinecmdline.execute(&quot;scrapy crawl wxapp_spider&quot;.split())","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"五、Scrapy框架(2)——快速入门","slug":"五、Scrapy框架-2-——快速入门","date":"2020-02-14T12:29:09.000Z","updated":"2020-02-14T12:36:15.506Z","comments":true,"path":"2020/02/14/五、Scrapy框架-2-——快速入门/","link":"","permalink":"http://yoursite.com/2020/02/14/%E4%BA%94%E3%80%81Scrapy%E6%A1%86%E6%9E%B6-2-%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"Scrapy快速入门","text":"Scrapy快速入门 安装和文档： 安装：通过pip install scrapy即可安装。 Scrapy官方文档：http://doc.scrapy.org/en/latest Scrapy中文文档：http://scrapy-chs.readthedocs.io/zh_CN/latest/index.html 注意： 在ubuntu上安装scrapy之前，需要先安装以下依赖：sudo apt-get install python3-dev build-essential python3-pip libxml2-dev libxslt1-dev zlib1g-dev libffi-dev libssl-dev，然后再通过pip install scrapy安装。 如果在windows系统下，提示这个错误ModuleNotFoundError: No module named &#39;win32api&#39;，那么使用以下命令可以解决：pip install pypiwin32。 快速入门：创建项目：要使用Scrapy框架创建项目，需要通过命令来创建。首先进入到你想把这个项目存放的目录。然后使用以下命令创建： 1scrapy startproject [项目名称] 目录结构介绍： 以下介绍下主要文件的作用： items.py：用来存放爬虫爬取下来数据的模型。 middlewares.py：用来存放各种中间件的文件。 pipelines.py：用来将items的模型存储到本地磁盘中。 settings.py：本爬虫的一些配置信息（比如请求头、多久发送一次请求、ip代理池等）。 scrapy.cfg：项目的配置文件。 spiders包：以后所有的爬虫，都是存放到这个里面。 使用Scrapy框架爬取糗事百科段子：使用命令创建一个爬虫：1scrapy gensipder qsbk &quot;qiushibaike.com&quot; 创建了一个名字叫做qsbk的爬虫，并且能爬取的网页只会限制在qiushibaike.com这个域名下。 爬虫代码解析：123456789import scrapyclass QsbkSpider(scrapy.Spider): name &#x3D; &#39;qsbk&#39; allowed_domains &#x3D; [&#39;qiushibaike.com&#39;] start_urls &#x3D; [&#39;http:&#x2F;&#x2F;www.qiushibaike.com&#x2F;&#39;] def parse(self, response): pass 其实这些代码我们完全可以自己手动去写，而不用命令。只不过是不用命令，自己写这些代码比较麻烦。要创建一个Spider，那么必须自定义一个类，继承自scrapy.Spider，然后在这个类中定义三个属性和一个方法。 name：这个爬虫的名字，名字必须是唯一的。 allow_domains：允许的域名。爬虫只会爬取这个域名下的网页，其他不是这个域名下的网页会被自动忽略。 start_urls：爬虫从这个变量中的url开始。 parse：引擎会把下载器下载回来的数据扔给爬虫解析，爬虫再把数据传给这个parse方法。这个是个固定的写法。这个方法的作用有两个，第一个是提取想要的数据。第二个是生成下一个请求的url。 修改settings.py代码：在做一个爬虫之前，一定要记得修改setttings.py中的设置。两个地方是强烈建议设置的。 ROBOTSTXT_OBEY设置为False。默认是True。即遵守机器协议，那么在爬虫的时候，scrapy首先去找robots.txt文件，如果没有找到。则直接停止爬取。 DEFAULT_REQUEST_HEADERS添加User-Agent。这个也是告诉服务器，我这个请求是一个正常的请求，不是一个爬虫。 完成的爬虫代码： 爬虫部分代码： 123456789101112131415161718192021# -*- coding: utf-8 -*-import scrapyfrom qsbk.qsbk.items import QsbkItemfrom scrapy.http.response.text import Responseclass QsbkSpiderSpider(scrapy.Spider): name &#x3D; &#39;qsbk_spider&#39; allowed_domains &#x3D; [&#39;qiushibaike.com&#39;] start_urls &#x3D; [&#39;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;text&#x2F;&#39;] def parse(self, response): # selectorList duanzidivs &#x3D; response.xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;content-left&#39;]&#x2F;div&quot;) for duanzidiv in duanzidivs: # selector author &#x3D; duanzidiv.xpath(&quot;.&#x2F;&#x2F;h2&#x2F;text()&quot;).get().strip() content &#x3D; duanzidiv.xpath(&quot;.&#x2F;&#x2F;div[@class&#x3D;&#39;content&#39;]&#x2F;&#x2F;text()&quot;).getall() content &#x3D; &quot;&quot;.join(content).strip() item &#x3D; QsbkItem(author&#x3D;author,content&#x3D;content) yield item items.py部分代码： 1234import scrapyclass QsbkItem(scrapy.Item): author &#x3D; scrapy.Field() content &#x3D; scrapy.Field() pipeline部分代码： 123456789101112131415161718import jsonclass QsbkPipeline(object): def __init__(self): self.fp &#x3D; open(&quot;duanzi.json&quot;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) def open_spider(self, spider): print(&#39;爬虫开始了...&#39;) def process_item(self, item, spider): item_json &#x3D; json.dumps(dict(item), ensure_ascii&#x3D;False) self.fp.write(item_json + &#39;\\n&#39;) return item def close_spider(self, spider): self.fp.close() print(&#39;爬虫结束了...&#39;) 运行scrapy项目：运行scrapy项目。需要在终端，进入项目所在的路径，然后scrapy crawl [爬虫名字]即可运行指定的爬虫。如果不想每次都在命令行中运行，那么可以把这个命令写在一个文件中。以后就在pycharm中执行运行这个文件就可以了。比如现在新创建一个文件叫做start.py，然后在这个文件中填入以下代码： 123from scrapy import cmdlinecmdline.execute(&quot;scrapy crawl qsbk&quot;.split()) 糗事百科Scrapy爬虫笔记： response是一个scrapy.http.response.html.HtmlResponse对象。可以执行xpath和css语法来提取数据。 提取出来的数据，是一个Selector或者是一个SelectorList对象。如果想要获取其中的字符串。那么应该执行getall或者get方法。 getall方法：获取Selector中的所有文本。返回的是一个列表 get方法：获取的是Selector中的第一个文本，返回的是一个str类型。 如果数据解析回来，要传给pipeline处理，那么可以使用 yield来返回。或者是收集所有的item。最后统一使用return返回。 item：建议在items.py中定义好模型，以后就不要使用字典。 pipeline：这个是专门用来保存数据的。其中有三个方法是会经常用的。 open_spider(self,spider)：当爬虫被打开的时候执行。 process_items(self,item,spider)：当爬虫有item传过来的时候会被调用。 close_spider(self,spider)：当爬虫关闭的时候会被调用 要激活pipeline，应该在settings.py中，设置ITEM_PIPELINES。示例如下： 123ITEM_PIPELINES &#x3D; &#123; &#39;qsbk.pipelines.QsbkPipeline&#39;: 300,&#125; JsonItemExporter 和 JsonLinesItemExporter保存 json 数据的时候，可以使用这两个类，让操作变得更简单。 JsonItemExporter：这个是每次把数据添加到内存中，最后统一写入到磁盘中。好处是：存储的数据是一个满足 json 规则的数据，坏处是如果数据量比较大，那么比较耗内存。示例代码如下： 1234567891011121314151617181920from scrapy.exporters import JsonItemExporterclass QsbkPipeline(object): def __init__(self): self.fp &#x3D; open(&quot;duanzi.json&quot;, &#39;wb&#39;) self.exporter &#x3D; JsonItemExporter(self.fp,ensure_ascii&#x3D;False,encoding&#x3D;&#39;utf-8&#39;) self.exporter.start_exporting() def open_spider(self, spider): print(&#39;爬虫开始了...&#39;) def process_item(self, item, spider): self.exporter.export_item(item) return item def close_spider(self, spider): self.exporter.finish_exporting() self.fp.close() print(&#39;爬虫结束了...&#39;) JsonLinesItemExporter：这个是每次调用export_item`的时候就把这个item存储到硬盘中。好处是每次处理数据的时候就直接存储到了硬盘中，这样不会耗内存，数据也比较安全。坏处是每一个字典是一行。整个文件不是一个满足json格式的文件。示例代码如下： 1234567891011121314151617from scrapy.exporters import JsonLinesItemExporterclass QsbkPipeline(object): def __init__(self): self.fp &#x3D; open(&quot;duanzi3.json&quot;, &#39;wb&#39;) self.exporter &#x3D; JsonLinesItemExporter(self.fp,ensure_ascii&#x3D;False,encoding&#x3D;&#39;utf-8&#39;) def open_spider(self, spider): print(&#39;爬虫开始了...&#39;) def process_item(self, item, spider): self.exporter.export_item(item) return item def close_spider(self, spider): self.fp.close() print(&#39;爬虫结束了...&#39;)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"五、Scrapy框架(1)——框架架构","slug":"五、Scrapy框架-1-——框架架构","date":"2020-02-14T12:25:05.000Z","updated":"2020-02-14T12:36:22.446Z","comments":true,"path":"2020/02/14/五、Scrapy框架-1-——框架架构/","link":"","permalink":"http://yoursite.com/2020/02/14/%E4%BA%94%E3%80%81Scrapy%E6%A1%86%E6%9E%B6-1-%E2%80%94%E2%80%94%E6%A1%86%E6%9E%B6%E6%9E%B6%E6%9E%84/","excerpt":"Scrapy框架架构","text":"Scrapy框架架构 Scrapy框架介绍：写一个爬虫，需要做很多的事情。比如：发送网络请求、数据解析、数据存储、反反爬虫机制（更换ip代理、设置请求头等）、异步请求等。这些工作如果每次都要自己从零开始写的话，比较浪费时间。因此Scrapy把一些基础的东西封装好了，在他上面写爬虫可以变的更加的高效（爬取效率和开发效率）。因此真正在公司里，一些上了量的爬虫，都是使用Scrapy框架来解决。 Scrapy架构图：流程图（1）： 流程图（2）： Scrapy框架模块功能： Scrapy Engine（引擎）：Scrapy框架的核心部分。负责在Spider和ItemPipeline、Downloader、Scheduler中间通信、传递数据等。 Spider（爬虫）：发送需要爬取的链接给引擎，最后引擎把其他模块请求回来的数据再发送给爬虫，爬虫就去解析想要的数据。这个部分是我们开发者自己写的，因为要爬取哪些链接，页面中的哪些数据是我们需要的，都是由程序员自己决定。 Scheduler（调度器）：负责接收引擎发送过来的请求，并按照一定的方式进行排列和整理，负责调度请求的顺序等。 Downloader（下载器）：负责接收引擎传过来的下载请求，然后去网络上下载对应的数据再交还给引擎。 Item Pipeline（管道）：负责将Spider（爬虫）传递过来的数据进行保存。具体保存在哪里，应该看开发者自己的需求。 Downloader Middlewares（下载中间件）：可以扩展下载器和引擎之间通信功能的中间件。 Spider Middlewares（Spider中间件）：可以扩展引擎和爬虫之间通信功能的中间件。","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"四、爬虫进阶(3）——图形验证码识别","slug":"四、爬虫进阶-3——图形验证码识别","date":"2020-02-14T12:22:56.000Z","updated":"2020-02-14T12:25:48.420Z","comments":true,"path":"2020/02/14/四、爬虫进阶-3——图形验证码识别/","link":"","permalink":"http://yoursite.com/2020/02/14/%E5%9B%9B%E3%80%81%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6-3%E2%80%94%E2%80%94%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/","excerpt":"图形验证码识别技术：","text":"图形验证码识别技术： 阻碍我们爬虫的。有时候正是在登录或者请求一些数据时候的图形验证码。因此这里我们讲解一种能将图片翻译成文字的技术。将图片翻译成文字一般被成为光学文字识别（Optical Character Recognition），简写为OCR。实现OCR的库不是很多，特别是开源的。因为这块存在一定的技术壁垒（需要大量的数据、算法、机器学习、深度学习知识等），并且如果做好了具有很高的商业价值。因此开源的比较少。这里介绍一个比较优秀的图像识别开源库：Tesseract。 Tesseract：Tesseract是一个OCR库，目前由谷歌赞助。Tesseract是目前公认最优秀、最准确的开源OCR库。Tesseract具有很高的识别度，也具有很高的灵活性，他可以通过训练识别任何字体。 安装：Windows系统：在以下链接下载可执行文件，然后一顿点击下一步安装即可（放在不需要权限的纯英文路径下）：https://github.com/tesseract-ocr/ Linux系统：可以在以下链接下载源码自行编译。https://github.com/tesseract-ocr/tesseract/wiki/Compiling或者在ubuntu下通过以下命令进行安装： 1sudo apt install tesseract-ocr Mac系统：用Homebrew即可方便安装： 1brew install tesseract 设置环境变量：安装完成后，如果想要在命令行中使用Tesseract，那么应该设置环境变量。Mac和Linux在安装的时候就默认已经设置好了。在Windows下把tesseract.exe所在的路径添加到PATH环境变量中。 还有一个环境变量需要设置的是，要把训练的数据文件路径也放到环境变量中。在环境变量中，添加一个TESSDATA_PREFIX=C:\\path_to_tesseractdata\\teseractdata。 在命令行中使用tesseract识别图像：如果想要在cmd下能够使用tesseract命令，那么需要把tesseract.exe所在的目录放到PATH环境变量中。然后使用命令：tesseract 图片路径 文件路径。示例： 1tesseract a.png a 那么就会识别出a.png中的图片，并且把文字写入到a.txt中。如果不想写入文件直接想显示在终端，那么不要加文件名就可以了。 在代码中使用tesseract识别图像：在Python代码中操作tesseract。需要安装一个库，叫做pytesseract。通过pip的方式即可安装： 1pip install pytesseract 并且，需要读取图片，需要借助一个第三方库叫做PIL。通过pip list看下是否安装。如果没有安装，通过pip的方式安装： 1pip install PIL 使用pytesseract将图片上的文字转换为文本文字的示例代码如下： 12345678910111213# 导入pytesseract库import pytesseract# 导入Image库from PIL import Image# 指定tesseract.exe所在的路径pytesseract.pytesseract.tesseract_cmd &#x3D; r&#39;D:\\ProgramApp\\TesseractOCR\\tesseract.exe&#39;# 打开图片image &#x3D; Image.open(&quot;a.png&quot;)# 调用image_to_string将图片转换为文字text &#x3D; pytesseract.image_to_string(image)print(text) 用pytesseract处理拉勾网图形验证码：12345678910111213141516import pytesseractfrom urllib import requestfrom PIL import Imageimport timepytesseract.pytesseract.tesseract_cmd &#x3D; r&quot;D:\\ProgramApp\\TesseractOCR\\tesseract.exe&quot;while True: captchaUrl &#x3D; &quot;https:&#x2F;&#x2F;passport.lagou.com&#x2F;vcode&#x2F;create?from&#x3D;register&amp;refresh&#x3D;1513081451891&quot; request.urlretrieve(captchaUrl,&#39;captcha.png&#39;) image &#x3D; Image.open(&#39;captcha.png&#39;) text &#x3D; pytesseract.image_to_string(image,lang&#x3D;&#39;eng&#39;) print(text) time.sleep(2)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"四、爬虫进阶(2）——ajax数据爬取","slug":"四、爬虫进阶-2——ajax数据爬取","date":"2020-02-14T12:21:17.000Z","updated":"2020-02-14T12:23:30.070Z","comments":true,"path":"2020/02/14/四、爬虫进阶-2——ajax数据爬取/","link":"","permalink":"http://yoursite.com/2020/02/14/%E5%9B%9B%E3%80%81%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6-2%E2%80%94%E2%80%94ajax%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/","excerpt":"动态网页数据抓取","text":"动态网页数据抓取 什么是AJAX：AJAX（Asynchronouse JavaScript And XML）异步JavaScript和XML。过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用Ajax）如果需要更新内容，必须重载整个网页页面。因为传统的在传输数据格式方面，使用的是XML语法。因此叫做AJAX，其实现在数据交互基本上都是使用JSON。使用AJAX加载的数据，即使使用了JS，将数据渲染到了浏览器中，在右键-&gt;查看网页源代码还是不能看到通过ajax加载的数据，只能看到使用这个url加载的html代码。 获取ajax数据的方式： 直接分析ajax调用的接口。然后通过代码请求这个接口。 使用Selenium+chromedriver模拟浏览器行为获取数据。 方式 优点 缺点 分析接口 直接可以请求到数据。不需要做一些解析工作。代码量少，性能高。 分析接口比较复杂，特别是一些通过js混淆的接口，要有一定的js功底。容易被发现是爬虫。 selenium 直接模拟浏览器的行为。浏览器能请求到的，使用selenium也能请求到。爬虫更稳定。 代码量多。性能低。 Selenium+chromedriver获取动态数据Selenium相当于是一个机器人。可以模拟人类在浏览器上的一些行为，自动处理浏览器上的一些行为，比如点击，填充数据，删除cookie等。chromedriver是一个驱动Chrome浏览器的驱动程序，使用他才可以驱动浏览器。当然针对不同的浏览器有不同的driver。以下列出了不同浏览器及其对应的driver： Chrome：https://sites.google.com/a/chromium.org/chromedriver/downloads Firefox：https://github.com/mozilla/geckodriver/releases Edge：https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/ Safari：https://webkit.org/blog/6900/webdriver-support-in-safari-10/ 安装Selenium和chromedriver： 安装 Selenium：Selenium有很多语言的版本，有java、ruby、python等。我们下载python版本的就可以了。 1pip install selenium 安装chromedriver：下载完成后，放到不需要权限的纯英文目录下就可以了。 快速入门：现在以一个简单的获取百度首页的例子来讲下Selenium和chromedriver如何快速入门： 1234567891011from selenium import webdriver# chromedriver的绝对路径driver_path &#x3D; r&#39;D:\\ProgramApp\\chromedriver\\chromedriver.exe&#39;# 初始化一个driver，并且指定chromedriver的路径driver &#x3D; webdriver.Chrome(executable_path&#x3D;driver_path)# 请求网页driver.get(&quot;https:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;)# 通过page_source获取网页源代码print(driver.page_source) selenium常用操作：更多教程请参考：http://selenium-python.readthedocs.io/installation.html#introduction 关闭页面： driver.close()：关闭当前页面。 driver.quit()：退出整个浏览器。 定位元素： find_element_by_id：根据id来查找某个元素。等价于： 12submitTag &#x3D; driver.find_element_by_id(&#39;su&#39;)submitTag1 &#x3D; driver.find_element(By.ID,&#39;su&#39;) find_element_by_class_name：根据类名查找元素。 等价于： 12submitTag &#x3D; driver.find_element_by_class_name(&#39;su&#39;)submitTag1 &#x3D; driver.find_element(By.CLASS_NAME,&#39;su&#39;) find_element_by_name：根据name属性的值来查找元素。等价于： 12submitTag &#x3D; driver.find_element_by_name(&#39;email&#39;)submitTag1 &#x3D; driver.find_element(By.NAME,&#39;email&#39;) find_element_by_tag_name：根据标签名来查找元素。等价于： 12submitTag &#x3D; driver.find_element_by_tag_name(&#39;div&#39;)submitTag1 &#x3D; driver.find_element(By.TAG_NAME,&#39;div&#39;) find_element_by_xpath：根据xpath语法来获取元素。等价于： 12submitTag &#x3D; driver.find_element_by_xpath(&#39;&#x2F;&#x2F;div&#39;)submitTag1 &#x3D; driver.find_element(By.XPATH,&#39;&#x2F;&#x2F;div&#39;) find_element_by_css_selector：根据css选择器选择元素。等价于： 12submitTag &#x3D; driver.find_element_by_css_selector(&#39;&#x2F;&#x2F;div&#39;)submitTag1 &#x3D; driver.find_element(By.CSS_SELECTOR,&#39;&#x2F;&#x2F;div&#39;) 要注意，find_element是获取第一个满足条件的元素。find_elements是获取所有满足条件的元素。 操作表单元素： 操作输入框：分为两步。第一步：找到这个元素。第二步：使用send_keys(value)，将数据填充进去。示例代码如下： 12inputTag &#x3D; driver.find_element_by_id(&#39;kw&#39;)inputTag.send_keys(&#39;python&#39;) 使用clear方法可以清除输入框中的内容。示例代码如下： 1inputTag.clear() 操作checkbox：因为要选中checkbox标签，在网页中是通过鼠标点击的。因此想要选中checkbox标签，那么先选中这个标签，然后执行click事件。示例代码如下： 12rememberTag &#x3D; driver.find_element_by_name(&quot;rememberMe&quot;)rememberTag.click() 选择select：select元素不能直接点击。因为点击后还需要选中元素。这时候selenium就专门为select标签提供了一个类selenium.webdriver.support.ui.Select。将获取到的元素当成参数传到这个类中，创建这个对象。以后就可以使用这个对象进行选择了。示例代码如下： 1234567891011from selenium.webdriver.support.ui import Select# 选中这个标签，然后使用Select创建对象selectTag &#x3D; Select(driver.find_element_by_name(&quot;jumpMenu&quot;))# 根据索引选择selectTag.select_by_index(1)# 根据值选择selectTag.select_by_value(&quot;http:&#x2F;&#x2F;www.95yueba.com&quot;)# 根据可视的文本选择selectTag.select_by_visible_text(&quot;95秀客户端&quot;)# 取消选中所有选项selectTag.deselect_all() 操作按钮：操作按钮有很多种方式。比如单击、右击、双击等。这里讲一个最常用的。就是点击。直接调用click函数就可以了。示例代码如下： 12inputTag &#x3D; driver.find_element_by_id(&#39;su&#39;)inputTag.click() 行为链：有时候在页面中的操作可能要有很多步，那么这时候可以使用鼠标行为链类ActionChains来完成。比如现在要将鼠标移动到某个元素上并执行点击事件。那么示例代码如下： 123456789inputTag &#x3D; driver.find_element_by_id(&#39;kw&#39;)submitTag &#x3D; driver.find_element_by_id(&#39;su&#39;)actions &#x3D; ActionChains(driver)actions.move_to_element(inputTag)actions.send_keys_to_element(inputTag,&#39;python&#39;)actions.move_to_element(submitTag)actions.click(submitTag)actions.perform() 还有更多的鼠标相关的操作。 click_and_hold(element)：点击但不松开鼠标。 context_click(element)：右键点击。 double_click(element)：双击。 更多方法请参考：http://selenium-python.readthedocs.io/api.html Cookie操作： 获取所有的 cookie： 12for cookie in driver.get_cookies(): print(cookie) 根据cookie的key获取value： 1value &#x3D; driver.get_cookie(key) 删除所有的cookie： 1driver.delete_all_cookies() 删除某个 cookie： 1driver.delete_cookie(key) 页面等待：现在的网页越来越多采用了 Ajax 技术，这样程序便不能确定何时某个元素完全加载出来了。如果实际页面等待时间过长导致某个dom元素还没出来，但是你的代码直接使用了这个WebElement，那么就会抛出NullPointer的异常。为了解决这个问题。所以 Selenium 提供了两种等待方式：一种是隐式等待、一种是显式等待。 隐式等待：调用driver.implicitly_wait。那么在获取不可用的元素之前，会先等待10秒中的时间。示例代码如下： 1234driver &#x3D; webdriver.Chrome(executable_path&#x3D;driver_path)driver.implicitly_wait(10)# 请求网页driver.get(&quot;https:&#x2F;&#x2F;www.douban.com&#x2F;&quot;) 显示等待：显示等待是表明某个条件成立后才执行获取元素的操作。也可以在等待的时候指定一个最大的时间，如果超过这个时间那么就抛出一个异常。显示等待应该使用selenium.webdriver.support.excepted_conditions期望的条件和selenium.webdriver.support.ui.WebDriverWait来配合完成。示例代码如下： 12345678910111213from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support import expected_conditions as EC driver &#x3D; webdriver.Firefox()driver.get(&quot;http:&#x2F;&#x2F;somedomain&#x2F;url_that_delays_loading&quot;)try: element &#x3D; WebDriverWait(driver, 10).until( EC.presence_of_element_located((By.ID, &quot;myDynamicElement&quot;)) )finally: driver.quit() 一些其他的等待条件： presence_of_element_located：某个元素已经加载完毕了。 presence_of_all_emement_located：网页中所有满足条件的元素都加载完毕了。 element_to_be_cliable：某个元素是可以点击了。 更多条件请参考：http://selenium-python.readthedocs.io/waits.html 切换页面：有时候窗口中有很多子tab页面。这时候肯定是需要进行切换的。selenium提供了一个叫做switch_to_window来进行切换，具体切换到哪个页面，可以从driver.window_handles中找到。示例代码如下： 1234# 打开一个新的页面self.driver.execute_script(&quot;window.open(&#39;&quot;+url+&quot;&#39;)&quot;)# 切换到这个新的页面中self.driver.switch_to_window(self.driver.window_handles[1]) 设置代理ip：有时候频繁爬取一些网页。服务器发现你是爬虫后会封掉你的ip地址。这时候我们可以更改代理ip。更改代理ip，不同的浏览器有不同的实现方式。这里以Chrome浏览器为例来讲解： 12345678from selenium import webdriveroptions &#x3D; webdriver.ChromeOptions()options.add_argument(&quot;--proxy-server&#x3D;http:&#x2F;&#x2F;110.73.2.248:8123&quot;)driver_path &#x3D; r&quot;D:\\ProgramApp\\chromedriver\\chromedriver.exe&quot;driver &#x3D; webdriver.Chrome(executable_path&#x3D;driver_path,chrome_options&#x3D;options)driver.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;ip&#39;) WebElement 元素：from selenium.webdriver.remote.webelement import WebElement类是每个获取出来的元素的所属类。有一些常用的属性： get_attribute：这个标签的某个属性的值。 screentshot：获取当前页面的截图。这个方法只能在driver上使用。driver的对象类，也是继承自 WebElement。更多请阅读相关源代码。","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"四、爬虫进阶(1）——多线程爬虫","slug":"四、爬虫进阶-1——多线程爬虫","date":"2020-02-14T12:18:31.000Z","updated":"2020-02-14T12:20:33.400Z","comments":true,"path":"2020/02/14/四、爬虫进阶-1——多线程爬虫/","link":"","permalink":"http://yoursite.com/2020/02/14/%E5%9B%9B%E3%80%81%E7%88%AC%E8%99%AB%E8%BF%9B%E9%98%B6-1%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E8%99%AB/","excerpt":"多线程爬虫","text":"多线程爬虫 有些时候，比如下载图片，因为下载图片是一个耗时的操作。如果采用之前那种同步的方式下载。那效率肯会特别慢。这时候我们就可以考虑使用多线程的方式来下载图片。 多线程介绍：多线程是为了同步完成多项任务，通过提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。最简单的比喻多线程就像火车的每一节车厢，而进程则是火车。车厢离开火车是无法跑动的，同理火车也可以有多节车厢。多线程的出现就是为了提高效率。同时它的出现也带来了一些问题。更多介绍请参考：https://baike.baidu.com/item/多线程/1190404?fr=aladdin threading模块介绍：threading模块是python中专门提供用来做多线程编程的模块。threading模块中最常用的类是Thread。以下看一个简单的多线程程序： 123456789101112131415161718192021222324252627import threadingimport timedef coding(): for x in range(3): print(&#39;%s正在写代码&#39; % x) time.sleep(1)def drawing(): for x in range(3): print(&#39;%s正在画图&#39; % x) time.sleep(1)def single_thread(): coding() drawing()def multi_thread(): t1 &#x3D; threading.Thread(target&#x3D;coding) t2 &#x3D; threading.Thread(target&#x3D;drawing) t1.start() t2.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: multi_thread() 查看线程数：使用threading.enumerate()函数便可以看到当前线程的数量。 查看当前线程的名字：使用threading.current_thread()可以看到当前线程的信息。 继承自threading.Thread类：为了让线程代码更好的封装。可以使用threading模块下的Thread类，继承自这个类，然后实现run方法，线程就会自动运行run方法中的代码。示例代码如下： 123456789101112131415161718192021222324import threadingimport timeclass CodingThread(threading.Thread): def run(self): for x in range(3): print(&#39;%s正在写代码&#39; % threading.current_thread()) time.sleep(1)class DrawingThread(threading.Thread): def run(self): for x in range(3): print(&#39;%s正在画图&#39; % threading.current_thread()) time.sleep(1)def multi_thread(): t1 &#x3D; CodingThread() t2 &#x3D; DrawingThread() t1.start() t2.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: multi_thread() 多线程共享全局变量的问题：多线程都是在同一个进程中运行的。因此在进程中的全局变量所有线程都是可共享的。这就造成了一个问题，因为线程执行的顺序是无序的。有可能会造成数据错误。比如以下代码： 1234567891011121314151617import threadingtickets &#x3D; 0def get_ticket(): global tickets for x in range(1000000): tickets +&#x3D; 1 print(&#39;tickets:%d&#39;%tickets)def main(): for x in range(2): t &#x3D; threading.Thread(target&#x3D;get_ticket) t.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 以上结果正常来讲应该是6，但是因为多线程运行的不确定性。因此最后的结果可能是随机的。 锁机制：为了解决以上使用共享全局变量的问题。threading提供了一个Lock类，这个类可以在某个线程访问某个变量的时候加锁，其他线程此时就不能进来，直到当前线程处理完后，把锁释放了，其他线程才能进来处理。示例代码如下： 123456789101112131415161718192021import threadingVALUE &#x3D; 0gLock &#x3D; threading.Lock()def add_value(): global VALUE gLock.acquire() for x in range(1000000): VALUE +&#x3D; 1 gLock.release() print(&#39;value：%d&#39;%VALUE)def main(): for x in range(2): t &#x3D; threading.Thread(target&#x3D;add_value) t.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() Lock版本生产者和消费者模式：生产者和消费者模式是多线程开发中经常见到的一种模式。生产者的线程专门用来生产一些数据，然后存放到一个中间的变量中。消费者再从这个中间的变量中取出数据进行消费。但是因为要使用中间变量，中间变量经常是一些全局变量，因此需要使用锁来保证数据完整性。以下是使用threading.Lock锁实现的“生产者与消费者模式”的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import threadingimport randomimport timegMoney &#x3D; 1000gLock &#x3D; threading.Lock()# 记录生产者生产的次数，达到10次就不再生产gTimes &#x3D; 0class Producer(threading.Thread): def run(self): global gMoney global gLock global gTimes while True: money &#x3D; random.randint(100, 1000) gLock.acquire() # 如果已经达到10次了，就不再生产了 if gTimes &gt;&#x3D; 10: gLock.release() break gMoney +&#x3D; money print(&#39;%s当前存入%s元钱，剩余%s元钱&#39; % (threading.current_thread(), money, gMoney)) gTimes +&#x3D; 1 time.sleep(0.5) gLock.release()class Consumer(threading.Thread): def run(self): global gMoney global gLock global gTimes while True: money &#x3D; random.randint(100, 500) gLock.acquire() if gMoney &gt; money: gMoney -&#x3D; money print(&#39;%s当前取出%s元钱，剩余%s元钱&#39; % (threading.current_thread(), money, gMoney)) time.sleep(0.5) else: # 如果钱不够了，有可能是已经超过了次数，这时候就判断一下 if gTimes &gt;&#x3D; 10: gLock.release() break print(&quot;%s当前想取%s元钱，剩余%s元钱，不足！&quot; % (threading.current_thread(),money,gMoney)) gLock.release()def main(): for x in range(5): Consumer(name&#x3D;&#39;消费者线程%d&#39;%x).start() for x in range(5): Producer(name&#x3D;&#39;生产者线程%d&#39;%x).start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() Condition版的生产者与消费者模式：Lock版本的生产者与消费者模式可以正常的运行。但是存在一个不足，在消费者中，总是通过while True死循环并且上锁的方式去判断钱够不够。上锁是一个很耗费CPU资源的行为。因此这种方式不是最好的。还有一种更好的方式便是使用threading.Condition来实现。threading.Condition可以在没有数据的时候处于阻塞等待状态。一旦有合适的数据了，还可以使用notify相关的函数来通知其他处于等待状态的线程。这样就可以不用做一些无用的上锁和解锁的操作。可以提高程序的性能。首先对threading.Condition相关的函数做个介绍，threading.Condition类似threading.Lock，可以在修改全局数据的时候进行上锁，也可以在修改完毕后进行解锁。以下将一些常用的函数做个简单的介绍： acquire：上锁。 release：解锁。 wait：将当前线程处于等待状态，并且会释放锁。可以被其他线程使用notify和notify_all函数唤醒。被唤醒后会继续等待上锁，上锁后继续执行下面的代码。 notify：通知某个正在等待的线程，默认是第1个等待的线程。 notify_all：通知所有正在等待的线程。notify和notify_all不会释放锁。并且需要在release之前调用。 Condition版的生产者与消费者模式代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import threadingimport randomimport timegMoney &#x3D; 1000gCondition &#x3D; threading.Condition()gTimes &#x3D; 0gTotalTimes &#x3D; 5class Producer(threading.Thread): def run(self): global gMoney global gCondition global gTimes while True: money &#x3D; random.randint(100, 1000) gCondition.acquire() if gTimes &gt;&#x3D; gTotalTimes: gCondition.release() print(&#39;当前生产者总共生产了%s次&#39;%gTimes) break gMoney +&#x3D; money print(&#39;%s当前存入%s元钱，剩余%s元钱&#39; % (threading.current_thread(), money, gMoney)) gTimes +&#x3D; 1 time.sleep(0.5) gCondition.notify_all() gCondition.release()class Consumer(threading.Thread): def run(self): global gMoney global gCondition while True: money &#x3D; random.randint(100, 500) gCondition.acquire() # 这里要给个while循环判断，因为等轮到这个线程的时候 # 条件有可能又不满足了 while gMoney &lt; money: if gTimes &gt;&#x3D; gTotalTimes: gCondition.release() return print(&#39;%s准备取%s元钱，剩余%s元钱，不足！&#39;%(threading.current_thread(),money,gMoney)) gCondition.wait() gMoney -&#x3D; money print(&#39;%s当前取出%s元钱，剩余%s元钱&#39; % (threading.current_thread(), money, gMoney)) time.sleep(0.5) gCondition.release()def main(): for x in range(5): Consumer(name&#x3D;&#39;消费者线程%d&#39;%x).start() for x in range(2): Producer(name&#x3D;&#39;生产者线程%d&#39;%x).start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() Queue线程安全队列：在线程中，访问一些全局变量，加锁是一个经常的过程。如果你是想把一些数据存储到某个队列中，那么Python内置了一个线程安全的模块叫做queue模块。Python中的queue模块中提供了同步的、线程安全的队列类，包括FIFO（先进先出）队列Queue，LIFO（后入先出）队列LifoQueue。这些队列都实现了锁原语（可以理解为原子操作，即要么不做，要么都做完），能够在多线程中直接使用。可以使用队列来实现线程间的同步。相关的函数如下： 初始化Queue(maxsize)：创建一个先进先出的队列。 qsize()：返回队列的大小。 empty()：判断队列是否为空。 full()：判断队列是否满了。 get()：从队列中取最后一个数据。 put()：将一个数据放到队列中。 使用生产者与消费者模式多线程下载表情包：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import threadingimport requestsfrom lxml import etreefrom urllib import requestimport osimport refrom queue import Queueclass Producer(threading.Thread): headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;62.0.3202.94 Safari&#x2F;537.36&#39; &#125; def __init__(self,page_queue,img_queue,*args,**kwargs): super(Producer, self).__init__(*args,**kwargs) self.page_queue &#x3D; page_queue self.img_queue &#x3D; img_queue def run(self): while True: if self.page_queue.empty(): break url &#x3D; self.page_queue.get() self.parse_page(url) def parse_page(self,url): response &#x3D; requests.get(url,headers&#x3D;self.headers) text &#x3D; response.text html &#x3D; etree.HTML(text) imgs &#x3D; html.xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;page-content text-center&#39;]&#x2F;&#x2F;a&#x2F;&#x2F;img&quot;) for img in imgs: if img.get(&#39;class&#39;) &#x3D;&#x3D; &#39;gif&#39;: continue img_url &#x3D; img.xpath(&quot;.&#x2F;&#x2F;@data-original&quot;)[0] suffix &#x3D; os.path.splitext(img_url)[1] alt &#x3D; img.xpath(&quot;.&#x2F;&#x2F;@alt&quot;)[0] alt &#x3D; re.sub(r&#39;[，。？?,&#x2F;\\\\·]&#39;,&#39;&#39;,alt) img_name &#x3D; alt + suffix self.img_queue.put((img_url,img_name))class Consumer(threading.Thread): def __init__(self,page_queue,img_queue,*args,**kwargs): super(Consumer, self).__init__(*args,**kwargs) self.page_queue &#x3D; page_queue self.img_queue &#x3D; img_queue def run(self): while True: if self.img_queue.empty(): if self.page_queue.empty(): return img &#x3D; self.img_queue.get(block&#x3D;True) url,filename &#x3D; img request.urlretrieve(url,&#39;images&#x2F;&#39;+filename) print(filename+&#39; 下载完成！&#39;)def main(): page_queue &#x3D; Queue(100) img_queue &#x3D; Queue(500) for x in range(1,101): url &#x3D; &quot;http:&#x2F;&#x2F;www.doutula.com&#x2F;photo&#x2F;list&#x2F;?page&#x3D;%d&quot; % x page_queue.put(url) for x in range(5): t &#x3D; Producer(page_queue,img_queue) t.start() for x in range(5): t &#x3D; Consumer(page_queue,img_queue) t.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() GIL全局解释器锁：Python自带的解释器是CPython。CPython解释器的多线程实际上是一个假的多线程（在多核CPU中，只能利用一核，不能利用多核）。同一时刻只有一个线程在执行，为了保证同一时刻只有一个线程在执行，在CPython解释器中有一个东西叫做GIL（Global Intepreter Lock），叫做全局解释器锁。这个解释器锁是有必要的。因为CPython解释器的内存管理不是线程安全的。当然除了CPython解释器，还有其他的解释器，有些解释器是没有GIL锁的，见下面： Jython：用Java实现的Python解释器。不存在GIL锁。更多详情请见：https://zh.wikipedia.org/wiki/Jython IronPython：用.net实现的Python解释器。不存在GIL锁。更多详情请见：https://zh.wikipedia.org/wiki/IronPython PyPy：用Python实现的Python解释器。存在GIL锁。更多详情请见：https://zh.wikipedia.org/wiki/PyPyGIL虽然是一个假的多线程。但是在处理一些IO操作（比如文件读写和网络请求）还是可以在很大程度上提高效率的。在IO操作上建议使用多线程提高效率。在一些CPU计算操作上不建议使用多线程，而建议使用多进程。 多线程下载百思不得姐段子作业：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import requestsfrom lxml import etreeimport threadingfrom queue import Queueimport csvclass BSSpider(threading.Thread): headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;62.0.3202.94 Safari&#x2F;537.36&#39; &#125; def __init__(self,page_queue,joke_queue,*args,**kwargs): super(BSSpider, self).__init__(*args,**kwargs) self.base_domain &#x3D; &#39;http:&#x2F;&#x2F;www.budejie.com&#39; self.page_queue &#x3D; page_queue self.joke_queue &#x3D; joke_queue def run(self): while True: if self.page_queue.empty(): break url &#x3D; self.page_queue.get() response &#x3D; requests.get(url, headers&#x3D;self.headers) text &#x3D; response.text html &#x3D; etree.HTML(text) descs &#x3D; html.xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;j-r-list-c-desc&#39;]&quot;) for desc in descs: jokes &#x3D; desc.xpath(&quot;.&#x2F;&#x2F;text()&quot;) joke &#x3D; &quot;\\n&quot;.join(jokes).strip() link &#x3D; self.base_domain+desc.xpath(&quot;.&#x2F;&#x2F;a&#x2F;@href&quot;)[0] self.joke_queue.put((joke,link)) print(&#39;&#x3D;&#39;*30+&quot;第%s页下载完成！&quot;%url.split(&#39;&#x2F;&#39;)[-1]+&quot;&#x3D;&quot;*30)class BSWriter(threading.Thread): headers &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;62.0.3202.94 Safari&#x2F;537.36&#39; &#125; def __init__(self, joke_queue, writer,gLock, *args, **kwargs): super(BSWriter, self).__init__(*args, **kwargs) self.joke_queue &#x3D; joke_queue self.writer &#x3D; writer self.lock &#x3D; gLock def run(self): while True: try: joke_info &#x3D; self.joke_queue.get(timeout&#x3D;40) joke,link &#x3D; joke_info self.lock.acquire() self.writer.writerow((joke,link)) self.lock.release() print(&#39;保存一条&#39;) except: breakdef main(): page_queue &#x3D; Queue(10) joke_queue &#x3D; Queue(500) gLock &#x3D; threading.Lock() fp &#x3D; open(&#39;bsbdj.csv&#39;, &#39;a&#39;,newline&#x3D;&#39;&#39;, encoding&#x3D;&#39;utf-8&#39;) writer &#x3D; csv.writer(fp) writer.writerow((&#39;content&#39;, &#39;link&#39;)) for x in range(1,11): url &#x3D; &#39;http:&#x2F;&#x2F;www.budejie.com&#x2F;text&#x2F;%d&#39; % x page_queue.put(url) for x in range(5): t &#x3D; BSSpider(page_queue,joke_queue) t.start() for x in range(5): t &#x3D; BSWriter(joke_queue,writer,gLock) t.start()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main()","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"三、数据存取(4)——MongoDB数据库操作","slug":"三、数据存取-4-——MongoDB数据库操作","date":"2020-02-13T14:10:01.000Z","updated":"2020-02-13T16:09:46.272Z","comments":true,"path":"2020/02/13/三、数据存取-4-——MongoDB数据库操作/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96-4-%E2%80%94%E2%80%94MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","excerpt":"MongoDB数据库操作","text":"MongoDB数据库操作 MongoDB是一个基于分布式文件存储的NoSQL 数据库。在处理海理数据的时候会比 MySQL 更有优势。爬虫如果上了一个量级，可能就会比较推荐使用 MongoDB，当然没有上量的数据也完全可以使用 MongoDB 来存储数据。因此学会使用 MongoDB 也是爬虫开发工程师必须掌握的一个技能。 Windows下安装MongoDB数据库在官网下载 MongoDB数据库，是一个msi文件。官网地址：https://www.mongodb.com/download-center/community 然后双击进行安装。 运行 MongoDB 创建数据目录： 启动 MongoDB 之前，首先要给他指定一个数据存储的路径。比如在 MongoDB 的安装路径下创建一个 data 文件夹角，专门用来存储数据的 D:\\ProgramApp\\mongodb\\data 把 mongodb 的bin 目录加入到环境变量中，方便后期调用 执行命令 mongod —dbpath D:\\ProgramApp\\mongodb\\data 启动 连接 MongoDB在环境变量设置好的前提下，使用以下命令 mongo 就可以进入到 mongo的操作终端了。 使用 Compass软件连接 MongoDBCompass 是一个图形化的操作 MongoDB 的客户端，使用他来操作更加方便。 将 MongoDB 制作成 windows 服务：启动 mongodb后，如果想让 mongodb一直运行，那么这个终端便不能关闭，而且每次运行的时候还需要指定 data的路径。因此我们可以将 mongodb 制作成一个服务，以后就通过一行命令就可以运行了。 创建配置文件：在 mongodb 安装的路径下创建配置文件 mongod.cfg(路径和名字任意)，然后在配置文件中添加以下代码： 12logpath&#x3D;D:\\ProgramApp\\mongodb\\data\\log\\mongod.logdbpath&#x3D;D:\\ProgramApp\\mongod\\data\\db 安装 mongdb服务： 123mongod --config &quot;cfg配置文件所有路径&quot; ——-install比如：mongod --config “D:\\ProgramApp\\mongodb\\mongod.cfg” --install 启动 Mongodb：net stat mongodb 关闭MongoDB：net stat mongodb 移除 MongoDB：&quot;D:\\ProgramApp\\mongodb\\bin\\mongod.exe&quot; --remove MongoDB概念介绍 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row Document 数据记录行/文档 column Field 数据字段/域 index Index 索引 table joins 表连接，MongoDB不支持 Primary key primary key 主键，MongoDB自动将_id字段设置为主键 MongoDB三元素三元素：数据库、集合、文档 文档(document)：就是关系型数据库中的一行。文档是一个对象，由键值对构成，是 json 的扩展形式。 1&#123;&#39;name&#39;:&#39;abc&#39;,&#39;gender&#39;:&#39;1&#39;&#125; 集合(collection)：就是关系型数据库中的表。可以存储多个文档，结构可以不固定。如可以存储如下文档在一个集合中： 123&#123;&quot;name&quot;:&quot;abc&quot;,&quot;gender&quot;:&quot;1&quot;&#125;&#123;&quot;name&quot;:&quot;xxx&quot;,&quot;gender&quot;:18&#125;&#123;&quot;title&quot;:&quot;yyy&quot;,&quot;price&quot;:20.9&#125; ### MongoDB基本操作命令 db：查看当前的数据库 show dbs：查看所有的数据库 use 数据库名：切换数据库，如果数据库不存在，则创建一个(创建完成后需要插入数据库才算创建成功) db.dropDatabase()：删除当前指向的数据库 db.集合名.insert(value)：添加数据到指定的集合中 db.集合名.find()：从指定的集合中查找数据 更多命令请见：http://www.runoob.com/mongodb/mongodb-tutorial.html Python操作 MongoDB安装pymongo要用 python 操作 Mongodb，必须下载一个驱动程序，这个驱动程序就是 pymongo: 1pip install pymongo 连接 MongoDB12345678910111213import pymongo# 获取连接 mongodb 的对象client &#x3D; pymongo.MongoClient(&quot;127.0.0.1&quot;,port&#x3D;27017)# 获取数据库（如果没有这个数据库，也没有关系）db &#x3D; client.zhihu# 获取数据库中的集合（也就是mysql中的表）collection &#x3D; db.qa# 写入数据collection.insert(&#123;&quot;username&quot;:&quot;aaa&quot;&#125;) 数据类型 类型 说明 ObjectID 文档ID String 字符串，最常用，必须是有效的UTF-8 Boolean 存储一个布尔值，true或false Integer 整数可以是32位或64位，这取决于服务器 Double 存储浮点值 Arrays 数组或列表，多个值存储到一个键 Object 用于嵌入式的文档，即一个值为一个文档 Null 存储Null值 Timestamp 时间戳，表示从1970-1-1到现在的总秒数 Date 存储当前日期或时间的Unix时间格式 操作MongoDB操作 MongoDB的主要方法如下： Insert_one：加入一条文档数据到集合中 1234collection.insert_one(&#123; &quot;username&quot;:&quot;abc&quot;, &quot;password&quot;:&quot;hello&quot;&#125;) Insert_many：加入多条文档数据到集合中 1234567collection.insert_many(&#123; &quot;username&quot;:&quot;abc&quot;, &quot;password&quot;:&quot;hello&quot;&#125;,&#123; &quot;username&quot;:&quot;bbb&quot;, &quot;password&quot;:&quot;222222&quot;&#125;) Find_one:查找一条文档对象 12result &#x3D; colloction.find_one()print(result) update_one：更新一条文档 1collection.update_one(&#123;&quot;username&quot;:&quot;bbb&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;age&quot;:20&#125;&#125;) Update_many：更新多条文档 1collection.update_many(&#123;&quot;username&quot;: &quot;aaa&quot;&#125;, &#123;&quot;$set&quot;: &#123;&quot;username&quot;: &quot;bbb&quot;&#125;&#125;) Delete_one：删除一条文档对象 1collection.delete_one(&#123;&quot;age&quot;:20&#125;) Delete_many:删除多条文档对象 1collection.delete_many(&#123;&quot;username&quot;:&quot;bbb&quot;&#125;)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"三、数据存取(3)——MySQL数据库操作","slug":"三、数据存取-3-——MySQL数据库操作","date":"2020-02-13T14:07:26.000Z","updated":"2020-02-13T16:10:03.592Z","comments":true,"path":"2020/02/13/三、数据存取-3-——MySQL数据库操作/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96-3-%E2%80%94%E2%80%94MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","excerpt":"安装mysql：","text":"安装mysql： 在官网：https://dev.mysql.com/downloads/windows/installer/5.7.html 如果提示没有.NET Framework框架。那么就在提示框中找到下载链接，下载一个就可以了。 如果提示没有Microsoft Virtual C++ x64(x86)，那么百度或者谷歌这个软件安装即可。 navicat：navicat是一个操作mysql数据库非常方便的软件。使用他操作数据库，就跟使用excel操作数据是一样的。 安装驱动程序：Python要想操作MySQL。必须要有一个中间件，或者叫做驱动程序。驱动程序有很多。比如有mysqldb、mysqlclient、pymysql等。在这里，我们选择用pymysql。安装方式也是非常简单，通过命令pip install pymysql即可安装。 数据库连接：数据库连接之前。首先先确认以下工作完成，这里我们以一个pymysql_test数据库.以下将介绍连接mysql的示例代码： 123456789101112131415import pymysql# 数据库连接db &#x3D; pymysql.connect( host&#x3D;&quot;127.0.0.1&quot;, user&#x3D;&#39;root&#39;, password&#x3D;&#39;root&#39;, database&#x3D;&#39;pymysql_demo&#39;, port&#x3D;3306)cursor &#x3D; db.cursor()cursor.execute(&quot;select 1&quot;)data &#x3D; cursor.fetchone()print(data)db.close() 插入数据：12345678910111213141516171819import pymysqldb &#x3D; pymysql.connect( host&#x3D;&quot;127.0.0.1&quot;, user&#x3D;&#39;root&#39;, password&#x3D;&#39;root&#39;, database&#x3D;&#39;pymysql_test&#39;, port&#x3D;3306)cursor &#x3D; db.cursor()sql &#x3D; &quot;&quot;&quot;insert into user( id,username,gender,age,password ) values(null,&#39;abc&#39;,1,18,&#39;111111&#39;);&quot;&quot;&quot;cursor.execute(sql)db.commit()db.close() 如果在数据还不能保证的情况下，可以使用以下方式来插入数据： 12345678sql &#x3D; &quot;&quot;&quot;insert into user( id,username,gender,age,password ) values(null,%s,%s,%s,%s);&quot;&quot;&quot;cursor.execute(sql,(&#39;spider&#39;,1,20,&#39;222222&#39;)) 查找数据：使用pymysql查询数据。可以使用fetch*方法。 fetchone()：这个方法每次之获取一条数据。 fetchall()：这个方法接收全部的返回结果。 fetchmany(size)：可以获取指定条数的数据。示例代码如下： 12345678910111213cursor &#x3D; db.cursor()sql &#x3D; &quot;&quot;&quot;select * from user&quot;&quot;&quot;cursor.execute(sql)while True: result &#x3D; cursor.fetchone() if not result: break print(result)db.close() 或者是直接使用fetchall，一次性可以把所有满足条件的数据都取出来： 1234567891011cursor &#x3D; db.cursor()sql &#x3D; &quot;&quot;&quot;select * from user&quot;&quot;&quot;cursor.execute(sql)results &#x3D; cursor.fetchall()for result in results: print(result)db.close() 或者是使用fetchmany，指定获取多少条数据： 1234567891011cursor &#x3D; db.cursor()sql &#x3D; &quot;&quot;&quot;select * from user&quot;&quot;&quot;cursor.execute(sql)results &#x3D; cursor.fetchmany(1)for result in results: print(result)db.close() 删除数据：123456789cursor &#x3D; db.cursor()sql &#x3D; &quot;&quot;&quot;delete from user where id&#x3D;1&quot;&quot;&quot;cursor.execute(sql)db.commit()db.close() 更新数据：12345678910conn &#x3D; pymysql.connect(host&#x3D;&#39;localhost&#39;,user&#x3D;&#39;root&#39;,password&#x3D;&#39;root&#39;,database&#x3D;&#39;pymysql_demo&#39;,port&#x3D;3306)cursor &#x3D; conn.cursor()sql &#x3D; &quot;&quot;&quot;update user set username&#x3D;&#39;aaa&#39; where id&#x3D;1&quot;&quot;&quot;cursor.execute(sql)conn.commit()conn.close()","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"三、数据存取(2)——csv文件处理","slug":"三、数据存取-2-——csv文件处理","date":"2020-02-13T14:05:49.000Z","updated":"2020-02-13T16:10:20.092Z","comments":true,"path":"2020/02/13/三、数据存取-2-——csv文件处理/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96-2-%E2%80%94%E2%80%94csv%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"读取csv文件：","text":"读取csv文件： 1234567import csvwith open(&#39;stock.csv&#39;,&#39;r&#39;) as fp: reader &#x3D; csv.reader(fp) titles &#x3D; next(reader) for x in reader: print(x) 这样操作，以后获取数据的时候，就要通过下表来获取数据。如果想要在获取数据的时候通过标题来获取。那么可以使用DictReader。示例代码如下： 123456import csvwith open(&#39;stock.csv&#39;,&#39;r&#39;) as fp: reader &#x3D; csv.DictReader(fp) for x in reader: print(x[&#39;turnoverVol&#39;]) 写入数据到csv文件：写入数据到csv文件，需要创建一个writer对象，主要用到两个方法。一个是writerow，这个是写入一行。一个是writerows，这个是写入多行。示例代码如下： 123456789101112import csvheaders &#x3D; [&#39;name&#39;,&#39;age&#39;,&#39;classroom&#39;]values &#x3D; [ (&#39;zhiliao&#39;,18,&#39;111&#39;), (&#39;wena&#39;,20,&#39;222&#39;), (&#39;bbc&#39;,21,&#39;111&#39;)]with open(&#39;test.csv&#39;,&#39;w&#39;,newline&#x3D;&#39;&#39;) as fp: writer &#x3D; csv.writer(fp) writer.writerow(headers) writer.writerows(values) 也可以使用字典的方式把数据写入进去。这时候就需要使用DictWriter了。示例代码如下： 123456789101112import csvheaders &#x3D; [&#39;name&#39;,&#39;age&#39;,&#39;classroom&#39;]values &#x3D; [ &#123;&quot;name&quot;:&#39;wenn&#39;,&quot;age&quot;:20,&quot;classroom&quot;:&#39;222&#39;&#125;, &#123;&quot;name&quot;:&#39;abc&#39;,&quot;age&quot;:30,&quot;classroom&quot;:&#39;333&#39;&#125;]with open(&#39;test.csv&#39;,&#39;w&#39;,newline&#x3D;&#39;&#39;) as fp: writer &#x3D; csv.DictWriter(fp,headers) writer &#x3D; csv.writeheader() writer.writerow(&#123;&#39;name&#39;:&#39;zhiliao&#39;,&quot;age&quot;:18,&quot;classroom&quot;:&#39;111&#39;&#125;) writer.writerows(values)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"三、数据存取(1)——json文件处理","slug":"三、数据存取-1-——json文件处理","date":"2020-02-13T14:04:07.000Z","updated":"2020-02-13T16:10:35.706Z","comments":true,"path":"2020/02/13/三、数据存取-1-——json文件处理/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96-1-%E2%80%94%E2%80%94json%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/","excerpt":"什么是json","text":"什么是json JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。更多解释请见：https://baike.baidu.com/item/JSON/2462549?fr=aladdin JSON支持数据格式： 对象（字典）。使用花括号。 数组（列表）。使用方括号。 整形、浮点型、布尔类型还有null类型。 字符串类型（字符串必须要用双引号，不能用单引号）。 多个数据之间使用逗号分开。注意：json本质上就是一个字符串。 字典和列表转JSON：123456789101112131415import jsonbooks &#x3D; [ &#123; &#39;title&#39;: &#39;钢铁是怎样练成的&#39;, &#39;price&#39;: 9.8 &#125;, &#123; &#39;title&#39;: &#39;红楼梦&#39;, &#39;price&#39;: 9.9 &#125;]json_str &#x3D; json.dumps(books,ensure_ascii&#x3D;False)print(json_str) 因为json在dump的时候，只能存放ascii的字符，因此会将中文进行转义，这时候我们可以使用ensure_ascii=False关闭这个特性。在Python中。只有基本数据类型才能转换成JSON格式的字符串。也即：int、float、str、list、dict、tuple。 将json数据直接 dump 到文件中：json模块中除了dumps函数，还有一个dump函数，这个函数可以传入一个文件指针，直接将字符串dump到文件中。示例代码如下： 1234567891011121314books &#x3D; [ &#123; &#39;title&#39;: &#39;钢铁是怎样练成的&#39;, &#39;price&#39;: 9.8 &#125;, &#123; &#39;title&#39;: &#39;红楼梦&#39;, &#39;price&#39;: 9.9 &#125;]with open(&#39;a.json&#39;,&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;) as fp: # fp.write(json_str) json.dump(books,fp,ensure_ascii&#x3D;False) 将一个json字符串load成Python对象：1234json_str &#x3D; &#39;[&#123;&quot;title&quot;: &quot;钢铁是怎样练成的&quot;, &quot;price&quot;: 9.8&#125;, &#123;&quot;title&quot;: &quot;红楼梦&quot;, &quot;price&quot;: 9.9&#125;]&#39;books &#x3D; json.loads(json_str,encoding&#x3D;&#39;utf-8&#39;)print(type(books))print(books) 直接从文件中读取json：123456import jsonwith open(&#39;person.json&#39;,&#39;r&#39;,encoding&#x3D;&#39;utf-8&#39;) as fp: persons &#x3D; json.load(fp) print(type(persons)) for person in persons: print(person)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"二、数据提取(3)——正则表达式和re模块","slug":"二、数据提取-3-——正则表达式和re模块","date":"2020-02-13T13:51:06.000Z","updated":"2020-02-13T16:08:16.991Z","comments":true,"path":"2020/02/13/二、数据提取-3-——正则表达式和re模块/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96-3-%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cre%E6%A8%A1%E5%9D%97/","excerpt":"什么是正则表达式：","text":"什么是正则表达式： 通俗理解：按照一定的规则，从某个字符串中匹配出想要的数据。这个规则就是正则表达式。标准答案：https://baike.baidu.com/item/正则表达式/1700215?fr=aladdin 一个段子：世界是分为两种人，一种是懂正则表达式的，一种是不懂正则表达式的。 正则表达式常用匹配规则：匹配某个字符串：1234text &#x3D; &#39;hello&#39;ret &#x3D; re.match(&#39;he&#39;,text)print(ret.group())&gt;&gt; he 以上便可以在hello中，匹配出he。 点（.）匹配任意的字符：1234text &#x3D; &quot;ab&quot;ret &#x3D; re.match(&#39;.&#39;,text)print(ret.group())&gt;&gt; a 但是点（.）不能匹配不到换行符。示例代码如下： 1234text &#x3D; &quot;ab&quot;ret &#x3D; re.match(&#39;.&#39;,text)print(ret.group())&gt;&gt; AttributeError: &#39;NoneType&#39; object has no attribute &#39;group&#39; \\d匹配任意的数字：1234text &#x3D; &quot;123&quot;ret &#x3D; re.match(&#39;\\d&#39;,text)print(ret.group())&gt;&gt; 1 \\D匹配任意的非数字：1234text &#x3D; &quot;a&quot;ret &#x3D; re.match(&#39;\\D&#39;,text)print(ret.group())&gt;&gt; a 而如果text是等于一个数字，那么就匹配不成功了。示例代码如下： 1234text &#x3D; &quot;1&quot;ret &#x3D; re.match(&#39;\\D&#39;,text)print(ret.group())&gt;&gt; AttributeError: &#39;NoneType&#39; object has no attribute &#39;group&#39; \\s匹配的是空白字符（包括：\\n，\\t，\\r和空格）：1234text &#x3D; &quot;\\t&quot;ret &#x3D; re.match(&#39;\\s&#39;,text)print(ret.group())&gt;&gt; 空白 \\w匹配的是a-z和A-Z以及数字和下划线：1234text &#x3D; &quot;_&quot;ret &#x3D; re.match(&#39;\\w&#39;,text)print(ret.group())&gt;&gt; _ 而如果要匹配一个其他的字符，那么就匹配不到。示例代码如下： 1234text &#x3D; &quot;+&quot;ret &#x3D; re.match(&#39;\\w&#39;,text)print(ret.group())&gt;&gt; AttributeError: &#39;NoneType&#39; object has no attribute \\W匹配的是和\\w相反的：1234text &#x3D; &quot;+&quot;ret &#x3D; re.match(&#39;\\W&#39;,text)print(ret.group())&gt;&gt; + 而如果你的text是一个下划线或者英文字符，那么就匹配不到了。示例代码如下： 1234text &#x3D; &quot;_&quot;ret &#x3D; re.match(&#39;\\W&#39;,text)print(ret.group())&gt;&gt; AttributeError: &#39;NoneType&#39; object has no attribute []组合的方式，只要满足中括号中的某一项都算匹配成功：1234text &#x3D; &quot;0731-88888888&quot;ret &#x3D; re.match(&#39;[\\d\\-]+&#39;,text)print(ret.group())&gt;&gt; 0731-88888888 之前讲到的几种匹配规则，其实可以使用中括号的形式来进行替代： \\d：[0-9] \\D：0-9 \\w：[0-9a-zA-Z_] \\W：[^0-9a-zA-Z_] 匹配多个字符： *：可以匹配0或者任意多个字符。示例代码如下： 1234text &#x3D; &quot;0731&quot;ret &#x3D; re.match(&#39;\\d*&#39;,text)print(ret.group())&gt;&gt; 0731 以上因为匹配的要求是\\d，那么就要求是数字，后面跟了一个星号，就可以匹配到0731这四个字符。 +：可以匹配1个或者多个字符。最少一个。示例代码如下： 1234text &#x3D; &quot;abc&quot;ret &#x3D; re.match(&#39;\\w+&#39;,text)print(ret.group())&gt;&gt; abc 因为匹配的是\\w，那么就要求是英文字符，后面跟了一个加号，意味着最少要有一个满足\\w的字符才能够匹配到。如果text是一个空白字符或者是一个不满足\\w的字符，那么就会报错。示例代码如下： 1234text &#x3D; &quot;&quot;ret &#x3D; re.match(&#39;\\w+&#39;,text)print(ret.group())&gt;&gt; AttributeError: &#39;NoneType&#39; object has no attribute ?：匹配的字符可以出现一次或者不出现（0或者1）。示例代码如下： 1234text &#x3D; &quot;123&quot;ret &#x3D; re.match(&#39;\\d?&#39;,text)print(ret.group())&gt;&gt; 1 {m}：匹配m个字符。示例代码如下： 1234text &#x3D; &quot;123&quot;ret &#x3D; re.match(&#39;\\d&#123;2&#125;&#39;,text)print(ret.group())&gt;&gt; 12 {m,n}：匹配m-n个字符。在这中间的字符都可以匹配到。示例代码如下： 1234text &#x3D; &quot;123&quot;ret &#x3D; re.match(&#39;\\d&#123;1,2&#125;&#39;,text)prit(ret.group())&gt;&gt; 12 如果text只有一个字符，那么也可以匹配出来。示例代码如下： 1234text &#x3D; &quot;1&quot;ret &#x3D; re.match(&#39;\\d&#123;1,2&#125;&#39;,text)prit(ret.group())&gt;&gt; 1 小案例： 验证手机号码：手机号码的规则是以1开头，第二位可以是34587，后面那9位就可以随意了。示例代码如下： 1234text &#x3D; &quot;18570631587&quot;ret &#x3D; re.match(&#39;1[34587]\\d&#123;9&#125;&#39;,text)print(ret.group())&gt;&gt; 18570631587 而如果是个不满足条件的手机号码。那么就匹配不到了。示例代码如下： 1234text &#x3D; &quot;1857063158&quot;ret &#x3D; re.match(&#39;1[34587]\\d&#123;9&#125;&#39;,text)print(ret.group())&gt;&gt; AttributeError: &#39;NoneType&#39; object has no attribute 验证邮箱：邮箱的规则是邮箱名称是用数字、数字、下划线组成的，然后是@符号，后面就是域名了。示例代码如下： 123text &#x3D; &quot;hynever@163.com&quot;ret &#x3D; re.match(&#39;\\w+@\\w+\\.[a-zA-Z\\.]+&#39;,text)print(ret.group()) 验证URL：URL的规则是前面是http或者https或者是ftp然后再加上一个冒号，再加上两个斜杠，再后面就是可以出现任意非空白字符了。示例代码如下： 123text &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;&quot;ret &#x3D; re.match(&#39;(http|https|ftp):&#x2F;&#x2F;[^\\s]+&#39;,text)print(ret.group()) 验证身份证：身份证的规则是，总共有18位，前面17位都是数字，后面一位可以是数字，也可以是小写的x，也可以是大写的X。示例代码如下： 123text &#x3D; &quot;3113111890812323X&quot;ret &#x3D; re.match(&#39;\\d&#123;17&#125;[\\dxX]&#39;,text)print(ret.group()) ^（脱字号）：表示以…开始：123text &#x3D; &quot;hello&quot;ret &#x3D; re.match(&#39;^h&#39;,text)print(ret.group()) 如果是在中括号中，那么代表的是取反操作. $：表示以…结束：12345# 匹配163.com的邮箱text &#x3D; &quot;xxx@163.com&quot;ret &#x3D; re.search(&#39;\\w+@163\\.com$&#39;,text)print(ret.group())&gt;&gt; xxx@163.com |：匹配多个表达式或者字符串：1234text &#x3D; &quot;hello|world&quot;ret &#x3D; re.search(&#39;hello&#39;,text)print(ret.group())&gt;&gt; hello 贪婪模式和非贪婪模式：贪婪模式：正则表达式会匹配尽量多的字符。默认是贪婪模式。非贪婪模式：正则表达式会尽量少的匹配字符。示例代码如下： 12345text &#x3D; &quot;0123456&quot;ret &#x3D; re.match(&#39;\\d+&#39;,text)print(ret.group())# 因为默认采用贪婪模式，所以会输出0123456&gt;&gt; 0123456 可以改成非贪婪模式，那么就只会匹配到0。示例代码如下： 123text &#x3D; &quot;0123456&quot;ret &#x3D; re.match(&#39;\\d+?&#39;,text)print(ret.group()) 案例：匹配0-100之间的数字：1234text &#x3D; &#39;99&#39;ret &#x3D; re.match(&#39;[1-9]?\\d$|100$&#39;,text)print(ret.group())&gt;&gt; 99 而如果text=101，那么就会抛出一个异常。示例代码如下： 1234text &#x3D; &#39;101&#39;ret &#x3D; re.match(&#39;[1-9]?\\d$|100$&#39;,text)print(ret.group())&gt;&gt; AttributeError: &#39;NoneType&#39; object has no attribute &#39;group&#39; 转义字符和原生字符串：在正则表达式中，有些字符是有特殊意义的字符。因此如果想要匹配这些字符，那么就必须使用反斜杠\\进行转义。比如$代表的是以…结尾，如果想要匹配$，那么就必须使用\\$。示例代码如下： 1234text &#x3D; &quot;apple price is \\$99,orange paice is $88&quot;ret &#x3D; re.search(&#39;\\$(\\d+)&#39;,text)print(ret.group())&gt;&gt; $99 原生字符串：在正则表达式中，\\是专门用来做转义的。在Python中\\也是用来做转义的。因此如果想要在普通的字符串中匹配出\\，那么要给出四个\\。示例代码如下： 123text &#x3D; &quot;apple \\c&quot;ret &#x3D; re.search(&#39;\\\\\\\\c&#39;,text)print(ret.group()) 因此要使用原生字符串就可以解决这个问题： 123text &#x3D; &quot;apple \\c&quot;ret &#x3D; re.search(r&#39;\\\\c&#39;,text)print(ret.group()) re模块中常用函数：match：从开始的位置进行匹配。如果开始的位置没有匹配到。就直接失败了。示例代码如下： 1234text &#x3D; &#39;hello&#39;ret &#x3D; re.match(&#39;h&#39;,text)print(ret.group())&gt;&gt; h 如果第一个字母不是h，那么就会失败。示例代码如下： 1234text &#x3D; &#39;ahello&#39;ret &#x3D; re.match(&#39;h&#39;,text)print(ret.group())&gt;&gt; AttributeError: &#39;NoneType&#39; object has no attribute &#39;group&#39; 如果想要匹配换行的数据，那么就要传入一个flag=re.DOTALL，就可以匹配换行符了。示例代码如下： 123text &#x3D; &quot;abc\\nabc&quot;ret &#x3D; re.match(&#39;abc.*abc&#39;,text,re.DOTALL)print(ret.group()) search：在字符串中找满足条件的字符。如果找到，就返回。说白了，就是只会找到第一个满足条件的。 1234text &#x3D; &#39;apple price $99 orange price $88&#39;ret &#x3D; re.search(&#39;\\d+&#39;,text)print(ret.group())&gt;&gt; 99 分组：在正则表达式中，可以对过滤到的字符串进行分组。分组使用圆括号的方式。 group：和group(0)是等价的，返回的是整个满足条件的字符串。 groups：返回的是里面的子组。索引从1开始。 group(1)：返回的是第一个子组，可以传入多个。示例代码如下： 1234567text &#x3D; &quot;apple price is $99,orange price is $10&quot;ret &#x3D; re.search(r&quot;.*(\\$\\d+).*(\\$\\d+)&quot;,text)print(ret.group())print(ret.group(0))print(ret.group(1))print(ret.group(2))print(ret.groups()) findall：找出所有满足条件的，返回的是一个列表。 1234text &#x3D; &#39;apple price $99 orange price $88&#39;ret &#x3D; re.findall(&#39;\\d+&#39;,text)print(ret)&gt;&gt; [&#39;99&#39;, &#39;88&#39;] sub：用来替换字符串。将匹配到的字符串替换为其他字符串。 1234text &#x3D; &#39;apple price $99 orange price $88&#39;ret &#x3D; re.sub(&#39;\\d+&#39;,&#39;0&#39;,text)print(ret)&gt;&gt; apple price $0 orange price $0 sub函数的案例，获取拉勾网中的数据： 123456789101112131415161718192021html &#x3D; &quot;&quot;&quot;&lt;div&gt;&lt;p&gt;基本要求：&lt;&#x2F;p&gt;&lt;p&gt;1、精通HTML5、CSS3、 JavaScript等Web前端开发技术，对html5页面适配充分了解，熟悉不同浏览器间的差异，熟练写出兼容各种浏览器的代码；&lt;&#x2F;p&gt;&lt;p&gt;2、熟悉运用常见JS开发框架，如JQuery、vue、angular，能快速高效实现各种交互效果；&lt;&#x2F;p&gt;&lt;p&gt;3、熟悉编写能够自动适应HTML5界面，能让网页格式自动适应各款各大小的手机；&lt;&#x2F;p&gt;&lt;p&gt;4、利用HTML5相关技术开发移动平台、PC终端的前端页面，实现HTML5模板化；&lt;&#x2F;p&gt;&lt;p&gt;5、熟悉手机端和PC端web实现的差异，有移动平台web前端开发经验，了解移动互联网产品和行业，有在Android,iOS等平台下HTML5+CSS+JavaScript（或移动JS框架）开发经验者优先考虑；6、良好的沟通能力和团队协作精神，对移动互联网行业有浓厚兴趣，有较强的研究能力和学习能力；&lt;&#x2F;p&gt;&lt;p&gt;7、能够承担公司前端培训工作，对公司各业务线的前端（HTML5\\CSS3）工作进行支撑和指导。&lt;&#x2F;p&gt;&lt;p&gt;&lt;br&gt;&lt;&#x2F;p&gt;&lt;p&gt;岗位职责：&lt;&#x2F;p&gt;&lt;p&gt;1、利用html5及相关技术开发移动平台、微信、APP等前端页面，各类交互的实现；&lt;&#x2F;p&gt;&lt;p&gt;2、持续的优化前端体验和页面响应速度，并保证兼容性和执行效率；&lt;&#x2F;p&gt;&lt;p&gt;3、根据产品需求，分析并给出最优的页面前端结构解决方案；&lt;&#x2F;p&gt;&lt;p&gt;4、协助后台及客户端开发人员完成功能开发和调试；&lt;&#x2F;p&gt;&lt;p&gt;5、移动端主流浏览器的适配、移动端界面自适应研发。&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&quot;&quot;&quot;ret &#x3D; re.sub(&#39;&lt;&#x2F;?[a-zA-Z0-9]+&gt;&#39;,&quot;&quot;,html)print(ret) split：使用正则表达式来分割字符串。 1234text &#x3D; &quot;hello world ni hao&quot;ret &#x3D; re.split(&#39;\\W&#39;,text)print(ret)&gt;&gt; [&quot;hello&quot;,&quot;world&quot;,&quot;ni&quot;,&quot;hao&quot;] compile：对于一些经常要用到的正则表达式，可以使用compile进行编译，后期再使用的时候可以直接拿过来用，执行效率会更快。而且compile还可以指定flag=re.VERBOSE，在写正则表达式的时候可以做好注释。示例代码如下： 12345678text &#x3D; &quot;the number is 20.50&quot;r &#x3D; re.compile(r&quot;&quot;&quot; \\d+ # 小数点前面的数字 \\.? # 小数点 \\d* # 小数点后面的数字 &quot;&quot;&quot;,re.VERBOSE)ret &#x3D; re.search(r,text)print(ret.group()) 实战：爬取古诗文网123456789101112131415161718192021222324252627282930313233343536373839404142434445import requestsimport redef parse_page(url): headers &#x3D; &#123; &#39;User_Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39; &#125; response &#x3D; requests.get(url, headers&#x3D;headers) text &#x3D; response.text titles &#x3D; re.findall(r&#39;&lt;div\\sclass&#x3D;&quot;cont&quot;&gt;.*?&lt;b&gt;(.*?)&lt;&#x2F;b&gt;&#39;, text, re.DOTALL) dynasties &#x3D; re.findall(r&#39;&lt;p class&#x3D;&quot;source&quot;&gt;.*?&lt;a.*?&gt;(.*?)&lt;&#x2F;a&gt;&#39;, text, re.DOTALL) authors &#x3D; re.findall(r&#39;&lt;p class&#x3D;&quot;source&quot;&gt;.*?&lt;a.*?&gt;.*?&lt;a.*?&gt;(.*?)&lt;&#x2F;a&gt;&#39;, text, re.DOTALL) content_tags &#x3D; re.findall(r&#39;&lt;div class&#x3D;&quot;contson&quot;.*?&gt;(.*?)&lt;&#x2F;div&gt;&#39;, text, re.DOTALL) contents &#x3D; [] for content in content_tags: x &#x3D; re.sub(r&#39;&lt;.*?&gt;&#39;,&#39;&#39;,content) contents.append(x.strip()) poems &#x3D; [] for value in zip(titles,dynasties,authors,contents): title,dynasty,author,content &#x3D; value poem &#x3D; &#123; &#39;title&#39;:title, &#39;dynasty&#39;:dynasty, &#39;author&#39;:author, &#39;content&#39;:content &#125; poems.append(poem) for poem in poems: print(poem) print(&#39;&#x3D;&#39;*50)def main(): url &#x3D; &#39;https:&#x2F;&#x2F;www.gushiwen.org&#x2F;default_2.aspx&#39; for x in range(1,11): url &#x3D; &#39;https:&#x2F;&#x2F;www.gushiwen.org&#x2F;default_%d.aspx&#39; %x parse_page(url)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 作业：用正则表达式爬取糗事百科12345678910111213141516171819202122232425262728import requestsimport redef parse_page(url): headers &#x3D; &#123; &#39;User_Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39; &#125; response &#x3D; requests.get(url, headers&#x3D;headers) text &#x3D; response.text contents &#x3D; re.findall(r&#39;&lt;div\\sclass&#x3D;&quot;content&quot;&gt;.*?&lt;span&gt;(.*?)&lt;&#x2F;span&gt;&#39;, text, re.DOTALL) duanzi &#x3D; [] for content in contents: x &#x3D; re.sub(r&#39;&lt;.*?&gt;&#39;, &#39;&#39;, content) duanzi.append(x.strip()) print(x.strip()) print(&#39;&#x3D;&#39; * 50)def main(): url &#x3D; &#39;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;text&#x2F;page&#x2F;3&#x2F;&#39; for x in range(1, 10): url &#x3D; &#39;https:&#x2F;&#x2F;www.qiushibaike.com&#x2F;text&#x2F;page&#x2F;%s&#x2F;&#39; % x parse_page(url)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main()","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"二、数据提取(2)——BeautifulSoup4库","slug":"二、数据提取-2-——BeautifulSoup4库","date":"2020-02-13T13:46:30.000Z","updated":"2020-02-13T16:08:46.079Z","comments":true,"path":"2020/02/13/二、数据提取-2-——BeautifulSoup4库/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96-2-%E2%80%94%E2%80%94BeautifulSoup4%E5%BA%93/","excerpt":"BeautifulSoup4库","text":"BeautifulSoup4库 和lxml一样，BeautifulSoup也是一个HTML/XML的解析器，主要的功能也是如何解析和提取 HTML/XML数据。 lxml只会局部遍历，而BeautifulSoup是基于HTML DOM的，会载入整个目标，解析整个DOM树，因此时间和内存开销都会大很多，所以性能要低于lxml。 BeautifulSoup用来解析 HTML 比较简单，API 非常人性化，支持 CSS 选择器，Python标准库中的 HTML 解析器，也支持 lxml 的XML解析器。 BeautifulSoup3目前已经停止开发，推荐现在的项目使用 BeautifulSoup 4。 安装和文件 安装：pip install bs4 中文文档：https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html 几大解析工具对比 解析工具 解析速度 使用难度 BeautifulSoup 最慢 最简单 lxml 快 简单 正则 最快 最难 简单使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112from bs4 import BeautifulSouphtml &#x3D; &quot;&quot;&quot;&lt;table class&#x3D;&quot;tablelist&quot; cellpadding&#x3D;&quot;0&quot; cellspacing&#x3D;&quot;0&quot;&gt; &lt;tbody&gt; &lt;tr class&#x3D;&quot;h&quot;&gt; &lt;td class&#x3D;&quot;l&quot; width&#x3D;&quot;374&quot;&gt;职位名称&lt;&#x2F;td&gt; &lt;td&gt;职位类别&lt;&#x2F;td&gt; &lt;td&gt;人数&lt;&#x2F;td&gt; &lt;td&gt;地点&lt;&#x2F;td&gt; &lt;td&gt;发布时间&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48569&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;26699-智慧零售业务中心前端开发（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48556&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;22989-高级AI后台开发工程师（上海&#x2F;深圳）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48537&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;25666-腾讯云华东区域解决方案支持&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48534&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;CSIG02-腾讯云行业方案架构师（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48428&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;25929-高级机器学习工程师&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48425&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;30628-腾讯广告投放平台PHP开发工程师（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48393&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;CSIG16-车联网系统工程师（自研基础产品运维负责人）（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48394&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;CSIG16-车联网IT运维经理（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48380&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;22989-腾讯云-区域交付leader（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48349&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;27570-高级引擎工程师&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;&quot;&quot;&quot;# 创建 Beautiful Soup对象# 使用 lxml来进行解析soup &#x3D; BeautifulSoup(html,&quot;lxml&quot;)# bs4 &#x3D;&gt; lxmlprint(soup.prettify()) 四个常用的对象BeautifulSoup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种： Tag NavigableString BeautifulSoup Comment 1.Tag：Tag通俗点讲就是 HTML 中的一个个标签。示例代码如下： 12345678910111213141516171819202122232425262728293031from bs4 import BeautifulSouphtml &#x3D; &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;p class&#x3D;&quot;title&quot; name&#x3D;&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;&#x2F;a&gt;,&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt; and&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;;and they lived at the bottom of a well.&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;story&quot;&gt;...&lt;&#x2F;p&gt;&quot;&quot;&quot;#创建 Beautiful Soup 对象soup &#x3D; BeautifulSoup(html,&#39;lxml&#39;)print soup.title# &lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;print soup.head# &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;print soup.a# &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;&#x2F;a&gt;print soup.p# &lt;p class&#x3D;&quot;title&quot; name&#x3D;&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;print type(soup.p)# &lt;class &#39;bs4.element.Tag&#39;&gt; 我们可以利用 soup 加标签名轻松地获取这些标签的内容，这些对象的类型是bs4.element.Tag。但是注意，它查找的是在所有内容中的第一个符合要求的标签。如果要查询所有的标签，后面会进行介绍。 对于Tag，它有两个重要的属性，分别是name和attrs。示例代码如下： 12345678910111213141516print soup.name# [document] #soup 对象本身比较特殊，它的 name 即为 [document]print soup.head.name# head #对于其他内部标签，输出的值便为标签本身的名称print soup.p.attrs# &#123;&#39;class&#39;: [&#39;title&#39;], &#39;name&#39;: &#39;dromouse&#39;&#125;# 在这里，我们把 p 标签的所有属性打印输出了出来，得到的类型是一个字典。print soup.p[&#39;class&#39;] # soup.p.get(&#39;class&#39;)# [&#39;title&#39;] #还可以利用get方法，传入属性的名称，二者是等价的soup.p[&#39;class&#39;] &#x3D; &quot;newClass&quot;print soup.p # 可以对这些属性和内容等等进行修改# &lt;p class&#x3D;&quot;newClass&quot; name&#x3D;&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt; 2. NavigableString:如果拿到标签后，还想获取标签中的内容。那么可以通过tag.string获取标签中的文字。示例代码如下： 12345print soup.p.string# The Dormouse&#39;s storyprint type(soup.p.string)# &lt;class &#39;bs4.element.NavigableString&#39;&gt;thon 3. BeautifulSoup:BeautifulSoup 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 Tag 对象,它支持 遍历文档树 和 搜索文档树 中描述的大部分的方法. 因为 BeautifulSoup 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 .name 属性是很方便的,所以 BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性 .name 12soup.name# &#39;[document]&#39; 4. Comment:Tag , NavigableString , BeautifulSoup 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分: 12345markup &#x3D; &quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;&#x2F;b&gt;&quot;soup &#x3D; BeautifulSoup(markup)comment &#x3D; soup.b.stringtype(comment)# &lt;class &#39;bs4.element.Comment&#39;&gt; Comment 对象是一个特殊类型的 NavigableString 对象: 12comment# &#39;Hey, buddy. Want to buy a used parser&#39; 遍历文档树1. contents和children：123456789101112131415161718192021222324html_doc &#x3D; &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;p class&#x3D;&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt; and&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;;and they lived at the bottom of a well.&lt;&#x2F;p&gt;&lt;p class&#x3D;&quot;story&quot;&gt;...&lt;&#x2F;p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup &#x3D; BeautifulSoup(html_doc,&#39;lxml&#39;)head_tag &#x3D; soup.head# 返回所有子节点的列表print(head_tag.contents)# 返回所有子节点的迭代器for child in head_tag.children: print(child) 2. Strings 和 stripped_strings如果tag中包含多个字符串 [2] ,可以使用 .strings 来循环获取： 12345678910111213141516for string in soup.strings: print(repr(string)) # u&quot;The Dormouse&#39;s story&quot; # u&#39;\\n\\n&#39; # u&quot;The Dormouse&#39;s story&quot; # u&#39;\\n\\n&#39; # u&#39;Once upon a time there were three little sisters; and their names were\\n&#39; # u&#39;Elsie&#39; # u&#39;,\\n&#39; # u&#39;Lacie&#39; # u&#39; and\\n&#39; # u&#39;Tillie&#39; # u&#39;;\\nand they lived at the bottom of a well.&#39; # u&#39;\\n\\n&#39; # u&#39;...&#39; # u&#39;\\n&#39; 输出的字符串中可能包含了很多空格或空行,使用 .stripped_strings 可以去除多余空白内容： 123456789101112for string in soup.stripped_strings: print(repr(string)) # u&quot;The Dormouse&#39;s story&quot; # u&quot;The Dormouse&#39;s story&quot; # u&#39;Once upon a time there were three little sisters; and their names were&#39; # u&#39;Elsie&#39; # u&#39;,&#39; # u&#39;Lacie&#39; # u&#39;and&#39; # u&#39;Tillie&#39; # u&#39;;\\nand they lived at the bottom of a well.&#39; # u&#39;...&#39; 搜索文档树1.find和find_all方法搜索文档时，一般用得比较多的就是两个方法，一个是find，一个是find_all。find方法是找到第一个满足条件的标签后就立即返回，只返回一个元素。find_all方法是把所有满足条件的标签都选到，然后返回回去。使用这两个方法，最常用的用法是出入name以及attr参数找出符合要求的标签。 1soup.find_all(&quot;a&quot;,attrs&#x3D;&#123;&quot;id&quot;:&quot;link2&quot;&#125;) 或者是直接传入属性的名字作为关键字参数： 1soup.find_all(&quot;a&quot;,id&#x3D;&quot;link2&quot;) 2. select方法使用以上方法可以方便的找出元素。但有时候使用css选择器的方式可以更加的方便。使用css选择器的语法，应该使用select方法。以下列出几种常用 的css选择器方法： (1) 通过标签名查找 1print(soup.select(&#39;a&#39;)) (2) 通过类名查找 通过类名，则应该在类的前面加一个 . 。比如要查找 class=sister()的标签。示例代码如下： 1print(soup.select(&#39;.sister&#39;)) (3)通过id查找 通过id查找，应该在id的名字前面加一个＃号。示例代码如下： 1print(soup.select(&quot;#link1&quot;)) (4)组合查找 组合查找即和写 class 文件时，标签名与类名、id名进行的组合原理是一样的，例如查找 p 标签中，id 等于 link1的内容，二者需要用空格分开： 1print(soup.select(&quot;p #link1&quot;)) 直接子标签查找，则使用 &gt; 分隔： 1print(soup.select(&quot;head &gt; title&quot;)) (5)通过属性查找 查找时还可以加入属性元素，属性需要用中括号括起来，注意属性和标签属于同一节点，所以中间不能加空格，否则会无法匹配到。示例代码如下： 1print(soup.select(&#39;a[href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot;]&#39;)) （6）获取内容 以上的 select 方法返回的结果都是列表形式，可以遍历形式输出，然后用 get_text() 方法来获取它的内容。 123456soup &#x3D; BeautifulSoup(html, &#39;lxml&#39;)print type(soup.select(&#39;title&#39;))print soup.select(&#39;title&#39;)[0].get_text()for title in soup.select(&#39;title&#39;): print title.get_text() 实战：爬取中国天气网华北地区的天气123456789101112131415161718192021222324252627282930import requestsfrom bs4 import BeautifulSoupdef parse_page(url): headers &#x3D; &#123; &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39; &#125; response &#x3D; requests.get(url,headers&#x3D;headers) text &#x3D; response.content.decode(&#39;utf-8&#39;) soup &#x3D; BeautifulSoup(text,&#39;lxml&#39;) conMidtab &#x3D; soup.find(&#39;div&#39;,class_&#x3D;&#39;conMidtab&#39;) tables &#x3D; conMidtab.find_all(&#39;table&#39;) for table in tables: trs &#x3D; table.find_all(&#39;tr&#39;)[2:] for tr in trs: tds &#x3D; tr.find_all(&#39;td&#39;) city_td &#x3D; tds[0] city &#x3D; list(city_td.stripped_strings)[0] temp_td &#x3D; tds[-2] min_temp &#x3D; list(temp_td.stripped_strings)[0] print(&#123;&quot;city&quot;:city,&quot;min_temp&quot;:min_temp&#125;)def main(): url &#x3D; &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;hb.shtml&#39; parse_page(url)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 实战2：爬取全国的最低气温并导出前十排行榜123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 1 import requests 2 from bs4 import BeautifulSoup 3 from pyecharts import Bar 4 5 ALL_DATA &#x3D; [] 6 7 def parse_page(url): 8 headers &#x3D; &#123; 9 &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39; 10 &#125;11 response &#x3D; requests.get(url,headers&#x3D;headers)12 text &#x3D; response.content.decode(&#39;utf-8&#39;)13 # html5lib14 # pip install html5lib15 soup &#x3D; BeautifulSoup(text,&#39;html5lib&#39;)16 conMidtab &#x3D; soup.find(&#39;div&#39;,class_&#x3D;&#39;conMidtab&#39;)17 tables &#x3D; conMidtab.find_all(&#39;table&#39;)18 for table in tables:19 trs &#x3D; table.find_all(&#39;tr&#39;)[2:]20 for index,tr in enumerate(trs):21 tds &#x3D; tr.find_all(&#39;td&#39;)22 city_td &#x3D; tds[0]23 if index &#x3D;&#x3D; 0:24 city_td &#x3D; tds[1]25 city &#x3D; list(city_td.stripped_strings)[0]26 temp_td &#x3D; tds[-2] 27 min_temp &#x3D; list(temp_td.stripped_strings)[0]28 ALL_DATA.append(&#123;&quot;city&quot;:city,&quot;min_temp&quot;:min_temp&#125;)29 #print(&#123;&quot;city&quot;:city,&quot;min_temp&quot;:min_temp&#125;)30 31 32 def main():33 #url &#x3D; &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;hb.shtml&#39;34 #url &#x3D; &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;db.shtml&#39;35 #url &#x3D; &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;hd.shtml&#39;36 #url &#x3D; &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;hz.shtml&#39;37 #url &#x3D; &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;hn.shtml&#39;38 #url &#x3D; &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;xb.shtml&#39;39 #url &#x3D; &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;xn.shtml&#39;40 #url &#x3D; &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;gat.shtml&#39;41 urls &#x3D; &#123;42 &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;hb.shtml&#39;,43 &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;db.shtml&#39;,44 &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;hd.shtml&#39;,45 &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;hz.shtml&#39;,46 &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;hn.shtml&#39;,47 &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;xb.shtml&#39;,48 &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;xn.shtml&#39;,49 &#39;http:&#x2F;&#x2F;www.weather.com.cn&#x2F;textFC&#x2F;gat.shtml&#39;50 &#125;51 for url in urls:52 parse_page(url)53 54 #分析数据55 # 根据最低气温进行排序56 ALL_DATA.sort(key &#x3D; lambda data:int(data[&#39;min_temp&#39;]))57 58 data &#x3D; ALL_DATA[0:10]59 cities &#x3D; []60 cities &#x3D; list(map(lambda x:x[&#39;city&#39;],data)) 61 temps &#x3D; list(map(lambda x:x[&#39;min_temp&#39;],data))62 63 chart &#x3D; Bar(&quot;中国天气最低气温排行榜&quot;)64 chart.add(&#39;&#39;,cities,temps)65 chart.render(&#39;temperature.html&#39;)66 67 68 if __name__ &#x3D;&#x3D; &#39;__main__&#39;:69 main()","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"二、数据提取(1)——xpath语法与lxml库","slug":"二、数据提取-1-——xpath语法与lxml库","date":"2020-02-13T13:39:16.000Z","updated":"2020-02-13T16:09:06.761Z","comments":true,"path":"2020/02/13/二、数据提取-1-——xpath语法与lxml库/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96-1-%E2%80%94%E2%80%94xpath%E8%AF%AD%E6%B3%95%E4%B8%8Elxml%E5%BA%93/","excerpt":"1. XPath语法","text":"1. XPath语法 什么是XPath？xpath（XML Path Language）是一门在XML和HTML文档中查找信息的语言，可用来在XML和HTML文档中对元素和属性进行遍历。 XPath开发工具 Chrome插件XPath Helper Firefox插件Xpath Checker XPath语法选取节点Xpath使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。 表达式 描述 示例 结果 nodename 选取此节点的所有子节点 bookstore 选取bookstore下所有的子节点 / 如果是在最前面，代表从根节点选取。否则选择某节点下的某个节点 /bookstore 选取根元素下所有的bookstore节点 // 从全局节点中选择节点，随便在哪个位置 //book 从全局节点中找到所有的book节点 @ 选取某个节点的属性 //book[@price] 选择所有拥有price属性的book节点 使用方式使用 //获取整个页面当中的元素，然后写标签名，然后再写谓词进行提取。比如: 1&#x2F;&#x2F;div[@class&#x3D;&#39;abc&#39;] 需要注意的知识点： / 和 // 的区别：/ 代表只获取直接子节点。//获取子孙节点。一般 // 用得比较多，当然也要视情况而定。 contains：有时候某个属性中包含了多个值，那么可以使用contains函数。示例代码如下： 1&#x2F;&#x2F;div[contains(@class,&#39;job_detail&#39;)] 谓词中的下标是从1开始的，不是从0开始的。 谓语谓语用来查找某个特定的节点或者包含某个指定的值的节点，被嵌在方括号中。在下面的表格中，我们列出了带有谓语的一些路径表达式，以及表达式的结果： 路径表达式 描述 /bookstore/book[1] 选取bookstore下的第一个子元素 /bookstore/book[last()] 选取bookstore下的倒数第二个book元素 bookstore/book[position()&lt;3] 选取bookstore下前面两个子元素 //book[@price] 选取拥有price属性的book元素 //book[@price=10] 选取所有属性price等于10的book元素 通配符*表示通配符。 通配符 描述 示例 结果 * 匹配任意节点 /bookstore/* 选取bookstore下的所有子元素 @* 匹配节点中的任何属性 //book[@*] 选取所有带有属性的book元素 选取多个路径通过在路径表达式中使用“i”运算符，可以选取若干个路径。 示例如下： 12&#x2F;&#x2F;bookstore&#x2F;book | &#x2F;&#x2F;book&#x2F;title# 选取所有book元素以及book元素下所有的title元素 运算符 运算符 描述 示例 返回值 | 计算两个节点集 //book | //cd 返回所有拥有 book 和 cd 元素的节点集 + 加法 6 + 4 10 - 减法 6 - 4 2 * 乘法 6 * 4 24 div 除法 8 div 4 2 = 等于 price = 9.80 如果price是9.80，则返回true，如果不是，则返回false != 不等于 price != 9.80 如果price不是9.80，则返回true，如果是，则返回false &lt; 小于 price &lt; 9.80 如果price小于9.80，则返回true，如果不是，则返回false &lt;= 小于或等于 price &lt;= 9.80 如果price小于或等于9.80，则返回true，如果不是，则返回false &gt; 大于 price &gt; 9.80 如果price大于9.80，则返回true，如果不是，则返回false &gt;= 大于或等于 price &gt;= 9.80 如果price大于或等于9.80，则返回true，如果不是，则返回false or 或 price = 9.80 or price = 9.70 满足任意一个条件，则返回true，如果不是，则返回false and 与 price &gt; 9.0 and price &lt; 9.70 同时满足两边条件，则返回true，如果不是，则返回false Mod 计算除法的余数 5 mod 2 1 2. lxml库lxml是一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML数据。 lxml和正则一样，也是用C实现，是一款高性能的 Python HTML/XML解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。 lxml python官方文档：http://lxml.de/index.html 需要安装C语言库，可使用pip安装：pip install lxml 基本使用解析html字符串：使用lxml.etree.HTML进行解析。我们可以利用它来解析HTML代码，并且在解析HTML代码的时候，如果HTML代码不规范，它会自动进行补全。示例代码如下： 123456789101112131415161718from lxml import etreetext &#x3D; &quot;&quot;&quot;&lt;div&gt; &lt;ul&gt; &lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link1.html&quot;&gt;first item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item-1&quot;&gt;&lt;a href&#x3D;&quot;link2.html&quot;&gt;second item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item-inactive&quot;&gt;&lt;a href&#x3D;&quot;link3.html&quot;&gt;third item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link4.html&quot;&gt;fourth item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link5.html&quot;&gt;fifth item&lt;&#x2F;a&gt; # 注意此处缺少一个&lt;&#x2F;li&gt;闭合标签 &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&quot;&quot;&quot;# 利用etree.HTML 将字符串解析为HTML文档htmlElement &#x3D; etree.HTML(text)# 按字符串序列化HTML文档print(etree.tostring(htmlElement,encoding&#x3D;&#39;utf-8&#39;).decode(&#39;utf-8&#39;)) 输出结果如下： 12345678910111213 1 &lt;html&gt; 2 &lt;body&gt; 3 &lt;div&gt; 4 &lt;ul&gt; 5 &lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link1.html&quot;&gt;first item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; 6 &lt;li class&#x3D;&quot;item-1&quot;&gt;&lt;a href&#x3D;&quot;link2.html&quot;&gt;second item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; 7 &lt;li class&#x3D;&quot;item-inactive&quot;&gt;&lt;a href&#x3D;&quot;link3.html&quot;&gt;third item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; 8 &lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link4.html&quot;&gt;fourth item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; 9 &lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link5.html&quot;&gt;fifth item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;10 &lt;&#x2F;ul&gt;11 &lt;&#x2F;div&gt;12 &lt;&#x2F;body&gt;13 &lt;&#x2F;html&gt; 可以看到Lxml会自动修改HTML代码。例子中不仅补全了li标签，还添加了body，html标签。 从文件中读取html代码除了直接使用字符串进行解析，lxml还支持从文件中读取内容。我们新建一个hello.html文件： 12345678910&lt;!-- hello.html --&gt;&lt;div&gt; &lt;ul&gt; &lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link1.html&quot;&gt;first item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item-1&quot;&gt;&lt;a href&#x3D;&quot;link2.html&quot;&gt;second item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item-inactive&quot;&gt;&lt;a href&#x3D;&quot;link3.html&quot;&gt;third item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item-1&quot;&gt;&lt;a href&#x3D;&quot;link4.html&quot;&gt;fourth item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;li class&#x3D;&quot;item-0&quot;&gt;&lt;a href&#x3D;&quot;link5.html&quot;&gt;fifth item&lt;&#x2F;a&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt; 然后利用 lxml.etree.parse()方法来读取文件。示例代码如下： 1234567from lxml import etree#读取外部文件 hello.htmlhtmlElement &#x3D; etree.parse(&#39;hello.html&#39;)print(etree.tostring(htmlElement, encoding&#x3D;&#39;utf-8&#39;).decode(&#39;utf-8&#39;))print(result) 输出结果和之前是相同的。 这个函数默认使用的是XML解析器。如果遇到一些不规范的HTML代码的时候就会解析错误，这个时候就要自己创建HTML解析器。 123parser &#x3D; etree.HTMLParser(encoding&#x3D;&#39;utf-8&#39;)htmlElement &#x3D; etree.parse(&#39;lagou.html&#39;,parser&#x3D;parser)print(etree.tostring(htmlElement,pretty_print&#x3D;True,encoding&#x3D;&#39;utf-8&#39;).decode(&#39;utf-8&#39;)) 在lxml中使用XPath语法示例1-hello.html\\1. 获取所有li标签 1234567from lxml import etreehtml &#x3D; etree.parse(&#39;hello.html&#39;)print(type(html)) # 显示 etree.parse() 返回类型result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li&#39;)print(result) # 打印&lt;li&gt;标签的元素集合 \\2. 获取所有li元素下的所有class属性的值 123456from lxml import etreehtml &#x3D; etree.parse(&#39;hello.html&#39;)result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li&#x2F;@class&#39;)print(result) \\3. 获取li标签下href为 www.baidu.com的a标签 123456from lxml import etreehtml &#x3D; etree.parse(&#39;hello.html&#39;)result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li&#x2F;a[@href&#x3D;&quot;www.baidu.com&quot;]&#39;)print(result) \\4. 获取li标签下所有span标签 123456789from lxml import etreehtml &#x3D; etree.parse(&#39;hello.html&#39;)#result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li&#x2F;span&#39;)# 注意这么写是不对的# 因为 &#x2F; 是用来获取子元素的，而&lt;span&gt;并不是&lt;li&gt;的子元素，所以，要用双斜杠result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li&#x2F;&#x2F;span&#39;)print(result) \\5. 获取li标签下的a标签里的所有class 12345from lxml import etreehtml &#x3D; etree.parse(&#39;hello.html&#39;)result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li&#x2F;a&#x2F;&#x2F;@class&#39;)print(result) \\6. 获取最后一个li的a的href属性对应的值 123456from lxml import etreehtml &#x3D; etree.parse(&#39;hello.html&#39;)result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[last()]&#x2F;a&#x2F;@href&#39;)# 谓语[last()] 可以找到最后一个元素print(result) \\7. 获取倒数第二个li元素的内容 1234567from lxml import etreehtml &#x3D; etree.parse(&#39;hello.html&#39;)result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[last()-1]&#x2F;a&#39;)# text 方法可以获取元素内容print(result[0].text) \\8. 获取倒数第二个li元素的内容的第二种方式 12345from lxml import etreehtml &#x3D; etree.parse(&#39;hello.html&#39;)result &#x3D; html.xpath(&#39;&#x2F;&#x2F;li[last()-1]&#x2F;a&#x2F;text&#39;)print(result) 示例2-tencent.html：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;table class&#x3D;&quot;tablelist&quot; cellpadding&#x3D;&quot;0&quot; cellspacing&#x3D;&quot;0&quot;&gt; &lt;tbody&gt; &lt;tr class&#x3D;&quot;h&quot;&gt; &lt;td class&#x3D;&quot;l&quot; width&#x3D;&quot;374&quot;&gt;职位名称&lt;&#x2F;td&gt; &lt;td&gt;职位类别&lt;&#x2F;td&gt; &lt;td&gt;人数&lt;&#x2F;td&gt; &lt;td&gt;地点&lt;&#x2F;td&gt; &lt;td&gt;发布时间&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48569&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;26699-智慧零售业务中心前端开发（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48556&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;22989-高级AI后台开发工程师（上海&#x2F;深圳）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48537&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;25666-腾讯云华东区域解决方案支持&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48534&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;CSIG02-腾讯云行业方案架构师（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48428&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;25929-高级机器学习工程师&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48425&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;30628-腾讯广告投放平台PHP开发工程师（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48393&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;CSIG16-车联网系统工程师（自研基础产品运维负责人）（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48394&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;CSIG16-车联网IT运维经理（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;even&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48380&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;22989-腾讯云-区域交付leader（上海）&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;1&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;tr class&#x3D;&quot;odd&quot;&gt; &lt;td class&#x3D;&quot;l square&quot;&gt;&lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;position_detail.php?id&#x3D;48349&amp;keywords&#x3D;&amp;tid&#x3D;87&amp;lid&#x3D;2175&quot;&gt;27570-高级引擎工程师&lt;&#x2F;a&gt; &lt;&#x2F;td&gt; &lt;td&gt;技术类&lt;&#x2F;td&gt; &lt;td&gt;2&lt;&#x2F;td&gt; &lt;td&gt;上海&lt;&#x2F;td&gt; &lt;td&gt;2019-03-15&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt; &lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt; \\1. 获取所有tr标签 1234567891011from lxml import etreeparser &#x3D; etree.HTMLParser(encoding&#x3D;&#39;utf-8&#39;)html &#x3D; etree.parse(&quot;tencent.html&quot;,parser&#x3D;parser)# 1.获取所有tr标签# &#x2F;&#x2F;tr# xpath函数返回的是一个列表trs &#x3D; html.xpath(&#39;&#x2F;&#x2F;tr&#39;)for tr in trs: print(etree.tostring(tr,encoding&#x3D;&#39;utf-8&#39;).decode(&#39;utf-8&#39;)) \\2. 获取第2个tr标签 12345678from lxml import etreeparser &#x3D; etree.HTMLParser(encoding&#x3D;&#39;utf-8&#39;)html &#x3D; etree.parse(&quot;tencent.html&quot;,parser&#x3D;parser)# 2.获取第2个tr标签tr &#x3D; html.xpath(&#39;&#x2F;&#x2F;tr[2]&#39;)[0]print(etree.tostring(tr,encoding&#x3D;&#39;utf-8&#39;).decode(&#39;utf-8&#39;)) \\3. 获取所有class等于even的tr标签 123456789from lxml import etreeparser &#x3D; etree.HTMLParser(encoding&#x3D;&#39;utf-8&#39;)html &#x3D; etree.parse(&quot;tencent.html&quot;,parser&#x3D;parser)# 3.获取所有class等于even的标签trs &#x3D; html.xpath(&quot;&#x2F;&#x2F;tr[@class&#x3D;&#39;even&#39;]&quot;)for tr in trs: print(etree.tostring(tr,encoding&#x3D;&#39;utf-8&#39;).decode(&#39;utf-8&#39;)) \\4. 获取所有的a标签的href属性对应的值 123456789from lxml import etreeparser &#x3D; etree.HTMLParser(encoding&#x3D;&#39;utf-8&#39;)html &#x3D; etree.parse(&#39;tencent.html&#39;,parser)# 4.获取所的a标签的href属性对应的值aList &#x3D; html.xpath(&#39;&#x2F;&#x2F;a&#x2F;@href&#39;)for a in aList: print(&#39;https:&#x2F;&#x2F;hr.tencent.com&#x2F;&#39;+ a) \\5. 获取所有的职位信息（纯文本） 12345678910111213141516171819202122232425262728293031from lxml import etreeparser &#x3D; etree.HTMLParser(encoding&#x3D;&#39;utf-8&#39;)html &#x3D; etree.parse(&#39;tencent.html&#39;,parser)# 5.获取所有的职位信息（纯文本）trs &#x3D; html.xpath(&#39;&#x2F;&#x2F;tr[position()&gt;1]&#39;)positions &#x3D; []print(len(trs))for tr in trs: # 在某个标签下，再执行 xpath函数，获取这个标签下的子孙元素 # 那么应该在 &#x2F;&#x2F;之前加一个点，代表是在当前元素下获取 href &#x3D; tr.xpath(&#39;.&#x2F;&#x2F;a&#x2F;@href&#39;)[0] full_url &#x3D; &#39;https:&#x2F;&#x2F;hr.tencent.com&#39; + href title &#x3D; tr.xpath(&#39;.&#x2F;td[1]&#x2F;&#x2F;text()&#39;)[0] category &#x3D; tr.xpath(&#39;.&#x2F;td[2]&#x2F;text()&#39;)[0] nums &#x3D; tr.xpath(&quot;.&#x2F;td[3]&#x2F;text()&quot;)[0] address &#x3D; tr.xpath(&quot;.&#x2F;td[4]&#x2F;text()&quot;)[0] pubtime &#x3D; tr.xpath(&quot;.&#x2F;td[5]&#x2F;text()&quot;)[0] position &#x3D; &#123; &#39;url&#39;: full_url, &#39;title&#39;: title, &#39;category&#39;: category, &#39;nums&#39;: nums, &#39;address&#39;: address, &#39;pubtime&#39;: pubtime &#125; positions.append(position)print(positions) lxml结合xpath注意事项 使用xpath语法，应该使用Element.xpath方法，来执行xpath的选择。示例: 1trs &#x3D; html.path(&quot;&#x2F;&#x2F;tr[position() &gt; 1]&quot;) xpath函数返回是永远是一个列表。 获取某个标签的属性对应的值，示例： 1href &#x3D; html.xpath(&quot;&#x2F;&#x2F;a&#x2F;@href&quot;) 获取文本，是通过xpath中的text()函数，示例： 1address &#x3D; tr.xpath(&quot;.&#x2F;td[4]&#x2F;text()&quot;)[0] 在某个标签下，再执行xpath函数，获取这个标签下的子孙元素，那么应该在 //之前加一个点，代表是在当前元素下获取，示例： 1category &#x3D; tr.xpath(&#39;.&#x2F;td[2]&#x2F;text()&#39;)[0] 实战1：爬取豆瓣电影正在上映电影12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom lxml import etree# 1.将目标网站上的页面抓取下来headers&#x3D;&#123; &#39;User_Agent&#39;:&#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39;, &#39;Referer&#39;:&#39;https:&#x2F;&#x2F;movie.douban.com&#x2F;&#39;&#125;url &#x3D; &#39;https:&#x2F;&#x2F;movie.douban.com&#x2F;cinema&#x2F;nowplaying&#x2F;shanghai&#x2F;&#39;response &#x3D; requests.get(url,headers&#x3D;headers)text &#x3D; response.text# 返回一个经过解码后的字符串，是str(unicode)类型# response.text#返回的是一个原生的字符串，就是从网页上抓取下来的，没有经过处理的字符串，是bytes类型# response.content# 2.将抓取下来的数据根据一定的规则进行提取html &#x3D; etree.HTML(text)ul &#x3D; html.xpath(&#39;&#x2F;&#x2F;ul[@class&#x3D;&quot;lists&quot;]&#39;)[0]lis &#x3D; ul.xpath(&#39;.&#x2F;li&#39;)movies &#x3D; []for li in lis: title &#x3D; li.xpath(&quot;@data-title&quot;)[0] score &#x3D; li.xpath(&quot;@data-score&quot;)[0] duration &#x3D; li.xpath(&quot;@data-duration&quot;)[0] region &#x3D; li.xpath(&quot;@data-region&quot;)[0] director &#x3D; li.xpath(&quot;@data-director&quot;)[0] actors &#x3D; li.xpath(&quot;@data-actors&quot;)[0] thumbnail &#x3D; li.xpath(&quot;.&#x2F;&#x2F;img&#x2F;@src&quot;) movie &#x3D; &#123; &#39;title&#39;:title, &#39;score&#39;:score, &#39;duration&#39;:duration, &#39;region&#39;:region, &#39;director&#39;:director, &#39;actors&#39;:actors, &#39;thumbnail&#39;:thumbnail &#125; movies.append(movie)print(movies) 实战2：使用 requests 和 xpath 爬取电影天堂示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import requestsfrom lxml import etreeBASE_DOMAIN &#x3D; &#39;http:&#x2F;&#x2F;www.dytt8.net&#39;HEADERS &#x3D; &#123; &#39;User_Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39;, &#39;Referer&#39;: &#39;http:&#x2F;&#x2F;www.dytt8.net&#x2F;html&#x2F;gndy&#x2F;dyzz&#x2F;list_23_2.html&#39;&#125;def spider(): url &#x3D; &#39;http:&#x2F;&#x2F;www.dytt8.net&#x2F;html&#x2F;gndy&#x2F;dyzz&#x2F;list_23_1.html&#39; resp &#x3D; requests.get(url, headers&#x3D;HEADERS) # resp.content:经过编码后的字符串 # resp.text：没有经过编码，也就是Unicode字符串 # text：相当于是网页中的源代码了 text &#x3D; resp.content.decode(&#39;gbk&#39;) # tree：经过 lxml 解析后的一个对象，以后使用这个对象的xpath方法，就可以提取一些想要的数据了 tree &#x3D; etree.HTML(text) # xpath&#x2F;beautifulsoup4 all_a &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;co_content8&quot;]&#x2F;&#x2F;a&#39;) for a in all_a: title &#x3D; a.xpath(&quot;text()&quot;)[0] href &#x3D; a.xpath(&quot;@href&quot;)[0] if href.startswith(&#39;&#x2F;&#39;): detail_url &#x3D; BASE_DOMAIN + href crawl_detail(detail_url) breakdef crawl_detail(url): resp &#x3D; requests.get(url, headers&#x3D;HEADERS) text &#x3D; resp.content.decode(&#39;gbk&#39;) tree &#x3D; etree.HTML(text) create_time &#x3D; tree.xpath(&#39;&#x2F;&#x2F;div[@class&#x3D;&quot;co_content8&quot;]&#x2F;ul&#x2F;text()&#39;)[0].strip() imgs &#x3D; tree.xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;Zoom&#39;]&#x2F;&#x2F;img&#x2F;@src&quot;) # 电影海报 cover &#x3D; imgs[0] # 电影截图 screenshoot &#x3D; imgs[1] # 获取 span 标签下所有的文本 infos &#x3D; tree.xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;Zoom&#39;]&#x2F;&#x2F;text()&quot;) for index, info in enumerate(infos): if info.startswith(&quot;◎年 代&quot;): year &#x3D; info.replace(&quot;◎年 代&quot;, &quot;&quot;).strip() if info.startswith(&quot;◎豆瓣评分&quot;): douban_rating &#x3D; info.replace(&quot;◎豆瓣评分&quot;, &#39;&#39;).strip() print(douban_rating) if info.startswith(&quot;◎主 演&quot;): # 从当前位置，一直往下面遍历 actors &#x3D; [info] for x in range(index + 1, len(infos)): actor &#x3D; infos[x] if actor.startswith(&quot;◎&quot;): break actors.append(actor.strip()) print(&quot;,&quot;.join(actors))if __name__ &#x3D;&#x3D; &#39;__main__&#39;: spider() 实战2-2：爬取电影天堂多页数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100from lxml import etreeimport requestsBASE_DOMAIN &#x3D; &quot;http:&#x2F;&#x2F;dytt8.net&quot;HEADERS &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39;&#125;def get_detail_urls(url): response &#x3D; requests.get(url, headers&#x3D;HEADERS) # response.text # response.content # requests库，默认会使用自己猜测的编码方式将抓取下来的网页进行解码， # 然后存储到text 属性上去 # 在电影天堂的网页中，因为编码方式，requests库猜错了，所以就会产生乱码 text &#x3D; response.text html &#x3D; etree.HTML(text) detail_urls &#x3D; html.xpath(&#39;&#x2F;&#x2F;table[@class&#x3D;&quot;tbspan&quot;]&#x2F;&#x2F;a&#x2F;@href&#39;) detail_urls &#x3D; map(lambda url: BASE_DOMAIN + url, detail_urls) return detail_urlsdef parse_detail_page(url): movie &#x3D; &#123;&#125; response &#x3D; requests.get(url, headers&#x3D;HEADERS) text &#x3D; response.content.decode(&#39;gbk&#39;) html &#x3D; etree.HTML(text) title &#x3D; html.xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;title_all&#39;]&#x2F;&#x2F;font[@color&#x3D;&#39;#07519a&#39;]&#x2F;text()&quot;)[0] movie[&#39;title&#39;] &#x3D; title zoomE &#x3D; html.xpath(&quot;&#x2F;&#x2F;div[@id&#x3D;&#39;Zoom&#39;]&quot;)[0] images &#x3D; zoomE.xpath(&quot;&#x2F;&#x2F;img&#x2F;@src&quot;) cover &#x3D; images[0] screenShot &#x3D; images[1] movie[&#39;cover&#39;] &#x3D; cover movie[&#39;screenShot&#39;] &#x3D; screenShot def parse_info(info, rule): return info.replace(rule, &quot;&quot;).strip() infos &#x3D; zoomE.xpath(&quot;.&#x2F;&#x2F;text()&quot;) for index, info in enumerate(infos): # print(index) # print(info) # print(&#39;&#x3D;&#39;*30) if info.startswith(&quot;◎年 代&quot;): info &#x3D; parse_info(info, &quot;◎年 代&quot;) movie[&#39;year&#39;] &#x3D; info elif info.startswith(&quot;◎产 地&quot;): info &#x3D; parse_info(info, &quot;◎产 地&quot;) movie[&#39;country&#39;] &#x3D; info elif info.startswith(&quot;◎类 别&quot;): info &#x3D; parse_info(info, &quot;◎类 别&quot;) movie[&#39;category&#39;] &#x3D; info elif info.startswith(&quot;◎豆瓣评分&quot;): info &#x3D; parse_info(info, &quot;◎豆瓣评分&quot;) movie[&#39;douban_rating&#39;] &#x3D; info elif info.startswith(&quot;◎片 长&quot;): info &#x3D; parse_info(info, &quot;◎片 长&quot;) movie[&#39;duration&#39;] &#x3D; info elif info.startswith(&quot;◎导 演&quot;): info &#x3D; parse_info(info, &quot;◎导 演&quot;) movie[&#39;director&#39;] &#x3D; info elif info.startswith(&quot;◎主 演&quot;): info &#x3D; parse_info(info, &quot;◎主 演&quot;) actors &#x3D; [info] for x in range(index + 1, len(infos)): actor &#x3D; infos[x].strip() if actor.startswith(&quot;◎&quot;): break actors.append(actor) movie[&#39;actors&#39;] &#x3D; actors elif info.startswith(&quot;◎简 介&quot;): info &#x3D; parse_info(info, &quot;◎简 介&quot;) for x in range(index + 1, len(infos)): profile &#x3D; infos[x].strip() movie[&#39;profile&#39;] &#x3D; profile download_url &#x3D; html.xpath(&quot;&#x2F;&#x2F;td[@bgcolor&#x3D;&#39;#fdfddf&#39;]&#x2F;a&#x2F;@hvynyxkj&quot;) print(download_url) movie[&#39;download_url&#39;] &#x3D; download_url return moviedef spider(): base_url &#x3D; &#39;http:&#x2F;&#x2F;dytt8.net&#x2F;html&#x2F;gndy&#x2F;dyzz&#x2F;list_23_&#123;&#125;.html&#39; movies &#x3D; [] for x in range(1, 2): # 第一个for循环，是用来控制总共有7页 url &#x3D; base_url.format(x) detail_urls &#x3D; get_detail_urls(url) for detail_url in detail_urls: # 第2个for循环，是用来遍历一页中所有电影的详情url movie &#x3D; parse_detail_page(detail_url) movies.append(movie) # print(movies)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: spider() chrome相关问题在62版本（目前最新）中有一个bug，在页面302重定向的时候不能记录FormData数据。这是这个版本的一个bug。详细见以下链接：https://stackoverflow.com/questions/34015735/http-post-payload-not-visible-in-chrome-debugger%E3%80%82 在金丝雀版本中已经解决了这个问题，可以下载这个版本继续，链接如下：https://www.google.com/chrome/canary/ 作业：使用requests和xpath爬取腾讯招聘网信息。要求为获取每个职位的详情信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import requestsfrom lxml import etreeBASE_DOMAIN &#x3D; &#39;https:&#x2F;&#x2F;hr.tencent.com&#x2F;&#39;HEADERS &#x3D; &#123; &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39;, &#39;Referer&#39;:&#39;https:&#x2F;&#x2F;hr.tencent.com&#x2F;position.php?keywords&#x3D;python&amp;tid&#x3D;0&amp;lid&#x3D;2175&#39;, &#39;Cookie&#39;:&#39;pgv_pvi&#x3D;728765440; PHPSESSID&#x3D;te5ir3afl3u2rm5b182nl2m5d5; pgv_si&#x3D;s4690324480&#39;, &#39;Host&#39;:&#39;hr.tencent.com&#39;, &#39;Upgrade-Insecure-Requests&#39;:&#39;1&#39;&#125;def parse_detail_page(url): position &#x3D; &#123;&#125; response &#x3D; requests.get(url,headers&#x3D;HEADERS) html &#x3D; etree.HTML(response.text) title &#x3D; html.xpath(&quot;&#x2F;&#x2F;td[@id&#x3D;&#39;sharetitle&#39;]&#x2F;text()&quot;)[0] tds &#x3D; html.xpath(&quot;&#x2F;&#x2F;tr[@class&#x3D;&#39;c bottomline&#39;]&#x2F;td&quot;) address &#x3D; tds[0].xpath(&quot;.&#x2F;&#x2F;text()&quot;)[1] category &#x3D; tds[1].xpath(&quot;.&#x2F;&#x2F;text()&quot;)[1] nums &#x3D; tds[2].xpath(&quot;.&#x2F;&#x2F;text()&quot;)[1] more_infos &#x3D; html.xpath(&quot;&#x2F;&#x2F;ul[@class&#x3D;&#39;squareli&#39;]&quot;) duty &#x3D; more_infos[0].xpath(&quot;.&#x2F;&#x2F;text()&quot;) require &#x3D; more_infos[1].xpath(&quot;.&#x2F;&#x2F;text()&quot;) position[&#39;title&#39;] &#x3D; title position[&#39;address&#39;] &#x3D; address position[&#39;category&#39;] &#x3D; category position[&#39;nums&#39;] &#x3D; nums position[&#39;duty&#39;] &#x3D; duty position[&#39;require&#39;] &#x3D; require return positiondef get_detail_urls(url): response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;hr.tencent.com&#x2F;position.php?keywords&#x3D;python&amp;tid&#x3D;0&amp;start&#x3D;0#a&#39;,headers&#x3D;HEADERS) text &#x3D; response.text html &#x3D; etree.HTML(text) links &#x3D; html.xpath(&quot;&#x2F;&#x2F;tr[@class&#x3D;&#39;even&#39;]&#x2F;&#x2F;a&#x2F;@href&quot;) links &#x3D; map(lambda url:BASE_DOMAIN+url,links) return linksdef spider(): base_url &#x3D; &quot;https:&#x2F;&#x2F;hr.tencent.com&#x2F;position.php?keywords&#x3D;python&amp;tid&#x3D;0&amp;start&#x3D;&#123;&#125;#a&quot; positions &#x3D; [] for x in range(0,43): x *&#x3D; 10 url &#x3D; base_url.format(x) detail_urls &#x3D; get_detail_urls(url) for detail_url in detail_urls: position &#x3D; parse_detail_page(detail_url) positions.append(position) print(position) # print(positions)if __name__ &#x3D;&#x3D; &#39;__main__&#39;: spider()","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"一、网络请求(3)——requests库","slug":"一、网络请求-3-——requests库","date":"2020-02-13T13:37:17.000Z","updated":"2020-02-13T16:07:12.803Z","comments":true,"path":"2020/02/13/一、网络请求-3-——requests库/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-3-%E2%80%94%E2%80%94requests%E5%BA%93/","excerpt":"requests库","text":"requests库 虽然 Python 的标准库中，urllib 模块已经包含了平常我们使用的大多数功能，但是它的 API 使用起来让人感觉不太好，而 Requests 宣传的是 “HTTP for Humans”，说明使用更简洁方便。 安装和文档地址利用pip可以非常方便的安装： 1pip install requests 中文文档：http://docs.python-requests.org/zh_CN/latest/index.html github地址：https://github.com/requests/requests 发送GET请求\\1. 最简单的发送get请求就是通过 requests.get 来调用: 1response &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;) \\2. 添加 headers和查询参数： 如果想添加 headers，可以传入 headers 参数来增加请求头中的 headers信息。如果要将参数放在url 中传递，可以利用 params 参数。相关示例代码如下： 1234567891011121314151617181920212223import requestskw &#x3D; &#123;&#39;wd&#39;:&#39;中国&#39;&#125;headers &#x3D; &#123;&quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&quot;&#125;# params 接收一个字典或者字符串的查询参数，字典类型自动转换为url编码，不需要urlencode()response &#x3D; requests.get(&quot;http:&#x2F;&#x2F;www.baidu.com&#x2F;s&quot;,params&#x3D;kw,headers&#x3D;headers)# 查看响应内容，response.text 返回的是Unicode格式的数据print(response.text)#查看响应内容，response.content 返回的是字节流数据print(response.content)# 查看完整url地址print(response.url)# 查看响应头部字符编码print(response.encoding)# 查看响应码print(response.status_code) response.text和response.content的区别 \\1. response.content：这个是直接从网络上面抓取的数据，没有经过任何解码。所以是一个bytes类型。其实在硬盘上和在网络上传输的客符串都是bytes类型。 \\2. response.text：这个是str的数据类型，是requests库将response.content进行解码的字符串。解码需要指定 一个编码方式，requests会根据自己的猜测来判断编码的方式，所以有时候可能会猜测错误，就会导致解码产生乱码。这时候就应试使用response.content.decode(&#39;utf-8&#39;)进行手动解码。 发送POST请求\\1. 最基本的POST请求可以使用requests.post方法： 1response &#x3D; requests.post(&quot;http:&#x2F;&#x2F;www.baidu.com&quot;,data&#x3D;data) \\2. 传入data数据： 这时候就不要再使用urlencode进行编码了，直接传入一个字典进去就可以了。如果返回的是json数据，那么就可以调用response.json()来将json字符串转换为字典或者列表。比如请求拉勾网的数据的代码： 123456789101112131415161718import requestsdata &#x3D; &#123; &#39;first&#39;: &#39;true&#39;, # 是不是第一页，false表示不是，true 表示是 &#39;kd&#39;: &#39;Python&#39;, # 搜索关键字 &#39;pn&#39;: 1 # 页码&#125;headers &#x3D; &#123; &#39;Accept&#39;: &#39;application&#x2F;json, text&#x2F;javascript, *&#x2F;*; q&#x3D;0.01&#39;, &#39;Referer&#39;: &#39;https:&#x2F;&#x2F;www.lagou.com&#x2F;jobs&#x2F;list_Android?px&#x3D;default&amp;city&#x3D;%E6%B7%B1%E5%9C%B3&#39;, &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39;,&#125;url &#x3D; &#39;https:&#x2F;&#x2F;www.lagou.com&#x2F;jobs&#x2F;positionAjax.json?px&#x3D;default&amp;city&#x3D;%E6%B7%B1%E5%9C%B3&amp;needAddtionalResult&#x3D;false&#39;response &#x3D; requests.post(url&#x3D;url, data&#x3D;data, headers&#x3D;headers)print(type(response.json()))# 如果是json数据，直接可以调用json方法print(response.json()) 使用代理使用requests添加代理也非常简单，只要在请求的方法中（比如get或者post）传递proxies参数就可以了。示例代码如下： 123456789import requestsurl &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;ip&#39;proxy &#x3D; &#123; &#39;http&#39;:&#39;123.59.232.123:80&#39;&#125;resp &#x3D; requests.get(url,proxies&#x3D;proxy)print(resp.text) Cookie如果在一个响应中包含了cookie，那么可以利用cookies属性拿到这个返回的cookie值： 12345import requestsresp &#x3D; requests.get(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;)print(resp.cookies)print(resp.cookies.get_dict()) Session之前使用urllib库，是可以使用opener发送多个请求，多个请求之间是可以共享 cookie 的。那么如果使用 requests，也要达到共享cookie的目的，那么可以使用 requests库给我们提供的session对象。注意，这里的session不是web开发中的那个session，这个地方只是一个会话的对象而已。还是以登录人人网为例，使用requests来实现。示例代码如下： 1234567891011121314import requestsurl &#x3D; &quot;http:&#x2F;&#x2F;www.renren.com&#x2F;PLogin.do&quot;data &#x3D; &#123;&quot;email&quot;:&quot;renjy185911222@126.com&quot;,&#39;password&#39;:&#39;caonima001&#39;&#125;headers&#x3D;&#123; &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39;&#125;session &#x3D; requests.Session()# 登录session.post(url,data&#x3D;data,headers&#x3D;headers)response &#x3D; session.get(&#39;http:&#x2F;&#x2F;www.renren.com&#x2F;880151247&#x2F;profile&#39;)with open(&#39;renren.html&#39;,&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;) as fp: fp.write(response.text) 处理不信任的ssl证书对于那些已经被信任的SSL整数的网站，比如http://www.baidu.com,那么使用requests直接就可以正常的返回响应。示例代码如下： 12resp &#x3D; requests.get(&#39;https:&#x2F;&#x2F;www.12306.cn&#x2F;index&#x2F;&#39;,verify&#x3D;False)print(resp.content.decode(&#39;utf-8&#39;))","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"一、网络请求(2)——urllib库","slug":"一、网络请求-2-——urllib库","date":"2020-02-13T13:26:23.000Z","updated":"2020-02-13T16:07:33.839Z","comments":true,"path":"2020/02/13/一、网络请求-2-——urllib库/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-2-%E2%80%94%E2%80%94urllib%E5%BA%93/","excerpt":"urllib库","text":"urllib库 urllib 库是 Python中一个最基本的网络请求库。可以模拟浏览器的行为，向指定的服务器发送一个请求，并可以保存服务器返回的数据。 urlopen函数在Python3的 urllib 库中，所有和网络请求相关的方法，都被集中到 urllib.request 模块下面了，先来看下 urlopen 函数基本的使用： 123from urllib import requestresp &#x3D; request.urlopen(&#39;http:&#x2F;&#x2F;www.baidu.com&#39;)print(resp.read()) 实际上，使用浏览器访问百度，右键查看源代码。你会发现，跟我们刚才打印出来的数据是一模一样的，也就是说，上面的三行代码就已经帮我们把百度的首页的全部代码爬下来了。一个基本的url请求对应的python代码真的非常简单。 以下对 urlopen 函数进行详细讲解： url：请求的url data：请求的data，如果设置了这个值，那么将变成post 请求。 返回值：返回值是一个 http.client.HTTPResponse 对象，这个对象是一个类文件句柄对象。 方法： read(size)：读取多少字节数，如果为空，默认读取所有 readline()：读取一行数据 readlines()：读取多行数据 getcode()：获取返回的状态码 urlretrieve函数这个函数可以方便的将网页上的一个文件保存到本地。以下代码可以非常方便的将百度的首页下载到本地： 12from urllib import requestrequest.urlretrieve(&#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;baidu.html&#39;) urlencode函数用浏览器发送请求的时候，如果 url 中包含了中文或者其他特殊字符，那么浏览器会自动的给我们进行编码。而如果使用代码发送请求，那么就必须手动的进行编码，这时候就应该使用 urlencode 函数来实现。 urlencode 可以把字典数据转换为 URL 编码的数据。示例代码如下： 1234from urllib import parsedata &#x3D; &#123;&#39;name&#39;:&#39;爬虫基础&#39;,&#39;greet&#39;:&#39;hello world&#39;,&#39;age&#39;:100&#125;qs &#x3D; parse.urlencode(data)print(qs) parse_qs函数可以将经过编码后的url参数进行解码。示例代码如下： 123from urllib import parseqs &#x3D; &quot;name&#x3D;%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80&amp;greet&#x3D;hello+world&amp;age&#x3D;100&quot;print(parse.parse_qs(qs)) urlparse和urlsplit有时候拿到一个url，想要对这个url中的各个组成部分进行分割，那么这时候就可以使用 urlparse 或者是 urlsplit 来进行分割。示例代码如下： 123456789101112from urllib import parseurl &#x3D; &#39;http:&#x2F;&#x2F;www.baidu.com&#x2F;s?wd&#x3D;python&amp;username&#x3D;abc#1&#39;result &#x3D; parse.urlsplit(url) # 没有params# result &#x3D; parse.urlparse(url) # 有paramsprint(&#39;scheme:&#39;,result.scheme)print(&#39;netloc:&#39;,result.netloc)print(&#39;path:&#39;,result.path)print(&#39;params:&#39;,result.params)print(&#39;query:&#39;,result.query)print(&#39;fragment:&#39;,result.fragment) urlparse和urlsplit基本上是一模一样的。唯一不一样的地方是，urlparse里面多了一个params属性，而urlsplit没有这个params属性。比如有一个url为：url = &#39;http://www.baidu.com/s;hello?wd=python&amp;username=abc#1&#39;，那么urlparse可以获取到hello，而urlsplit不可以获取到。url中的params也用得比较少。 request.Request类如果想要在请求的时候增加一些请求头，那以就必须使用request.Request类来实现。比如要增加一个User-Agent，示例代码如下： 1234567891011121314151617from urllib import request,parseurl &#x3D; &#39;https:&#x2F;&#x2F;www.lagou.com&#x2F;jobs&#x2F;positionAjax.json?px&#x3D;default&amp;city&#x3D;%E4%B8%8A%E6%B5%B7&amp;needAddtionalResult&#x3D;false&#39;headers &#x3D; &#123; &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39;, &#39;Referer&#39;:&#39;https:&#x2F;&#x2F;www.lagou.com&#x2F;jobs&#x2F;list_python?px&#x3D;default&amp;city&#x3D;%E4%B8%8A%E6%B5%B7&#39;,&#125;data&#x3D;&#123; &#39;first&#39;:&#39;true&#39;, &#39;pn&#39;:1, &#39;kd&#39;:&#39;python&#39;&#125;req &#x3D; request.Request(url,headers&#x3D;headers,data&#x3D;parse.urlencode(data).encode(&#39;utf-8&#39;),method&#x3D;&#39;POST&#39;)resp &#x3D; request.urlopen(req)print(resp.read().decode(&#39;utf-8&#39;)) 内涵段子爬虫实战作业 url链接：http://neihanshequ.com/bar/1 要求：能爬取一页的数据就可以了 ProxyHandler处理器（代理设置）很多网站会检测某一段时间某个IP的访问次数（通过流量统计，系统日志等），如果访问次数多的不象正常人，它会禁止这个IP的访问。所以我们可以设置一些代理服务器，每隔一段时间换一个代理，就算IP被禁止，依然可以换个IP继续爬取。 代理的原理：在请求目的网站之前，先请求代理服务器，然后让代理服务器去请求目的网站 ，代理服务器拿到目的网站的数据后，再转发给我们的代码。 http://httpbin.org： 这个网站可以方便的查看http请求的一些参数 在代码中使用代理： 使用urllib.request.ProxyHandler，传入一个代理，这个代理是一个字典，字典的key依赖于代理服务器能够接收的类型，一般是http或者https,值是ip:port。 使用上一步创建的handler，以及request.build_opener创建一个opener对象。 使用上一步创建的opener，调用open函数，发起请求。 urllib 中通过ProxyHandler来设置使用代理服务器，下面代码说明如何使用自定义opener来使用代理： 123456789101112131415from urllib import request# 这个是没有使用代理的# resp &#x3D; request.urlopen(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;)# print(resp.read().decode(&#39;utf-8&#39;))# 这个是使用了代理的url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;ip&#39;# 1.使用 ProxyHandler 传入代理构建一个 handlerhandler &#x3D; request.ProxyHandler(&#123;&#39;http&#39;:&#39;118.122.114.236:9000&#39;&#125;)# 2. 使用上面创建的 handler 构建一个 openeropener &#x3D; request.build_opener(handler)# 3. 使用 opener 去发送一个请求resp &#x3D; opener.open(url)print(resp.read()) 常用的代理有： 西制免费代理IP：http://www.xicidaili.com 快代理：http://www.kuaidaili.com 代理云：http://www.dailiyun.com 什么是cookie？在网站中，http请求是无状态的，也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。cookie的出现就是为了解决这个问题，第一次登录后服务器返回一些数据(cookie)给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。 cookie的格式1Set-Cookie:NAME&#x3D;VALUE;Expires&#x2F;Max-age&#x3D;DATE;Path&#x3D;PATH;Domain&#x3D;DOMAIN_NAME;SECURE 参数意义： NAME：cookie的名字 VALUE：cookie的值 Expires：cookie的过期时间 Path：cookie作用的路径 Domain：cookie作用的域名 SECURE：是否只在https协议下起作用。 使用cookielib库和HTTPCookieProcessor模拟登录Cookie是指网站服务器为了辨别用户身份和进行Session跟踪，而储存在用户浏览器上的文本文件，Cookie可以保持登录信息到用户下次与服务器的会话。 这里以人人网为例，人人网中，要访问某个人的主页，必须先登录才能访问，登录说白了就是要有cookie的信息。那么如果我们想要用代码的方式访问，就必须要有正确的cookie信息才能访问。解决方案有两种，第一种是使用浏览器访问，然后将cookie信息复制下来，放到headers中。示例代码如下： 12345678910111213141516171819from urllib import request# 大鹏董成鹏主页：http:&#x2F;&#x2F;www.renren.com&#x2F;880151247&#x2F;profile# 人人网登录url：http:&#x2F;&#x2F;www.renren.com&#x2F;PLogin.do#1.不使用 cookie 去请求大鹏的主页dapeng_url &#x3D; &quot;http:&#x2F;&#x2F;www.renren.com&#x2F;880151247&#x2F;profile&quot;headers &#x3D; &#123; &#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39;, &#39;Cookie&#39;:&#39;anonymid&#x3D;jt75deea1mav2z; depovince&#x3D;SH; jebecookies&#x3D;842f59db-ac85-4ccf-bc5d-89e0ed90c533|||||; _r01_&#x3D;1; JSESSIONID&#x3D;abcCVukf0adNo_gT752Lw; ick_login&#x3D;83dc3768-6560-49e1-9f60-89750c9c0708; _de&#x3D;020D07FA7C972D7F9693B941A6D5CC6732E0B9ADC37B4602; p&#x3D;d1afe6d3669e2b81f53082455819c0d45; first_login_flag&#x3D;1; ln_uact&#x3D;renjy185911222@126.com; ln_hurl&#x3D;http:&#x2F;&#x2F;hd60.xiaonei.com&#x2F;photos&#x2F;hd60&#x2F;20071127&#x2F;16&#x2F;52&#x2F;main_3012f107.jpg; t&#x3D;e3d3d615ccd5c73c8160234d70b7f9505; societyguester&#x3D;e3d3d615ccd5c73c8160234d70b7f9505; id&#x3D;236210555; xnsid&#x3D;8917e94c; loginfrom&#x3D;syshome; wp_fold&#x3D;0&#39;&#125;req &#x3D; request.Request(url&#x3D;dapeng_url,headers&#x3D;headers)resp &#x3D; request.urlopen(req)with open(&#39;renren.html&#39;,&#39;w&#39;,encoding&#x3D;&#39;utf-8&#39;) as fp: # write函数必须写入一个str的数据类型 # resp.read()读出来的是一个bytes数据类型 # bytes -&gt;decode -&gt; str # str -&gt; encode -&gt; bytes fp.write(resp.read().decode(&quot;utf-8&quot;)) 但是每次在访问需要cookie的页面都要从浏览器中复制cookie比较麻烦。在Python处理Cookie，一般是通过http.cookiejar模块和urllib模块的HTTPCookieProcessor处理器类一起使用。http.cookiejar模块主要作用是提供用于存储 cookie 的对象。而 HTTPCookieProcessor处理器主要作用是处理这些 cookie 对象，并构建 handler 对象。 http.cookiejar模块该模块主要的类有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。这四个类的作用分别如下： CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie，向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失。 FileCookieJar(filename，delayload=None;policy=None)：从CookieJar派生而来，用来创建FileCookieJar实例，检索cookie信息并将cookie存储到文件中。filename是存储 cookie的文件名。delayload为True时支持延迟访问文件，即只有在需要时才读取文件或在文件中存储数据。 MozillaCookieJar(filename，delayload=None;policy=None)：从CookieJar派生而来，创建与Mozilla浏览器 cookies.txt 兼容的 FileCookieJar 实例。 LWPCookieJar(filename，delayload=None;policy=None)：从CookieJar派生而来，创建与libwww-per标准的 Set-Cookie3文件格式兼容的 FileCookieJar 实例。 利用 http.cookiejar 和 request.HTTPCookieProcessor 登录人人网。相关示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from urllib import request, parsefrom http.cookiejar import CookieJarheaders &#x3D; &#123; &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;72.0.3626.121 Safari&#x2F;537.36&#39;&#125;def get_opener(): # 1. 登录 # 1.1 创建一个cookiejar对象 cookiejar &#x3D; CookieJar() # 1.2 使用 cookiejar 创建一个 HTTPCookieProcessor对象 handler &#x3D; request.HTTPCookieProcessor(cookiejar) # 1.3 使用上一步创建的handler创建一个opener opener &#x3D; request.build_opener(handler) return openerdef login_renren(opener): # 1.4 使用 opener发送登录的请求（人人网的邮箱和密码） data &#x3D; &#123; &#39;email&#39;: &#39;renjy185911222@126.com&#39;, &#39;password&#39;: &#39;caonima001&#39; &#125; login_url &#x3D; &quot;http:&#x2F;&#x2F;www.renren.com&#x2F;PLogin.do&quot; req &#x3D; request.Request(login_url, data&#x3D;parse.urlencode(data).encode(&#39;utf-8&#39;), headers&#x3D;headers) opener.open(req)def visit_profile(opener): # 2.访问个人主页 dapeng_url &#x3D; &quot;http:&#x2F;&#x2F;www.renren.com&#x2F;880151247&#x2F;profile&quot; # 获取个人主页的页面的时候，不要新建一个opener # 而应该使用之前的那个opener，因为之前的那个opener已经包含了登录所需要的cookie信息 req &#x3D; request.Request(dapeng_url, headers&#x3D;headers) resp &#x3D; opener.open(req) with open(&#39;renren.html&#39;, &#39;w&#39;, encoding&#x3D;&#39;utf-8&#39;) as fp: fp.write(resp.read().decode(&#39;utf-8&#39;))if __name__ &#x3D;&#x3D; &#39;__main__&#39;: opener &#x3D; get_opener() login_renren(opener) visit_profile(opener) 保存cookie到本地保存cookie到本地，可以使用cookiejar的save方法，并且需要指定一个文件名： 1234567891011from urllib import requestfrom http.cookiejar import MozillaCookieJar# 保存cookie到本地cookiejar &#x3D; MozillaCookieJar(&#39;cookie.txt&#39;)handler &#x3D; request.HTTPCookieProcessor(cookiejar)opener &#x3D; request.build_opener(handler)resp &#x3D; opener.open(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;)cookiejar.save(ignore_discard&#x3D;True) 从本地加载cookie从本地加载cookie，需要使用cookiejar的load方法，并且也需要指定方法： 1234567891011121314from urllib import requestfrom http.cookiejar import MozillaCookieJar# 保存cookie到本地cookiejar &#x3D; MozillaCookieJar(&#39;cookie.txt&#39;)cookiejar.load(ignore_discard&#x3D;True)handler &#x3D; request.HTTPCookieProcessor(cookiejar)opener &#x3D; request.build_opener(handler)resp &#x3D; opener.open(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;)for cookie in cookiejar: print(cookie)# cookiejar.save(ignore_discard&#x3D;True)","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"一、网络请求(1)——爬虫前奏","slug":"一、网络请求-1-——爬虫前奏","date":"2020-02-13T13:23:58.000Z","updated":"2020-02-13T16:07:49.255Z","comments":true,"path":"2020/02/13/一、网络请求-1-——爬虫前奏/","link":"","permalink":"http://yoursite.com/2020/02/13/%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82-1-%E2%80%94%E2%80%94%E7%88%AC%E8%99%AB%E5%89%8D%E5%A5%8F/","excerpt":"1. 爬虫前奏","text":"1. 爬虫前奏 爬虫的实际例子： 搜索引擎（百度、谷歌、360搜索等）。 伯乐在线 惠惠购物助手 数据分析与研究（数据冰山知乎专栏） 抢票软件等 什么是网络爬虫？ 通俗理解：爬虫是一个模拟人类请求网络行为的程序。可以自动请求网页，并将数据抓取下来，然后使用一定的规则提取有价值的数据。 专业介绍：百度百科 通用爬虫和聚焦爬虫 通用爬虫：通用爬虫是搜索引擎抓取系统（百度、谷歌、搜狗等）的重要组成部分。主要是将互联网上的网页下载到本地，形成一个互联网内容的镜像备份。 聚焦爬虫：是面向特定需求的一种网络爬虫程序，他与通用爬虫的区虽在于：聚焦爬虫在实施网页抓取时候会对内容进行筛选和处理，尽量保证只抓取与需求相关的网页信息。 为什么用Python写爬虫程序？ PHP：PHP是世界最好的语言，但他天生不是做这个的，而且对多线程、异步支持不是很好，并发处理能力弱。爬虫是工具生程序，对速度和效率要求比较高。 Java：生态圈很完善，是Python爬虫最大的竞争对手。但是Java语言本身很笨重，代码量很大。重构成本比较高，任何修改都会导致代码大量改动，而爬虫经常要修改采集代码。 C/C++：运行效率是无敌的。但是学习和开发成本高。写个小爬虫程序要大半天时间。 Python：语法优美、代码简洁、开发效率高、支持的模块多。相关的HTTP请求模块和HTML解析模块非常丰富。还有Scrapy和Scrapy-redis框架让我们开发爬虫变得异常简单。 准备工具 Python3.6开发环境 Pycharm 2017 professional版 虚拟环境 virtualenv/virtualenvwrapper 2. http协议和Chrome抓包工具什么是http和https协议：HTTP协议：全称是 HyperText Transfer Protocol，中文意是超文本传输协议，是一种发布和接收HTML页面的方法。服务端口号是 80 端口。 HTTPS协议：是HTTP协议的加密版本，在HTTP下加入了SSL层。服务器端口号是 443 端口。 在浏览器中发送一个http请求的过程 当用户在浏览器的地址栏中输入一个URL并按回车键之后，浏览器会向HTTP服务器发送HTTP请求。HTTP请求主要分为“Get”和“Post”两种方法。 当我们在浏览器输入URL http://www.baidu.com 的时候，浏览器发送一个Request请求去获取 http://www.baidu.com的html文件，服务器把Response文件对象发送回给浏览器。 浏览器分析Response中的HTML，发现其中引用了很多其他文件，比如image文件，CSS文件，JS文件。浏览器会自动再次发送Request去获取图片，CSS文件或者JS文件。 当所有的文件都下载成功后，网页会根据HTML语法结构，完整的显示出来了。 url详解URL 是 Uniform Resource Locator 的简写，统一资源定位符。 一个 URL 由以下几部分组成： 1scheme:&#x2F;&#x2F;host:port&#x2F;path?query-string&#x3D;xxx&amp;anchor scheme: 代表的是访问的协议，一般为 http 或者 https 以及 ftp等。 host：主机名，域名，比如 www.baidu.com。 post：端口号。当你访问一个网站的时候，浏览器默认使用80端口。 path：查找路径。比如： www.jianshu.com/trending/now， 后面的 trending/now就是 Path。 query-string：查询字符串，比如：www.baidu.com/s?wd=python，后面的wd=python就是查询字符串。 anchor：锚点，后台一般不用管，前端用来做页面定位的。 在浏览器中请求一个url，浏览器会对这个url进行一个编码。除英文字母，数字和部分符号外，其他的全部使用百分号+十六进制码值是行编码。 常用的请求方法：在Http协议中，定义了八种请求方法。这里介绍两种常用的请求方法，分别是get和post请求。 get请求：一般情况下，只从服务器获取数据下来，并不会对服务器资源产生任何影响的时候会使用get请求。 post请求：向服务器发送数据（登录）、上传文件等，会对服务器资源产生影响的时候会使用post请求。 以上是在网站开发中常用的两种方法。并且一般情况下都会遵循使用的原则。但是有的网站和服务器为了做反爬虫机制，也经常会不按常理出牌，有可能一个应该使用get方法的请求就一定要改成post请求，这个要视情况而定。 请求头常见参数：在http协议中，向服务器发送一个请求，数据分为三部分，第一个是把数据放在url中，第二个是把数据话在body中（在post请求中），第三个就是把数据放在head中。这里介绍在网络爬虫中经常会使用到的一些请求头参数： User-Agent：浏览器名称。这个在网络爬虫中经常会被使用到。请求一个网页的时候，服务器通过这个参数就可以知道这个请求是由哪种浏览器发送的。如果我们是通过爬虫发送请求，那么我们的User-Agent就是Python，这对于那些有反爬虫机制的网站来说，可以轻易的判断你这个请求是爬虫。因此我们要经常设置这个值为一些浏览器的值，来伪装我们的爬虫。 Referer：表明当前这个请求是从哪个url过来。这个一般也可以用来做反爬虫技术。如果不是从指定页面过来的，那么就不做相关的响应。 Cookie：http协议是无状态的。也就是同一个人发送了两次请求，服务器没有能力知道这两个请求是否来自同一个人。因此这个时候就用 cookie 来标识。一般如果想要做登录后才能访问的网站，那么就需要发送 cookie 信息了。 常见响应状态码： 200：请求正常，服务器正常的返回数据。 301：永久重定向。比如在访问 www.jingdong.com 的时候会重定向到 www.jd.com 302：临时重定向。比如在访问一个需要登录的页面的时候，而此时没有登录，那么就会重定向到登录页面。 400：请求的url在服务器上找不到。换句话说就是请求url错误 403：服务器拒绝访问，权限不够 500：服务器内部错误，可能是服务器出现 bug 了。 Chrome抓包工具：Chrome浏览器是一个非常亲近工发者的浏览器。可以方便的查看网络请求以及发送的参数。对着网页 右键-&gt;检查 ，然后就可以打开开发者选项。 Elements：源代码 Console：控制台 Sources：文件 Network：网络","categories":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"网络爬虫","slug":"网络爬虫","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"}]},{"title":"13-tcp-ip简介","slug":"13-tcp-ip简介","date":"2020-02-10T09:27:11.000Z","updated":"2020-02-10T09:34:29.127Z","comments":true,"path":"2020/02/10/13-tcp-ip简介/","link":"","permalink":"http://yoursite.com/2020/02/10/13-tcp-ip%E7%AE%80%E4%BB%8B/","excerpt":"tcp-ip简介","text":"tcp-ip简介 作为新时代标杆的我们，已经离不开手机、离不开网络，对于互联网大家可能耳熟能详，但是计算机网络的出现比互联网要早很多 1. 什么是协议有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了 为了解决不同种族人之间的语言沟通障碍，现规定国际通用语言是英语，这就是一个规定，这就是协议 2. 计算机网络沟通用什么现在的生活中，不同的计算机只需要能够联网（有线无线都可以）那么就可以相互进行传递数据 那么不同种类之间的计算机到底是怎么进行数据传递的呢？ 就像说不同语言的人沟通一样，只要有一种大家都认可都遵守的协议即可，那么这个计算机都遵守的网络通信协议叫做TCP/IP协议 3. TCP/IP协议(族)早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容 为了把全世界的所有不同类型的计算机都连接起来，就必须规定一套全球通用的协议，为了实现互联网这个目标，互联网协议族（Internet Protocol Suite）就是通用协议标准。 因为互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP/IP协议(族) 常用的网络协议如下图所示： 说明： 12网际层也称为：网络层网络接口层也称为：链路层 另外一套标准","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"12-TCP握手","slug":"12-TCP握手","date":"2020-02-10T09:22:27.000Z","updated":"2020-02-10T09:34:18.850Z","comments":true,"path":"2020/02/10/12-TCP握手/","link":"","permalink":"http://yoursite.com/2020/02/10/12-TCP%E6%8F%A1%E6%89%8B/","excerpt":"tcp的3次握手","text":"tcp的3次握手 tcp的4次挥手 tcp长连接和短连接TCP在真正的读写操作之前，server与client之间必须建立一个连接， 当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接， 连接的建立通过三次握手，释放则需要四次握手， 所以说每个连接的建立都是需要资源消耗和时间消耗的。 TCP通信的整个过程，如下图: 1. TCP短连接模拟一种TCP短连接的情况: client 向server 发起连接请求 server 接到请求，双方建立连接 client 向server 发送消息 server 回应client 一次读写完成，此时双方任何一个都可以发起close 操作 在步骤5中，一般都是client 先发起close 操作。当然也不排除有特殊的情况。 从上面的描述看，短连接一般只会在client/server 间传递一次读写操作！ 2. TCP长连接再模拟一种长连接的情况: client 向server 发起连接 server 接到请求，双方建立连接 client 向server 发送消息 server 回应client 一次读写完成，连接不关闭 后续读写操作… 长时间操作之后client发起关闭请求 3. TCP长/短连接操作过程3.1 短连接的操作步骤是：建立连接——数据传输——关闭连接…建立连接——数据传输——关闭连接 3.2 长连接的操作步骤是：建立连接——数据传输…（保持连接）…数据传输——关闭连接 4. TCP长/短连接的优点和缺点 长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。 对于频繁请求资源的客户来说，较适用长连接。 client与server之间的连接如果一直不关闭的话，会存在一个问题， 随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略， 如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损； 如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数， 这样可以完全避免某个蛋疼的客户端连累后端服务。 短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。 但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。 5. TCP长/短连接的应用场景 长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。 每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接， 再操作的话那么处理速度会降低很多，所以每个操作完后都不断开， 再次处理时直接发送数据包就OK了，不用建立TCP连接。 例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误， 而且频繁的socket 创建也是对资源的浪费。 而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源， 而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源， 如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话， 那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"11-案例:文件下载器","slug":"11-案例-文件下载器","date":"2020-02-10T09:21:02.000Z","updated":"2020-02-10T09:34:09.488Z","comments":true,"path":"2020/02/10/11-案例-文件下载器/","link":"","permalink":"http://yoursite.com/2020/02/10/11-%E6%A1%88%E4%BE%8B-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%99%A8/","excerpt":"案例:文件下载器","text":"案例:文件下载器 服务器参考代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from socket import *import sysdef get_file_content(file_name): \"\"\"获取文件的内容\"\"\" try: with open(file_name, \"rb\") as f: content = f.read() return content except: print(\"没有下载的文件:%s\" % file_name)def main(): if len(sys.argv) != 2: print(\"请按照如下方式运行：python3 xxx.py 7890\") return else: # 运行方式为python3 xxx.py 7890 port = int(sys.argv[1]) # 创建socket tcp_server_socket = socket(AF_INET, SOCK_STREAM) # 本地信息 address = ('', port) # 绑定本地信息 tcp_server_socket.bind(address) # 将主动套接字变为被动套接字 tcp_server_socket.listen(128) while True: # 等待客户端的链接，即为这个客户端发送文件 client_socket, clientAddr = tcp_server_socket.accept() # 接收对方发送过来的数据 recv_data = client_socket.recv(1024) # 接收1024个字节 file_name = recv_data.decode(\"utf-8\") print(\"对方请求下载的文件名为:%s\" % file_name) file_content = get_file_content(file_name) # 发送文件的数据给客户端 # 因为获取打开文件时是以rb方式打开，所以file_content中的数据已经是二进制的格式，因此不需要encode编码 if file_content: client_socket.send(file_content) # 关闭这个套接字 client_socket.close() # 关闭监听套接字 tcp_server_socket.close()if __name__ == \"__main__\": main() 客户端参考代码如下:1234567891011121314151617181920212223242526272829303132333435from socket import *def main(): # 创建socket tcp_client_socket = socket(AF_INET, SOCK_STREAM) # 目的信息 server_ip = input(\"请输入服务器ip:\") server_port = int(input(\"请输入服务器port:\")) # 链接服务器 tcp_client_socket.connect((server_ip, server_port)) # 输入需要下载的文件名 file_name = input(\"请输入要下载的文件名：\") # 发送文件下载请求 tcp_client_socket.send(file_name.encode(\"utf-8\")) # 接收对方发送过来的数据，最大接收1024个字节（1K） recv_data = tcp_client_socket.recv(1024) # print('接收到的数据为:', recv_data.decode('utf-8')) # 如果接收到数据再创建文件，否则不创建 if recv_data: with open(\"[接收]\"+file_name, \"wb\") as f: f.write(recv_data) # 关闭套接字 tcp_client_socket.close()if __name__ == \"__main__\": main()","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"10-TCP客户端和服务器","slug":"10-TCP客户端和服务器","date":"2020-02-10T09:17:10.000Z","updated":"2020-02-10T09:33:58.243Z","comments":true,"path":"2020/02/10/10-TCP客户端和服务器/","link":"","permalink":"http://yoursite.com/2020/02/10/10-TCP%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"tcp客户端","text":"tcp客户端 tcp客户端，并不是像之前一个段子：一个顾客去饭馆吃饭，这个顾客要点菜，就问服务员咱们饭店有客户端么，然后这个服务员非常客气的说道：先生我们饭店不用客户端，我们直接送到您的餐桌上 如果，不学习网络的知识是不是说不定也会发生那样的笑话，哈哈 所谓的服务器端：就是提供服务的一方，而客户端，就是需要被服务的一方 tcp客户端构建流程tcp的客户端要比服务器端简单很多，如果说服务器端是需要自己买手机、查手机卡、设置铃声、等待别人打电话流程的话，那么客户端就只需要找一个电话亭，拿起电话拨打即可，流程要少很多 示例代码： 1234567891011121314151617181920212223from socket import *# 创建sockettcp_client_socket = socket(AF_INET, SOCK_STREAM)# 目的信息server_ip = input(\"请输入服务器ip:\")server_port = int(input(\"请输入服务器port:\"))# 链接服务器tcp_client_socket.connect((server_ip, server_port))# 提示用户输入数据send_data = input(\"请输入要发送的数据：\")tcp_client_socket.send(send_data.encode(\"gbk\"))# 接收对方发送过来的数据，最大接收1024个字节recvData = tcp_client_socket.recv(1024)print('接收到的数据为:', recvData.decode('gbk'))# 关闭套接字tcp_client_socket.close() 运行流程：&lt;1&gt;tcp客户端1234请输入服务器ip:10.10.0.47请输入服务器port:8080请输入要发送的数据：你好啊接收到的数据为: 我很好，你呢 &lt;2&gt;网络调试助手： tcp服务器生活中的电话机如果想让别人能更够打通咱们的电话获取相应服务的话，需要做以下几件事情： 买个手机 插上手机卡 设计手机为正常接听状态（即能够响铃） 静静的等着别人拨打 tcp服务器如同上面的电话机过程一样，在程序中，如果想要完成一个tcp服务器的功能，需要的流程如下： socket创建一个套接字 bind绑定ip和port listen使套接字变为可以被动链接 accept等待客户端的链接 recv/send接收发送数据 一个很简单的tcp服务器如下： 12345678910111213141516171819202122232425262728from socket import *# 创建sockettcp_server_socket = socket(AF_INET, SOCK_STREAM)# 本地信息address = ('', 7788)# 绑定tcp_server_socket.bind(address)# 使用socket创建的套接字默认的属性是主动的，使用listen将其变为被动的，这样就可以接收别人的链接了tcp_server_socket.listen(128)# 如果有新的客户端来链接服务器，那么就产生一个新的套接字专门为这个客户端服务# client_socket用来为这个客户端服务# tcp_server_socket就可以省下来专门等待其他新客户端的链接client_socket, clientAddr = tcp_server_socket.accept()# 接收对方发送过来的数据recv_data = client_socket.recv(1024) # 接收1024个字节print('接收到的数据为:', recv_data.decode('gbk'))# 发送一些数据到客户端client_socket.send(\"thank you !\".encode('gbk'))# 关闭为这个客户端服务的套接字，只要关闭了，就意味着为不能再为这个客户端服务了，如果还需要服务，只能再次重新连接client_socket.close() 运行流程：&lt;1&gt;tcp服务器1接收到的数据为: 你在么？ &lt;2&gt;网络调试助手： tcp注意点 tcp服务器一般情况下都需要绑定，否则客户端找不到这个服务器 tcp客户端一般不绑定，因为是主动链接服务器，所以只要确定好服务器的ip、port等信息就好，本地客户端可以随机 tcp服务器中通过listen可以将socket创建出来的主动套接字变为被动的，这是做tcp服务器时必须要做的 当客户端需要链接服务器时，就需要使用connect进行链接，udp是不需要链接的而是直接发送，但是tcp必须先链接，只有链接成功才能通信 当一个tcp客户端连接服务器时，服务器端会有1个新的套接字，这个套接字用来标记这个客户端，单独为这个客户端服务 listen后的套接字是被动套接字，用来接收新的客户端的链接请求的，而accept返回的新套接字是标记这个新客户端的 关闭listen后的套接字意味着被动套接字关闭了，会导致新的客户端不能够链接服务器，但是之前已经链接成功的客户端正常通信。 关闭accept返回的套接字意味着这个客户端已经服务完毕 当客户端的套接字调用close后，服务器端会recv解堵塞，并且返回的长度为0，因此服务器可以通过返回数据的长度来区别客户端是否已经下线","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"9-TCP简介","slug":"9-TCP简介","date":"2020-02-10T09:10:11.000Z","updated":"2020-02-10T09:33:45.154Z","comments":true,"path":"2020/02/10/9-TCP简介/","link":"","permalink":"http://yoursite.com/2020/02/10/9-TCP%E7%AE%80%E4%BB%8B/","excerpt":"TCP简介","text":"TCP简介 TCP介绍TCP协议，传输控制协议（英语：Transmission Control Protocol，缩写为TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。 TCP通信需要经过创建连接、数据传送、终止连接三个步骤。 TCP通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，”打电话”” TCP特点1. 面向连接通信双方必须先建立连接才能进行数据的传输，双方都必须为该连接分配必要的系统内核资源，以管理连接的状态和连接上的传输。 双方间的数据传输都可以通过这一个连接进行。 完成数据交换后，双方必须断开此连接，以释放系统资源。 这种连接是一对一的，因此TCP不适用于广播的应用程序，基于广播的应用程序请使用UDP协议。 2. 可靠传输1）TCP采用发送应答机制 TCP发送的每个报文段都必须得到接收方的应答才认为这个TCP报文段传输成功 2）超时重传 发送端发出一个报文段之后就启动定时器，如果在定时时间内没有收到应答就重新发送这个报文段。 TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。 3）错误校验 TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。 4) 流量控制和阻塞管理 流量控制用来避免主机发送得过快而使接收方来不及完全收下。 TCP与UDP的不同点 面向连接（确认有创建三方交握，连接已创建才作传输。） 有序数据传输 重发丢失的数据包 舍弃重复的数据包 无差错的数据传输 阻塞/流量控制 udp通信模型udp通信模型中，在通信开始之前，不需要建立相关的链接，只需要发送数据即可，类似于生活中，”写信”” TCP通信模型udp通信模型中，在通信开始之前，一定要先建立相关的链接，才能发送数据，类似于生活中，”打电话””","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"8-应用：udp聊天器","slug":"8-应用：udp聊天器","date":"2020-02-10T09:04:04.000Z","updated":"2020-02-10T09:33:31.829Z","comments":true,"path":"2020/02/10/8-应用：udp聊天器/","link":"","permalink":"http://yoursite.com/2020/02/10/8-%E5%BA%94%E7%94%A8%EF%BC%9Audp%E8%81%8A%E5%A4%A9%E5%99%A8/","excerpt":"应用：udp聊天器","text":"应用：udp聊天器 说明 在一个电脑中编写1个程序，有2个功能 1.获取键盘数据，并将其发送给对方 2.接收数据并显示 并且功能数据进行选择以上的2个功能调用 要求 实现上述程序 参考代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import socketdef send_msg(udp_socket): \"\"\"获取键盘数据，并将其发送给对方\"\"\" # 1. 从键盘输入数据 msg = input(\"\\n请输入要发送的数据:\") # 2. 输入对方的ip地址 dest_ip = input(\"\\n请输入对方的ip地址:\") # 3. 输入对方的port dest_port = int(input(\"\\n请输入对方的port:\")) # 4. 发送数据 udp_socket.sendto(msg.encode(\"utf-8\"), (dest_ip, dest_port))def recv_msg(udp_socket): \"\"\"接收数据并显示\"\"\" # 1. 接收数据 recv_msg = udp_socket.recvfrom(1024) # 2. 解码 recv_ip = recv_msg[1] recv_msg = recv_msg[0].decode(\"utf-8\") # 3. 显示接收到的数据 print(\"&gt;&gt;&gt;%s:%s\" % (str(recv_ip), recv_msg))def main(): # 1. 创建套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 2. 绑定本地信息 udp_socket.bind((\"\", 7890)) while True: # 3. 选择功能 print(\"=\"*30) print(\"1:发送消息\") print(\"2:接收消息\") print(\"=\"*30) op_num = input(\"请输入要操作的功能序号:\") # 4. 根据选择调用相应的函数 if op_num == \"1\": send_msg(udp_socket) elif op_num == \"2\": recv_msg(udp_socket) else: print(\"输入有误，请重新输入...\")if __name__ == \"__main__\": main() 想一想 以上的程序如果选择了接收数据功能，并且此时没有数据，程序会堵塞在这，那么怎样才能让这个程序收发数据一起进行呢？别着急，学习完多任务知识之后就解决了O(∩_∩)O…","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"7-python3编码转换","slug":"7-python3编码转换","date":"2020-02-10T09:02:11.000Z","updated":"2020-02-10T09:33:20.834Z","comments":true,"path":"2020/02/10/7-python3编码转换/","link":"","permalink":"http://yoursite.com/2020/02/10/7-python3%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2/","excerpt":"python3编码转换","text":"python3编码转换 12str-&gt;bytes:encode编码bytes-&gt;str:decode解码 字符串通过编码成为字节码，字节码通过解码成为字符串。 12345678910111213141516171819&gt;&gt;&gt; text = '我是文本'&gt;&gt;&gt; text'我是文本'&gt;&gt;&gt; print(text)我是文本&gt;&gt;&gt; bytesText = text.encode()&gt;&gt;&gt; bytesTextb'\\xe6\\x88\\x91\\xe6\\x98\\xaf\\xe6\\x96\\x87\\xe6\\x9c\\xac'&gt;&gt;&gt; print(bytesText)b'\\xe6\\x88\\x91\\xe6\\x98\\xaf\\xe6\\x96\\x87\\xe6\\x9c\\xac'&gt;&gt;&gt; type(text)&lt;class 'str'&gt;&gt;&gt;&gt; type(bytesText)&lt;class 'bytes'&gt;&gt;&gt;&gt; textDecode = bytesText.decode()&gt;&gt;&gt; textDecode'我是文本'&gt;&gt;&gt; print(textDecode)我是文本 其中decode()与encode()方法可以接受参数，其声明分别为: 12bytes.decode(encoding=\"utf-8\", errors=\"strict\")str.encode(encoding=\"utf-8\", errors=\"strict\") 其中的encoding是指在解码编码过程中使用的编码(此处指“编码方案”是名词)，errors是指错误的处理方案。 详细的可以参照官方文档： str.encode() bytes.decode()","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"6-udp绑定信息","slug":"6-udp绑定信息","date":"2020-02-10T08:52:56.000Z","updated":"2020-02-10T09:33:09.871Z","comments":true,"path":"2020/02/10/6-udp绑定信息/","link":"","permalink":"http://yoursite.com/2020/02/10/6-udp%E7%BB%91%E5%AE%9A%E4%BF%A1%E6%81%AF/","excerpt":"udp绑定信息","text":"udp绑定信息 1. udp网络程序-端口问题 会变的端口号 重新运行多次脚本，然后在“网络调试助手”中，看到的现象如下： 说明： 每重新运行一次网络程序，上图中红圈中的数字，不一样的原因在于，这个数字标识这个网络程序，当重新运行时，如果没有确定到底用哪个，系统默认会随机分配 记住一点：这个网络程序在运行的过程中，这个就唯一标识这个程序，所以如果其他电脑上的网络程序如果想要向此程序发送数据，那么就需要向这个数字（即端口）标识的程序发送即可 2. udp绑定信息&lt;1&gt;. 绑定信息一般情况下，在一台电脑上运行的网络程序有很多，为了不与其他的网络程序占用同一个端口号，往往在编程中，udp的端口号一般不绑定 但是如果需要做成一个服务器端的程序的话，是需要绑定的，想想看这又是为什么呢？ 如果报警电话每天都在变，想必世界就会乱了，所以一般服务性的程序，往往需要一个固定的端口号，这就是所谓的端口绑定 &lt;2&gt;. 绑定示例12345678910111213141516171819#coding=utf-8from socket import *# 1. 创建套接字udp_socket = socket(AF_INET, SOCK_DGRAM)# 2. 绑定本地的相关信息，如果一个网络程序不绑定，则系统会随机分配local_addr = ('', 7788) # ip地址和端口号，ip一般不用写，表示本机的任何一个ipudp_socket.bind(local_addr)# 3. 等待接收对方发送的数据recv_data = udp_socket.recvfrom(1024) # 1024表示本次接收的最大字节数# 4. 显示接收到的数据print(recv_data[0].decode('gbk'))# 5. 关闭套接字udp_socket.close() &lt;3&gt;. 总结 一个udp网络程序，可以不绑定，此时操作系统会随机进行分配一个端口，如果重新运行此程序端口可能会发生变化 一个udp网络程序，也可以绑定信息（ip地址，端口号），如果绑定成功，那么操作系统用这个端口号来进行区别收到的网络数据是否是此进程的","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"5-udp网络程序-发送、接收数据","slug":"5-udp网络程序-发送、接收数据","date":"2020-02-10T08:49:54.000Z","updated":"2020-02-10T09:33:00.128Z","comments":true,"path":"2020/02/10/5-udp网络程序-发送、接收数据/","link":"","permalink":"http://yoursite.com/2020/02/10/5-udp%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F-%E5%8F%91%E9%80%81%E3%80%81%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE/","excerpt":"udp网络程序-发送、接收数据","text":"udp网络程序-发送、接收数据 1. udp网络程序-发送数据创建一个基于udp的网络程序流程很简单，具体步骤如下： 创建客户端套接字 发送/接收数据 关闭套接字 代码如下： 1234567891011121314151617181920#coding=utf-8from socket import *# 1. 创建udp套接字udp_socket = socket(AF_INET, SOCK_DGRAM)# 2. 准备接收方的地址# '192.168.1.103'表示目的ip地址# 8080表示目的端口dest_addr = ('192.168.1.103', 8080) # 注意 是元组，ip是字符串，端口是数字# 3. 从键盘获取数据send_data = input(\"请输入要发送的数据:\")# 4. 发送数据到指定的电脑上的指定程序中udp_socket.sendto(send_data.encode('utf-8'), dest_addr)# 5. 关闭套接字udp_socket.close() 2. udp网络程序-发送、接收数据12345678910111213141516171819202122232425262728#coding=utf-8from socket import *# 1. 创建udp套接字udp_socket = socket(AF_INET, SOCK_DGRAM)# 2. 准备接收方的地址dest_addr = ('192.168.236.129', 8080)# 3. 从键盘获取数据send_data = input(\"请输入要发送的数据:\")# 4. 发送数据到指定的电脑上udp_socket.sendto(send_data.encode('utf-8'), dest_addr)# 5. 等待接收对方发送的数据recv_data = udp_socket.recvfrom(1024) # 1024表示本次接收的最大字节数# 6. 显示对方发送的数据# 接收到的数据recv_data是一个元组# 第1个元素是对方发送的数据# 第2个元素是对方的ip和端口print(recv_data[0].decode('gbk'))print(recv_data[1])# 7. 关闭套接字udp_socket.close()","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"4-socket简介","slug":"4-socket简介","date":"2020-02-10T08:47:50.000Z","updated":"2020-02-10T09:32:44.213Z","comments":true,"path":"2020/02/10/4-socket简介/","link":"","permalink":"http://yoursite.com/2020/02/10/4-socket%E7%AE%80%E4%BB%8B/","excerpt":"socket简介","text":"socket简介 1. 不同电脑上的进程之间如何通信首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！ 在1台电脑上可以通过进程号（PID）来唯一标识一个进程，但是在网络中这是行不通的。 其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用进程（进程）。 这样利用ip地址，协议，端口就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互 注意： 所谓进程指的是：运行的程序以及运行时用到的资源这个整体称之为进程（在讲解多任务编程时进行详细讲解） 所谓进程间通信指的是：运行的程序之间的数据共享 后面课程中会详细说到，像网络层等知识，不要着急 2. 什么是socketsocket(简称套接字)是进程间通信的一种方式，它与其他进程间通信的一个主要不同是： 它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于Socket 来完成通信的 例如我们每天浏览网页、QQ 聊天、收发email 等等 3. 创建socket在Python 中使用socket 模块的函数socket 就可以完成： 12import socketsocket.socket(AddressFamily, Type) 说明：函数socket.socket 创建一个socket，该函数带有两个参数： Address Family：可以选择AF_INET（用于Internet 进程间通信） 或者AF_UNIX（用于同一台机器进程间通信）,实际工作中常用AF_INET Type：套接字类型，可以是SOCK_STREAM（流式套接字，主要用于TCP 协议）或者SOCK_DGRAM（数据报套接字，主要用于UDP 协议） 创建一个tcp socket（tcp套接字） 123456789import socket# 创建tcp的套接字s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# ...这里是使用套接字的功能（省略）...# 不用的时候，关闭套接字s.close() 创建一个udp socket（udp套接字） 123456789import socket# 创建udp的套接字s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# ...这里是使用套接字的功能（省略）...# 不用的时候，关闭套接字s.close() 说明 套接字使用流程与文件的使用流程很类似 创建套接字 使用套接字收/发数据 关闭套接字","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"3-端口","slug":"3-端口","date":"2020-02-10T08:43:28.000Z","updated":"2020-02-10T09:36:40.283Z","comments":true,"path":"2020/02/10/3-端口/","link":"","permalink":"http://yoursite.com/2020/02/10/3-%E7%AB%AF%E5%8F%A3/","excerpt":"端口","text":"端口 1. 什么是端口端口就好一个房子的门，是出入这间房子的必经之路。 如果一个程序需要收发网络数据，那么就需要有这样的端口 在linux系统中，端口可以有65536（2的16次方）个之多！ 既然有这么多，操作系统为了统一管理，所以进行了编号，这就是端口号 2. 端口号端口是通过端口号来标记的，端口号只有整数，范围是从0到65535 注意：端口数不一样的*nix系统不一样，还可以手动修改 3. 端口是怎样分配的端口号不是随意使用的，而是按照一定的规定进行分配。 端口的分类标准有好几种，我们这里不做详细讲解，只介绍一下知名端口和动态端口 3.1 知名端口（Well Known Ports）知名端口是众所周知的端口号，范围从0到1023 1280端口分配给HTTP服务21端口分配给FTP服务 可以理解为，一些常用的功能使用的号码是估计的，好比电话号码110、10086、10010一样 一般情况下，如果一个程序需要使用知名端口的需要有root权限 3.2 动态端口（Dynamic Ports）动态端口的范围是从1024到65535 之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。 动态分配是指当一个系统程序或应用程序程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。 当这个程序关闭时，同时也就释放了所占用的端口号 3.3 怎样查看端口？ 用“netstat －an”查看端口状态 lsof -i [tcp/udp]:2425 4. 小总结端口有什么用呢？我们知道，一台拥有IP地址的主机可以提供许多服务，比如HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。需要注意的是，端口并不是一一对应的。比如你的电脑作为客户机访问一台WWW服务器时，WWW服务器使用“80”端口与你的电脑通信，但你的电脑则可能使用“3457”这样的端口。","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"2-Linux命令(ping, ifconfig)","slug":"2-Linux命令-ping-ifconfig","date":"2020-02-10T08:40:27.000Z","updated":"2020-02-10T09:32:24.056Z","comments":true,"path":"2020/02/10/2-Linux命令-ping-ifconfig/","link":"","permalink":"http://yoursite.com/2020/02/10/2-Linux%E5%91%BD%E4%BB%A4-ping-ifconfig/","excerpt":"Linux命令(ping, ifconfig)","text":"Linux命令(ping, ifconfig) 查看或配置网卡信息：ifconfig如果，我们只是敲：ifconfig，它会显示所有网卡的信息： 测试远程主机连通性：ping通常用ping来检测网络是否正常","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"1-ip地址","slug":"1-ip地址","date":"2020-02-10T08:35:44.000Z","updated":"2020-02-10T09:32:12.046Z","comments":true,"path":"2020/02/10/1-ip地址/","link":"","permalink":"http://yoursite.com/2020/02/10/1-ip%E5%9C%B0%E5%9D%80/","excerpt":"ip地址","text":"ip地址 1. 什么是地址地址就是用来标记地点的 2. ip地址的作用ip地址：用来在网络中标记一台电脑，比如192.168.1.1；在本地局域网上是唯一的。3. ip地址的分类（了解）每一个IP地址包括两部分：网络地址和主机地址 3.1 A类IP地址一个A类IP地址由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”， 地址范围1.0.0.1-126.255.255.254 二进制表示为：00000001 00000000 00000000 00000001 - 01111110 11111111 11111111 11111110 可用的A类网络有126个，每个网络能容纳1677214个主机 3.2 B类IP地址一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”， 地址范围128.1.0.1-191.255.255.254 二进制表示为：10000000 00000001 00000000 00000001 - 10111111 11111111 11111111 11111110 可用的B类网络有16384个，每个网络能容纳65534主机 3.3 C类IP地址一个C类IP地址由3字节的网络地址和1字节的主机地址组成，网络地址的最高位必须是“110” 范围192.0.1.1-223.255.255.254 二进制表示为: 11000000 00000000 00000001 00000001 - 11011111 11111111 11111110 11111110 C类网络可达2097152个，每个网络能容纳254个主机 3.4 D类地址用于多点广播D类IP地址第一个字节以“1110”开始，它是一个专门保留的地址。 它并不指向特定的网络，目前这一类地址被用在多点广播（Multicast）中 多点广播地址用来一次寻址一组计算机s 地址范围224.0.0.1-239.255.255.254 3.5 E类IP地址以“1111”开始，为将来使用保留 E类地址保留，仅作实验和开发用 3.6 私有ip在这么多网络IP中，国际规定有一部分IP地址是用于我们的局域网使用，也就 是属于私网IP，不在公网中使用的，它们的范围是： 1234510.0.0.0～10.255.255.255172.16.0.0～172.31.255.255192.168.0.0～192.168.255.255 3.7 注意IP地址127．0．0．1~127．255．255．255用于回路测试， 如：127.0.0.1可以代表本机IP地址，用http://127.0.0.1就可以测试本机中配置的Web服务器。","categories":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"网络通信","slug":"网络通信","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}]},{"title":"14-eval函数","slug":"14-eval函数","date":"2020-02-08T08:12:38.000Z","updated":"2020-02-08T08:55:26.866Z","comments":true,"path":"2020/02/08/14-eval函数/","link":"","permalink":"http://yoursite.com/2020/02/08/14-eval%E5%87%BD%E6%95%B0/","excerpt":"eval 函数","text":"eval 函数 eval() 函数十分强大 —— 将字符串 当成 有效的表达式 来求值 并 返回计算结果 123456789101112131415# 基本的数学计算In [1]: eval(\"1 + 1\")Out[1]: 2# 字符串重复In [2]: eval(\"'*' * 10\")Out[2]: '**********'# 将字符串转换成列表In [3]: type(eval(\"[1, 2, 3, 4, 5]\"))Out[3]: list# 将字符串转换成字典In [4]: type(eval(\"&#123;'name': 'xiaoming', 'age': 18&#125;\"))Out[4]: dict 案例 - 计算器需求 提示用户输入一个 加减乘除混合运算 返回计算结果 123input_str = input(\"请输入一个算术题：\")print(eval(input_str)) 不要滥用 eval 在开发时千万不要使用 eval 直接转换 input 的结果 1__import__('os').system('ls') 等价代码 123import osos.system(\"终端命令\") 执行成功，返回 0 执行失败，返回错误信息","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"13-文件","slug":"13-文件","date":"2020-02-08T08:06:15.000Z","updated":"2020-02-08T08:55:09.854Z","comments":true,"path":"2020/02/08/13-文件/","link":"","permalink":"http://yoursite.com/2020/02/08/13-%E6%96%87%E4%BB%B6/","excerpt":"文件目标 文件的概念 文件的基本操作 文件/文件夹的常用操作 文本文件的编码方式","text":"文件目标 文件的概念 文件的基本操作 文件/文件夹的常用操作 文本文件的编码方式 01. 文件的概念 1.1 文件的概念和作用 计算机的 文件，就是存储在某种 长期储存设备 上的一段 数据 长期存储设备包括：硬盘、U 盘、移动硬盘、光盘… 文件的作用 将数据长期保存下来，在需要的时候使用 CPU 内存 硬盘 ￼ ￼ ￼ 1.2 文件的存储方式 在计算机中，文件是以 二进制 的方式保存在磁盘上的 文本文件和二进制文件 文本文件 可以使用 文本编辑软件 查看 本质上还是二进制文件 例如：python 的源程序 二进制文件 保存的内容 不是给人直接阅读的，而是 提供给其他软件使用的 例如：图片文件、音频文件、视频文件等等 二进制文件不能使用 文本编辑软件 查看 02. 文件的基本操作2.1 操作文件的套路在 计算机 中要操作文件的套路非常固定，一共包含三个步骤： 打开文件 读、写文件 读 将文件内容读入内存 写 将内存内容写入文件 关闭文件 2.2 操作文件的函数/方法 在 Python 中要操作文件需要记住 1 个函数和 3 个方法 序号 函数/方法 说明 01 open 打开文件，并且返回文件操作对象 02 read 将文件内容读取到内存 03 write 将指定内容写入文件 04 close 关闭文件 open 函数负责打开文件，并且返回文件对象 read/write/close 三个方法都需要通过 文件对象 来调用 2.3 read 方法 —— 读取文件 open函数的第一个参数是要打开的文件名（文件名区分大小写） 如果文件 存在，返回 文件操作对象 如果文件 不存在，会 抛出异常 read 方法可以一次性 读入 并 返回 文件的 所有内容 close方法负责关闭文件 如果 忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问 注意：read 方法执行后，会把 文件指针 移动到 文件的末尾 123456789# 1. 打开 - 文件名需要注意大小写file = open(\"README\")# 2. 读取text = file.read()print(text)# 3. 关闭file.close() 提示 在开发中，通常会先编写 打开 和 关闭 的代码，再编写中间针对文件的 读/写 操作！ 文件指针（知道） 文件指针 标记 从哪个位置开始读取数据 第一次打开 文件时，通常 文件指针会指向文件的开始位置 当执行了read方法后，文件指针会移动到读取内容的末尾 默认情况下会移动到 文件末尾 思考 如果执行了一次 read 方法，读取了所有内容，那么再次调用 read 方法，还能够获得到内容吗？ 答案 不能 第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容 2.4 打开文件的方式 open 函数默认以 只读方式 打开文件，并且返回文件对象 语法如下： 1f = open(\"文件名\", \"访问方式\") 访问方式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常 w 以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a 以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 r+ 以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常 w+ 以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件 a+ 以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入 提示 频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以 只读、只写 的方式来操作文件 写入文件示例 12345678# 打开文件f = open(\"README\", \"w\")f.write(\"hello python！\\n\")f.write(\"今天天气真好\")# 关闭文件f.close() 2.5 按行读取文件内容 read 方法默认会把文件的 所有内容 一次性读取到内存 如果文件太大，对内存的占用会非常严重 readline 方法 readline 方法可以一次读取一行内容 方法执行后，会把 文件指针 移动到下一行，准备再次读取 读取大文件的正确姿势 12345678910111213141516# 打开文件file = open(\"README\")while True: # 读取一行内容 text = file.readline() # 判断是否读到内容 if not text: break # 每读取一行的末尾已经有了一个 `\\n` print(text, end=\"\")# 关闭文件file.close() 2.6 文件读写案例 —— 复制文件目标 用代码的方式，来实现文件复制过程 ￼ 小文件复制 打开一个已有文件，读取完整内容，并写入到另外一个文件 1234567891011# 1. 打开文件file_read = open(\"README\")file_write = open(\"README[复件]\", \"w\")# 2. 读取并写入文件text = file_read.read()file_write.write(text)# 3. 关闭文件file_read.close()file_write.close() 大文件复制 打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件 123456789101112131415161718# 1. 打开文件file_read = open(\"README\")file_write = open(\"README[复件]\", \"w\")# 2. 读取并写入文件while True: # 每次读取一行 text = file_read.readline() # 判断是否读取到内容 if not text: break file_write.write(text)# 3. 关闭文件file_read.close()file_write.close() 03. 文件/目录的常用管理操作 在终端/文件浏览器、 中可以执行常规的文件/目录管理操作，例如： 创建、重命名、删除、改变路径、查看目录内容、…… 在 Python 中，如果希望通过程序实现上述功能，需要导入 os 模块 文件操作 序号 方法名 说明 示例 01 rename 重命名文件 os.rename(源文件名, 目标文件名) 02 remove 删除文件 os.remove(文件名) 目录操作 序号 方法名 说明 示例 01 listdir 目录列表 os.listdir(目录名) 02 mkdir 创建目录 os.mkdir(目录名) 03 rmdir 删除目录 os.rmdir(目录名) 04 getcwd 获取当前目录 os.getcwd() 05 chdir 修改工作目录 os.chdir(目标目录) 06 path.isdir 判断是否是文件 os.path.isdir(文件路径) 提示：文件或者目录操作都支持 相对路径 和 绝对路径 04. 文本文件的编码格式（科普） 文本文件存储的内容是基于 字符编码 的文件，常见的编码有 ASCII 编码，UNICODE 编码等 Python 2.x 默认使用 ASCII 编码格式Python 3.x 默认使用 UTF-8 编码格式 4.1 ASCII 编码和 UNICODE 编码ASCII 编码 计算机中只有 256 个 ASCII 字符 一个ASCII在内存中占用1 个字节的空间 8 个 0/1 的排列组合方式一共有 256 种，也就是 2 ** 8 ￼ UTF-8 编码格式 计算机中使用 1~6 个字节 来表示一个 UTF-8 字符，涵盖了 地球上几乎所有地区的文字 大多数汉字会使用 3 个字节 表示 UTF-8 是 UNICODE 编码的一种编码格式 4.2 Ptyhon 2.x 中如何使用中文 Python 2.x 默认使用 ASCII 编码格式Python 3.x 默认使用 UTF-8 编码格式 在 Python 2.x 文件的 第一行 增加以下代码，解释器会以 utf-8 编码来处理 python 文件 1# *-* coding:utf8 *-* 这方式是官方推荐使用的！ 也可以使用 1# coding=utf8 unicode 字符串 在 Python 2.x 中，即使指定了文件使用 UTF-8 的编码格式，但是在遍历字符串时，仍然会 以字节为单位遍历 字符串 要能够 正确的遍历字符串，在定义字符串时，需要 在字符串的引号前，增加一个小写字母 u，告诉解释器这是一个 unicode 字符串（使用 UTF-8 编码格式的字符串） 123456789# *-* coding:utf8 *-*# 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串hello_str = u\"你好世界\"print(hello_str)for c in hello_str: print(c)","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"12-模块和包","slug":"12-模块和包","date":"2020-02-08T08:01:27.000Z","updated":"2020-02-08T08:55:41.286Z","comments":true,"path":"2020/02/08/12-模块和包/","link":"","permalink":"http://yoursite.com/2020/02/08/12-%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/","excerpt":"模块和包目标 模块 包 发布模块","text":"模块和包目标 模块 包 发布模块 01. 模块1.1 模块的概念 模块是 Python 程序架构的一个核心概念 每一个以扩展名 py 结尾的 Python 源代码文件都是一个 模块 模块名 同样也是一个 标识符，需要符合标识符的命名规则 在模块中定义的 全局变量 、函数、类 都是提供给外界直接使用的 工具 模块 就好比是 工具包，要想使用这个工具包中的工具，就需要先 导入 这个模块 1.2 模块的两种导入方式1）import 导入1import 模块名1, 模块名2 提示：在导入模块时，每个导入应该独占一行 12import 模块名1import 模块名2 导入之后 通过 模块名. 使用 模块提供的工具 —— 全局变量、函数、类 使用 as 指定模块的别名 如果模块的名字太长，可以使用 as 指定模块的名称，以方便在代码中的使用 1import 模块名1 as 模块别名 注意：模块别名 应该符合 大驼峰命名法 2）from…import 导入 如果希望 从某一个模块 中，导入 部分 工具，就可以使用 from ... import 的方式 import 模块名 是 一次性 把模块中 所有工具全部导入，并且通过 模块名/别名 访问 12# 从 模块 导入 某一个工具from 模块名1 import 工具名 导入之后 不需要 通过 模块名. 可以直接使用 模块提供的工具 —— 全局变量、函数、类 注意 如果 两个模块，存在 同名的函数，那么 后导入模块的函数，会 覆盖掉先导入的函数 开发时 import 代码应该统一写在 代码的顶部，更容易及时发现冲突 一旦发现冲突，可以使用 as 关键字 给其中一个工具起一个别名 from…import *（知道）12# 从 模块 导入 所有工具from 模块名1 import * 注意 这种方式不推荐使用，因为函数重名并没有任何的提示，出现问题不好排查 1.3 模块的搜索顺序[扩展]Python 的解释器在 导入模块 时，会： 搜索 当前目录 指定模块名的文件，如果有就直接导入 如果没有，再搜索 系统目录 在开发时，给文件起名，不要和 系统的模块文件 重名 Python 中每一个模块都有一个内置属性 __file__ 可以 查看模块 的 完整路径 示例 123456import random# 生成一个 0～10 的数字rand = random.randint(0, 10)print(rand) 注意：如果当前目录下，存在一个 random.py 的文件，程序就无法正常执行了！ 这个时候，Python 的解释器会 加载当前目录 下的 random.py 而不会加载 系统的 random 模块 1.4 原则 —— 每一个文件都应该是可以被导入的 一个 独立的 Python 文件 就是一个 模块 在导入文件时，文件中 所有没有任何缩进的代码 都会被执行一遍！ 实际开发场景 在实际开发中，每一个模块都是独立开发的，大多都有专人负责 开发人员通常会在模块下方增加一些测试代码 仅在模块内使用，而被导入到其他文件中不需要执行 __name__ 属性 __name__ 属性可以做到，测试模块的代码 只在测试情况下被运行，而在 被导入时不会被执行！ __name__ 是 Python 的一个内置属性，记录着一个 字符串 如果 是被其他文件导入的，__name__ 就是 模块名 如果 是当前执行的程序 __name__ 是 __main__ 在很多 Python 文件中都会看到以下格式的代码： 12345678910111213# 导入模块# 定义全局变量# 定义类# 定义函数# 在代码的最下方def main(): # ... pass# 根据 __name__ 判断是否执行下方代码if __name__ == \"__main__\": main() 02. 包（Package）概念 包 是一个 包含多个模块 的 特殊目录 目录下有一个 特殊的文件 __init__.py 包名的 命名方式 和变量名一致，小写字母 + _ 好处 使用 import 包名 可以一次性导入 包 中 所有的模块 案例演练 新建一个 hm_message 的 包 在目录下，新建两个文件 send_message 和 receive_message 在 send_message 文件中定义一个 send 函数 在 receive_message 文件中定义一个 receive 函数 在外部直接导入 hm_message 的包 __init__.py 要在外界使用 包 中的模块，需要在 __init__.py 中指定 对外界提供的模块列表 123# 从 当前目录 导入 模块列表from . import send_messagefrom . import receive_message 03. 发布模块（知道） 如果希望自己开发的模块，分享 给其他人，可以按照以下步骤操作 3.1 制作发布压缩包步骤1) 创建 setup.py setup.py 的文件 1234567891011from distutils.core import setupsetup(name=\"hm_message\", # 包名 version=\"1.0\", # 版本 description=\"itheima's 发送和接收消息模块\", # 描述信息 long_description=\"完整的发送和接收消息模块\", # 完整描述信息 author=\"itheima\", # 作者 author_email=\"itheima@itheima.com\", # 作者邮箱 url=\"www.itheima.com\", # 主页 py_modules=[\"hm_message.send_message\", \"hm_message.receive_message\"]) 有关字典参数的详细信息，可以参阅官方网站： https://docs.python.org/2/distutils/apiref.html 2) 构建模块1$ python3 setup.py build 3) 生成发布压缩包1$ python3 setup.py sdist 注意：要制作哪个版本的模块，就使用哪个版本的解释器执行！ 3.2 安装模块123$ tar -zxvf hm_message-1.0.tar.gz $ sudo python3 setup.py install 卸载模块 直接从安装目录下，把安装模块的 目录 删除就可以 12$ cd /usr/local/lib/python3.5/dist-packages/$ sudo rm -r hm_message* 3.3 pip 安装第三方模块 第三方模块通常是指由知名的第三方团队开发的并且被程序员广泛使用Python包 / 模块 例如 pygame 就是一套非常成熟的 游戏开发模块 pip 是一个现代的，通用的 Python 包管理工具 提供了对 Python 包的查找、下载、安装、卸载等功能 安装和卸载命令如下： 1234567# 将模块安装到 Python 2.x 环境$ sudo pip install pygame$ sudo pip uninstall pygame# 将模块安装到 Python 3.x 环境$ sudo pip3 install pygame$ sudo pip3 uninstall pygame 在 Mac 下安装 iPython1$ sudo pip install ipython 在 Linux 下安装 iPython12$ sudo apt install ipython$ sudo apt install ipython3","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"11-异常","slug":"11-异常","date":"2020-02-08T07:55:25.000Z","updated":"2020-02-08T08:55:54.748Z","comments":true,"path":"2020/02/08/11-异常/","link":"","permalink":"http://yoursite.com/2020/02/08/11-%E5%BC%82%E5%B8%B8/","excerpt":"异常目标 异常的概念 捕获异常 异常的传递 抛出异常","text":"异常目标 异常的概念 捕获异常 异常的传递 抛出异常 01. 异常的概念 程序在运行时，如果 Python 解释器 遇到 到一个错误，会停止程序的执行，并且提示一些错误信息，这就是 异常 程序停止执行并且提示错误信息 这个动作，我们通常称之为：抛出(raise)异常 ￼ 程序开发时，很难将 所有的特殊情况 都处理的面面俱到，通过 异常捕获 可以针对突发事件做集中的处理，从而保证程序的 稳定性和健壮性 02. 捕获异常2.1 简单的捕获异常语法 在程序开发中，如果 对某些代码的执行不能确定是否正确，可以增加 try(尝试) 来 捕获异常 捕获异常最简单的语法格式： 1234try: 尝试执行的代码except: 出现错误的处理 try 尝试，下方编写要尝试代码，不确定是否能够正常执行的代码 except 如果不是，下方编写尝试失败的代码 简单异常捕获演练 —— 要求用户输入整数12345try: # 提示用户输入一个数字 num = int(input(\"请输入数字：\"))except: print(\"请输入正确的数字\") 2.2 错误类型捕获 在程序执行时，可能会遇到 不同类型的异常，并且需要 针对不同类型的异常，做出不同的响应，这个时候，就需要捕获错误类型了 语法如下： 1234567891011try: # 尝试执行的代码 passexcept 错误类型1: # 针对错误类型1，对应的代码处理 passexcept (错误类型2, 错误类型3): # 针对错误类型2 和 3，对应的代码处理 passexcept Exception as result: print(\"未知错误 %s\" % result) 当 Python 解释器 抛出异常 时，最后一行错误信息的第一个单词，就是错误类型 异常类型捕获演练 —— 要求用户输入整数需求 提示用户输入一个整数 使用 8 除以用户输入的整数并且输出 12345678try: num = int(input(\"请输入整数：\")) result = 8 / num print(result)except ValueError: print(\"请输入正确的整数\")except ZeroDivisionError: print(\"除 0 错误\") 捕获未知错误 在开发时，要预判到所有可能出现的错误，还是有一定难度的 如果希望程序 无论出现任何错误，都不会因为 Python 解释器 抛出异常而被终止，可以再增加一个 except 语法如下： 12except Exception as result: print(\"未知错误 %s\" % result) 2.3 异常捕获完整语法 在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下： 提示： 有关完整语法的应用场景，在后续学习中，结合实际的案例会更好理解 现在先对这个语法结构有个印象即可 123456789101112131415161718192021try: # 尝试执行的代码 passexcept 错误类型1: # 针对错误类型1，对应的代码处理 passexcept 错误类型2: # 针对错误类型2，对应的代码处理 passexcept (错误类型3, 错误类型4): # 针对错误类型3 和 4，对应的代码处理 passexcept Exception as result: # 打印错误信息 print(result)else: # 没有异常才会执行的代码 passfinally: # 无论是否有异常，都会执行的代码 print(\"无论是否有异常，都会执行的代码\") else 只有在没有异常时才会执行的代码 finally 无论是否有异常，都会执行的代码 之前一个演练的 完整捕获异常 的代码如下： 1234567891011121314try: num = int(input(\"请输入整数：\")) result = 8 / num print(result)except ValueError: print(\"请输入正确的整数\")except ZeroDivisionError: print(\"除 0 错误\")except Exception as result: print(\"未知错误 %s\" % result)else: print(\"正常执行\")finally: print(\"执行完成，但是不保证正确\") 03. 异常的传递 异常的传递 —— 当 函数/方法 执行 出现异常，会 将异常传递 给 函数/方法 的 调用一方 如果 传递到主程序，仍然 没有异常处理，程序才会被终止 提示 在开发中，可以在主函数中增加 异常捕获 而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的 异常捕获 中 这样就不需要在代码中，增加大量的 异常捕获，能够保证代码的整洁 需求 定义函数 demo1() 提示用户输入一个整数并且返回 定义函数 demo2() 调用 demo1() 在主程序中调用 demo2() 12345678910111213def demo1(): return int(input(\"请输入一个整数：\"))def demo2(): return demo1()try: print(demo2())except ValueError: print(\"请输入正确的整数\")except Exception as result: print(\"未知错误 %s\" % result) 04. 抛出 raise 异常4.1 应用场景 在开发中，除了 代码执行出错 Python 解释器会 抛出 异常之外 还可以根据 应用程序 特有的业务需求 主动抛出异常 示例 提示用户 输入密码，如果 长度少于 8，抛出 异常 ￼ 注意 当前函数 只负责 提示用户输入密码，如果 密码长度不正确，需要其他的函数进行额外处理 因此可以 抛出异常，由其他需要处理的函数 捕获异常 4.2 抛出异常 Python 中提供了一个 Exception 异常类 在开发时，如果满足特定业务需求时，希望 抛出异常，可以： 创建 一个 Exception 的 对象 使用 raise 关键字 抛出 异常对象 需求 定义 input_password 函数，提示用户输入密码 如果用户输入长度 &lt; 8，抛出异常 如果用户输入长度 &gt;=8，返回输入的密码 12345678910111213141516171819202122def input_password(): # 1. 提示用户输入密码 pwd = input(\"请输入密码：\") # 2. 判断密码长度，如果长度 &gt;= 8，返回用户输入的密码 if len(pwd) &gt;= 8: return pwd # 3. 密码长度不够，需要抛出异常 # 1&gt; 创建异常对象 - 使用异常的错误信息字符串作为参数 ex = Exception(\"密码长度不够\") # 2&gt; 抛出异常对象 raise extry: user_pwd = input_password() print(user_pwd)except Exception as result: print(\"发现错误：%s\" % result)","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"10-单例","slug":"10-单例","date":"2020-02-08T07:51:28.000Z","updated":"2020-02-08T08:56:07.302Z","comments":true,"path":"2020/02/08/10-单例/","link":"","permalink":"http://yoursite.com/2020/02/08/10-%E5%8D%95%E4%BE%8B/","excerpt":"单例目标 单例设计模式 __new__ 方法 Python 中的单例","text":"单例目标 单例设计模式 __new__ 方法 Python 中的单例 01. 单例设计模式 设计模式 设计模式 是 前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对 某一特定问题 的成熟的解决方案 使用 设计模式 是为了可重用代码、让代码更容易被他人理解、保证代码可靠性 单例设计模式 目的 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例 每一次执行 类名() 返回的对象，内存地址是相同的 单例设计模式的应用场景 音乐播放 对象 回收站 对象 打印机 对象 …… 02. __new__ 方法 使用 类名() 创建对象时，Python 的解释器 首先 会 调用 __new__ 方法为对象 分配空间 __new__是一个 由object基类提供的内置的静态方法，主要作用有两个： 1) 在内存中为对象 分配空间 2) 返回 对象的引用 Python 的解释器获得对象的 引用 后，将引用作为 第一个参数，传递给 __init__ 方法 重写 __new__ 方法 的代码非常固定！ 重写 __new__ 方法 一定要 return super().__new__(cls) 否则 Python 的解释器 得不到 分配了空间的 对象引用，就不会调用对象的初始化方法 注意：__new__ 是一个静态方法，在调用时需要 主动传递 cls 参数 ￼ 示例代码 123456789101112class MusicPlayer(object): def __new__(cls, *args, **kwargs): # 如果不返回任何结果， return super().__new__(cls) def __init__(self): print(\"初始化音乐播放对象\")player = MusicPlayer()print(player) 03. Python 中的单例 单例—— 让类创建的对象，在系统中只有唯一的一个实例 定义一个 类属性，初始值是 None，用于记录 单例对象的引用 重写 __new__ 方法 如果 类属性 is None，调用父类方法分配空间，并在类属性中记录结果 返回 类属性 中记录的 对象引用 ￼ 12345678910111213class MusicPlayer(object): # 定义类属性记录单例对象引用 instance = None def __new__(cls, *args, **kwargs): # 1. 判断类属性是否已经被赋值 if cls.instance is None: cls.instance = super().__new__(cls) # 2. 返回类属性的单例引用 return cls.instance 只执行一次初始化工作 在每次使用类名()创建对象时，Python的解释器都会自动调用两个方法： __new__ 分配空间 __init__ 对象初始化 在上一小节对 __new__ 方法改造之后，每次都会得到 第一次被创建对象的引用 但是：初始化方法还会被再次调用 需求 让 初始化动作 只被 执行一次 解决办法 定义一个类属性 init_flag 标记是否 执行过初始化动作，初始值为 False 在 __init__ 方法中，判断 init_flag，如果为 False 就执行初始化动作 然后将 init_flag 设置为 True 这样，再次 自动 调用 __init__ 方法时，初始化动作就不会被再次执行 了 12345678910111213141516171819202122232425262728293031class MusicPlayer(object): # 记录第一个被创建对象的引用 instance = None # 记录是否执行过初始化动作 init_flag = False def __new__(cls, *args, **kwargs): # 1. 判断类属性是否是空对象 if cls.instance is None: # 2. 调用父类的方法，为第一个对象分配空间 cls.instance = super().__new__(cls) # 3. 返回类属性保存的对象引用 return cls.instance def __init__(self): if not MusicPlayer.init_flag: print(\"初始化音乐播放器\") MusicPlayer.init_flag = True# 创建多个对象player1 = MusicPlayer()print(player1)player2 = MusicPlayer()print(player2)","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"9-类属性和类方法","slug":"9-类属性和类方法","date":"2020-02-08T07:46:39.000Z","updated":"2020-02-08T08:56:21.164Z","comments":true,"path":"2020/02/08/9-类属性和类方法/","link":"","permalink":"http://yoursite.com/2020/02/08/9-%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95/","excerpt":"类属性和类方法目标 类的结构 类属性和实例属性 类方法和静态方法","text":"类属性和类方法目标 类的结构 类属性和实例属性 类方法和静态方法 01. 类的结构1.1 术语 —— 实例 使用面相对象开发，第 1 步 是设计 类 使用类名()创建对象，创建对象的动作有两步： 1) 在内存中为对象 分配空间 2) 调用初始化方法 __init__ 为 对象初始化 对象创建后，内存 中就有了一个对象的 实实在在 的存在 —— 实例 ￼ 因此，通常也会把： 创建出来的 对象 叫做 类 的 实例 创建对象的 动作 叫做 实例化 对象的属性 叫做 实例属性 对象调用的方法 叫做 实例方法 在程序执行时： 对象各自拥有自己的 实例属性 调用对象方法，可以通过self. 访问自己的属性 调用自己的方法 结论 每一个对象 都有自己 独立的内存空间，保存各自不同的属性 多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用 传递到方法内部 1.2 类是一个特殊的对象 Python 中 一切皆对象： class AAA: 定义的类属于 类对象 obj1 = AAA() 属于 实例对象 在程序运行时，类 同样 会被加载到内存 在 Python 中，类 是一个特殊的对象 —— 类对象 在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例 除了封装实例的属性和方法外，类对象还可以拥有自己的属性和方法 类属性 类方法 通过 类名. 的方式可以 访问类的属性 或者 调用类的方法 ￼ 02. 类属性和实例属性2.1 概念和使用 类属性 就是给 类对象 中定义的 属性 通常用来记录 与这个类相关 的特征 类属性 不会用于记录 具体对象的特征 示例需求 定义一个 工具类 每件工具都有自己的 name 需求 —— 知道使用这个类，创建了多少个工具对象？ ￼ 12345678910111213141516171819class Tool(object): # 使用赋值语句，定义类属性，记录创建工具对象的总数 count = 0 def __init__(self, name): self.name = name # 针对类属性做一个计数+1 Tool.count += 1# 创建工具对象tool1 = Tool(\"斧头\")tool2 = Tool(\"榔头\")tool3 = Tool(\"铁锹\")# 知道使用 Tool 类到底创建了多少个对象?print(\"现在创建了 %d 个工具\" % Tool.count) 2.2 属性的获取机制（科普） 在 Python 中 属性的获取 存在一个 向上查找机制 ￼ 因此，要访问类属性有两种方式： 类名.类属性 对象.类属性 （不推荐） 注意 如果使用 对象.类属性 = 值 赋值语句，只会 给对象添加一个属性，而不会影响到 类属性的值 03. 类方法和静态方法3.1 类方法 类属性就是针对类对象定义的属性 使用 赋值语句 在 class 关键字下方可以定义 类属性 类属性 用于记录 与这个类相关 的特征 类方法就是针对 类对象 定义的方法 在 类方法 内部可以直接访问 类属性 或者调用其他的 类方法 语法如下 123@classmethoddef 类方法名(cls): pass 类方法需要用 修饰器 @classmethod 来标识，告诉解释器这是一个类方法 类方法的第一个参数应该是 cls 由 哪一个类 调用的方法，方法内的 cls 就是 哪一个类的引用 这个参数和 实例方法 的第一个参数是 self 类似 提示 使用其他名称也可以，不过习惯使用 cls 通过 类名. 调用 类方法，调用方法时，不需要传递 cls 参数 在方法内部 可以通过 cls. 访问类的属性 也可以通过 cls. 调用其他的类方法 示例需求 定义一个 工具类 每件工具都有自己的 name 需求 —— 在 类 封装一个 show_tool_count 的类方法，输出使用当前这个类，创建的对象个数 ￼ 1234@classmethoddef show_tool_count(cls): \"\"\"显示工具对象的总数\"\"\" print(\"工具对象的总数 %d\" % cls.count) 在类方法内部，可以直接使用 cls 访问 类属性 或者 调用类方法 3.2 静态方法 在开发时，如果需要在 类 中封装一个方法，这个方法： 既 不需要 访问 实例属性 或者调用 实例方法 也 不需要 访问 类属性 或者调用 类方法 这个时候，可以把这个方法封装成一个 静态方法 语法如下 123@staticmethoddef 静态方法名(): pass 静态方法 需要用 修饰器 @staticmethod 来标识，告诉解释器这是一个静态方法 通过 类名. 调用 静态方法 12345678910111213class Dog(object): # 狗对象计数 dog_count = 0 @staticmethod def run(): # 不需要访问实例属性也不需要访问类属性的方法 print(\"狗在跑...\") def __init__(self, name): self.name = name 3.3 方法综合案例需求 设计一个 Game 类 属性： 定义一个 类属性 top_score 记录游戏的 历史最高分 定义一个 实例属性 player_name 记录 当前游戏的玩家姓名 方法： 静态方法 show_help 显示游戏帮助信息 类方法 show_top_score 显示历史最高分 实例方法 start_game 开始当前玩家的游戏 主程序步骤 1) 查看帮助信息 2) 查看历史最高分 3) 创建游戏对象，开始游戏 ￼ 案例小结 实例方法—— 方法内部需要访问实例属性 实例方法 内部可以使用 类名. 访问类属性 类方法 —— 方法内部 只 需要访问 类属性 静态方法 —— 方法内部，不需要访问 实例属性 和 类属性 提问 如果方法内部 即需要访问 实例属性，又需要访问 类属性，应该定义成什么方法？ 答案 应该定义 实例方法 因为，类只有一个，在 实例方法 内部可以使用 类名. 访问类属性 1234567891011121314151617181920212223242526272829303132333435class Game(object): # 游戏最高分，类属性 top_score = 0 @staticmethod def show_help(): print(\"帮助信息：让僵尸走进房间\") @classmethod def show_top_score(cls): print(\"游戏最高分是 %d\" % cls.top_score) def __init__(self, player_name): self.player_name = player_name def start_game(self): print(\"[%s] 开始游戏...\" % self.player_name) # 使用类名.修改历史最高分 Game.top_score = 999# 1. 查看游戏帮助Game.show_help()# 2. 查看游戏最高分Game.show_top_score()# 3. 创建游戏对象，开始游戏game = Game(\"小明\")game.start_game()# 4. 游戏结束，查看游戏最高分Game.show_top_score()","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"8-多态","slug":"8-多态","date":"2020-02-08T07:34:35.000Z","updated":"2020-02-08T08:56:32.774Z","comments":true,"path":"2020/02/08/8-多态/","link":"","permalink":"http://yoursite.com/2020/02/08/8-%E5%A4%9A%E6%80%81/","excerpt":"多态目标 多态","text":"多态目标 多态 面向对象三大特性 封装根据职责将属性和方法封装到一个抽象的类中 定义类的准则 继承 实现代码的重用，相同的代码不需要重复的编写 设计类的技巧 子类针对自己特有的需求，编写特定的代码 多态 不同的 子类对象 调用相同的 父类方法，产生不同的执行结果 多态 可以 增加代码的灵活度 以 继承 和 重写父类方法 为前提 是调用方法的技巧，不会影响到类的内部设计 ￼ 多态案例演练需求 在Dog类中封装方法game 普通狗只是简单的玩耍 定义XiaoTianDog继承自Dog，并且重写game方法 哮天犬需要在天上玩耍 定义Person类，并且封装一个和狗玩的方法 在方法内部，直接让 狗对象 调用 game 方法 ￼ 案例小结 Person类中只需要让狗对象调用game方法，而不关心具体是什么狗 game 方法是在 Dog 父类中定义的 在程序执行时，传入不同的 狗对象 实参，就会产生不同的执行效果 多态 更容易编写出出通用的代码，做出通用的编程，以适应需求的不断变化！ 12345678910111213141516171819202122232425262728293031323334353637class Dog(object): def __init__(self, name): self.name = name def game(self): print(\"%s 蹦蹦跳跳的玩耍...\" % self.name)class XiaoTianDog(Dog): def game(self): print(\"%s 飞到天上去玩耍...\" % self.name)class Person(object): def __init__(self, name): self.name = name def game_with_dog(self, dog): print(\"%s 和 %s 快乐的玩耍...\" % (self.name, dog.name)) # 让狗玩耍 dog.game()# 1. 创建一个狗对象# wangcai = Dog(\"旺财\")wangcai = XiaoTianDog(\"飞天旺财\")# 2. 创建一个小明对象xiaoming = Person(\"小明\")# 3. 让小明调用和狗玩的方法xiaoming.game_with_dog(wangcai)","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"7-继承","slug":"7-继承","date":"2020-02-08T07:31:06.000Z","updated":"2020-02-08T08:56:41.213Z","comments":true,"path":"2020/02/08/7-继承/","link":"","permalink":"http://yoursite.com/2020/02/08/7-%E7%BB%A7%E6%89%BF/","excerpt":"继承目标 单继承 多继承","text":"继承目标 单继承 多继承 面向对象三大特性 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中 继承 实现代码的重用，相同的代码不需要重复的编写 多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度 01. 单继承1.1 继承的概念、语法和特点继承的概念：子类 拥有 父类 的所有 方法 和 属性 ￼ 1) 继承的语法123class 类名(父类名): pass 子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发 子类 中应该根据 职责，封装 子类特有的 属性和方法 2) 专业术语 Dog 类是 Animal 类的子类，Animal 类是 Dog 类的父类，Dog 类从 Animal 类继承 Dog 类是 Animal 类的派生类，Animal 类是 Dog 类的基类，Dog 类从 Animal 类派生 3) 继承的传递性 C 类从 B 类继承，B 类又从 A 类继承 那么 C 类就具有 B 类和 A 类的所有属性和方法 子类 拥有 父类 以及 父类的父类 中封装的所有 属性 和 方法 提问 哮天犬 能够调用 Cat 类中定义的 catch 方法吗？ 答案 不能，因为 哮天犬 和 Cat 之间没有 继承 关系 1.2 方法的重写 子类 拥有 父类 的所有 方法 和 属性 子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发 应用场景 当 父类 的方法实现不能满足子类需求时，可以对方法进行 重写(override) ￼ 重写 父类方法有两种情况： 覆盖 父类的方法 对父类方法进行 扩展 1) 覆盖父类的方法 如果在开发中，父类的方法实现 和 子类的方法实现，完全不同 就可以使用 覆盖 的方式，在子类中 重新编写 父类的方法实现 具体的实现方式，就相当于在 子类中 定义了一个 和父类同名的方法并且实现 重写之后，在运行时，只会调用 子类中重写的方法，而不再会调用 父类封装的方法 2) 对父类方法进行 扩展 如果在开发中，子类的方法实现中包含父类的方法实现 父类原本封装的方法实现 是 子类方法的一部分 就可以使用扩展的方式 在子类中 重写 父类的方法 在需要的位置使用 super().父类方法 来调用父类方法的执行 代码其他的位置针对子类的需求，编写 子类特有的代码实现 关于 super 在 Python 中 super 是一个 特殊的类 super() 就是使用 super 类创建出来的对象 最常 使用的场景就是在 重写父类方法时，调用 在父类中封装的方法实现 调用父类方法的另外一种方式（知道） 在 Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式： 1父类名.方法(self) 这种方式，目前在 Python 3.x 还支持这种方式 这种方法 不推荐使用，因为一旦 父类发生变化，方法调用位置的 类名 同样需要修改 提示 在开发时，父类名 和 super() 两种方式不要混用 如果使用 当前子类名 调用方法，会形成递归调用，出现死循环 1.3 父类的 私有属性 和 私有方法 子类对象 不能 在自己的方法内部，直接 访问 父类的 私有属性 或 私有方法 子类对象 可以通过 父类 的 公有方法 间接 访问到 私有属性 或 私有方法 私有属性、方法 是对象的隐私，不对外公开，外界 以及 子类 都不能直接访问 私有属性、方法 通常用于做一些内部的事情 示例 ￼ B 的对象不能直接访问 __num2 属性 B 的对象不能在 demo 方法内访问 __num2 属性 B 的对象可以在 demo 方法内，调用父类的 test 方法 父类的 test 方法内部，能够访问 __num2 属性和 __test 方法 02. 多继承概念 子类 可以拥有 多个父类，并且具有 所有父类 的 属性 和 方法 例如：孩子 会继承自己 父亲 和 母亲 的 特性 ￼ 语法 12class 子类名(父类名1, 父类名2...) pass 2.1 多继承的使用注意事项问题的提出 如果 不同的父类 中存在 同名的方法，子类对象 在调用方法时，会调用 哪一个父类中的方法呢？ 提示：开发时，应该尽量避免这种容易产生混淆的情况！ —— 如果 父类之间 存在 同名的属性或者方法，应该 尽量避免 使用多继承 ￼ Python 中的 MRO —— 方法搜索顺序（知道） Python 中针对 类 提供了一个 内置属性 __mro__ 可以查看 方法 搜索顺序 MRO 是 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径 1print(C.__mro__) 输出结果 1(&lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;object&#39;&gt;) 在搜索方法时，是按照 __mro__ 的输出结果 从左至右 的顺序查找的 如果在当前类中 找到方法，就直接执行，不再搜索 如果 没有找到，就查找下一个类 中是否有对应的方法，如果找到，就直接执行，不再搜索 如果找到最后一个类，还没有找到方法，程序报错 2.2 新式类与旧式（经典）类 object 是 Python 为所有对象提供的 基类，提供有一些内置的属性和方法，可以使用 dir 函数查看 新式类：以 object 为基类的类，推荐使用 经典类：不以 object 为基类的类，不推荐使用 在 Python 3.x 中定义类时，如果没有指定父类，会 默认使用 object 作为该类的 基类 —— Python 3.x 中定义的类都是 新式类 在 Python 2.x 中定义类时，如果没有指定父类，则不会以 object 作为 基类 新式类 和 经典类 在多继承时 —— 会影响到方法的搜索顺序 为了保证编写的代码能够同时在 Python 2.x 和 Python 3.x 运行！今后在定义类时，如果没有父类，建议统一继承自 object 12class 类名(object): pass","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"6-私有属性和私有方法","slug":"6-私有属性和私有方法","date":"2020-02-08T07:29:09.000Z","updated":"2020-02-08T08:56:57.477Z","comments":true,"path":"2020/02/08/6-私有属性和私有方法/","link":"","permalink":"http://yoursite.com/2020/02/08/6-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/","excerpt":"私有属性和私有方法","text":"私有属性和私有方法 01. 应用场景及定义方式应用场景 在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到 私有属性 就是 对象 不希望公开的 属性 私有方法 就是 对象 不希望公开的 方法 定义方式 在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线，定义的就是 私有 属性或方法 ￼ 123456789101112131415161718class Women: def __init__(self, name): self.name = name # 不要问女生的年龄 self.__age = 18 def __secret(self): print(\"我的年龄是 %d\" % self.__age)xiaofang = Women(\"小芳\")# 私有属性，外部不能直接访问# print(xiaofang.__age)# 私有方法，外部不能直接调用# xiaofang.__secret() 02. 伪私有属性和私有方法（科普） 提示：在日常开发中，不要使用这种方式，访问对象的 私有属性 或 私有方法 Python 中，并没有 真正意义 的 私有 在给 属性、方法 命名时，实际是对 名称 做了一些特殊处理，使得外界无法访问到 处理方式：在 名称 前面加上 _类名 =&gt; _类名__名称 12345# 私有属性，外部不能直接访问到print(xiaofang._Women__age)# 私有方法，外部不能直接调用xiaofang._Women__secret()","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"5-面向对象封装案例II","slug":"5-面向对象封装案例II","date":"2020-02-08T07:27:10.000Z","updated":"2020-02-08T08:57:12.040Z","comments":true,"path":"2020/02/08/5-面向对象封装案例II/","link":"","permalink":"http://yoursite.com/2020/02/08/5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E6%A1%88%E4%BE%8BII/","excerpt":"面向对象封装案例 II目标 士兵突击案例 身份运算符","text":"面向对象封装案例 II目标 士兵突击案例 身份运算符 封装 封装 是面向对象编程的一大特点 面向对象编程的 第一步 —— 将 属性 和 方法 封装 到一个抽象的 类 中 外界 使用 类 创建 对象，然后 让对象调用方法 对象方法的细节 都被 封装 在 类的内部 一个对象的 属性 可以是 另外一个类创建的对象 01. 士兵突击需求 士兵 许三多 有一把 AK47 士兵 可以 开火 枪 能够 发射 子弹 枪 装填 装填子弹 —— 增加子弹数量 ￼ 1.1 开发枪类shoot 方法需求 1&gt; 判断是否有子弹，没有子弹无法射击 2&gt; 使用 print 提示射击，并且输出子弹数量 123456789101112131415161718192021222324252627282930class Gun: def __init__(self, model): # 枪的型号 self.model = model # 子弹数量 self.bullet_count = 0 def add_bullet(self, count): self.bullet_count += count def shoot(self): # 判断是否还有子弹 if self.bullet_count &lt;= 0: print(\"没有子弹了...\") return # 发射一颗子弹 self.bullet_count -= 1 print(\"%s 发射子弹[%d]...\" % (self.model, self.bullet_count))# 创建枪对象ak47 = Gun(\"ak47\")ak47.add_bullet(50)ak47.shoot() 1.2 开发士兵类 假设：每一个新兵 都 没有枪 定义没有初始值的属性 在定义属性时，如果 不知道设置什么初始值，可以设置为 None None 关键字 表示 什么都没有 表示一个 空对象，没有方法和属性，是一个特殊的常量 可以将 None 赋值给任何一个变量 fire 方法需求 1&gt; 判断是否有枪，没有枪没法冲锋 2&gt; 喊一声口号 3&gt; 装填子弹 4&gt; 射击 12345678910111213141516171819202122232425class Soldier: def __init__(self, name): # 姓名 self.name = name # 枪，士兵初始没有枪 None 关键字表示什么都没有 self.gun = None def fire(self): # 1. 判断士兵是否有枪 if self.gun is None: print(\"[%s] 还没有枪...\" % self.name) return # 2. 高喊口号 print(\"冲啊...[%s]\" % self.name) # 3. 让枪装填子弹 self.gun.add_bullet(50) # 4. 让枪发射子弹 self.gun.shoot() 小结 创建了一个 士兵类，使用到 __init__ 内置方法 在定义属性时，如果 不知道设置什么初始值，可以设置为 None 在 封装的 方法内部，还可以让 自己的 使用其他类创建的对象属性 调用已经 封装好的方法 02. 身份运算符身份运算符用于 比较 两个对象的 内存地址 是否一致 —— 是否是对同一个对象的引用 在 Python 中针对 None 比较时，建议使用 is 判断 运算符 描述 实例 is is 是判断两个标识符是不是引用同一个对象 x is y，类似 id(x) == id(y) is not is not 是判断两个标识符是不是引用不同对象 x is not y，类似 id(a) != id(b) is 与 == 区别：is 用于判断 两个变量 引用对象是否为同一个== 用于判断 引用变量的值 是否相等 123456&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = [1, 2, 3]&gt;&gt;&gt; b is a False&gt;&gt;&gt; b == aTrue","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"4-面向对象封装案例","slug":"4-面向对象封装案例","date":"2020-02-08T07:23:41.000Z","updated":"2020-02-08T08:57:24.338Z","comments":true,"path":"2020/02/08/4-面向对象封装案例/","link":"","permalink":"http://yoursite.com/2020/02/08/4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%B0%81%E8%A3%85%E6%A1%88%E4%BE%8B/","excerpt":"面向对象封装案例目标 封装 小明爱跑步 存放家具","text":"面向对象封装案例目标 封装 小明爱跑步 存放家具 01. 封装 封装 是面向对象编程的一大特点 面向对象编程的 第一步 —— 将 属性 和 方法 封装 到一个抽象的 类 中 外界 使用 类 创建 对象，然后 让对象调用方法 对象方法的细节 都被 封装 在 类的内部 02. 小明爱跑步需求 小明 体重 75.0 公斤 小明每次 跑步 会减肥 0.5 公斤 小明每次 吃东西 体重增加 1 公斤 ￼ 提示：在 对象的方法内部，是可以 直接访问对象的属性 的！ 代码实现： 1234567891011121314151617181920212223242526272829303132class Person: \"\"\"人类\"\"\" def __init__(self, name, weight): self.name = name self.weight = weight def __str__(self): return \"我的名字叫 %s 体重 %.2f 公斤\" % (self.name, self.weight) def run(self): \"\"\"跑步\"\"\" print(\"%s 爱跑步，跑步锻炼身体\" % self.name) self.weight -= 0.5 def eat(self): \"\"\"吃东西\"\"\" print(\"%s 是吃货，吃完这顿再减肥\" % self.name) self.weight += 1xiaoming = Person(\"小明\", 75)xiaoming.run()xiaoming.eat()xiaoming.eat()print(xiaoming) 2.1 小明爱跑步扩展 —— 小美也爱跑步需求 小明 和 小美 都爱跑步 小明 体重 75.0 公斤 小美 体重 45.0 公斤 每次 跑步 都会减少 0.5 公斤 每次 吃东西 都会增加 1 公斤 ￼ 提示 在 对象的方法内部，是可以 直接访问对象的属性 的 同一个类 创建的 多个对象 之间，属性 互不干扰！ ￼ 03. 摆放家具需求 房子(House)有户型、总面积和家具名称列表 新房子没有任何的家具 家具(HouseItem)有名字和占地面积，其中 席梦思(bed) 占地 4 平米 衣柜(chest) 占地 2 平米 餐桌(table) 占地 1.5 平米 将以上三件 家具 添加 到 房子 中 打印房子时，要求输出：户型、总面积、剩余面积、家具名称列表 ￼ 剩余面积 在创建房子对象时，定义一个 剩余面积的属性，初始值和总面积相等 当调用 add_item 方法，向房间 添加家具 时，让 剩余面积 -= 家具面积 思考：应该先开发哪一个类？ 答案 —— 家具类 家具简单 房子要使用到家具，被使用的类，通常应该先开发 3.1 创建家具1234567891011121314151617181920212223class HouseItem: def __init__(self, name, area): \"\"\" :param name: 家具名称 :param area: 占地面积 \"\"\" self.name = name self.area = area def __str__(self): return \"[%s] 占地面积 %.2f\" % (self.name, self.area)# 1. 创建家具bed = HouseItem(\"席梦思\", 4)chest = HouseItem(\"衣柜\", 2)table = HouseItem(\"餐桌\", 1.5)print(bed)print(chest)print(table) 小结 创建了一个 家具类，使用到 __init__ 和 __str__ 两个内置方法 使用 家具类 创建了 三个家具对象，并且 输出家具信息 3.2 创建房间12345678910111213141516171819202122232425262728293031323334353637class House: def __init__(self, house_type, area): \"\"\" :param house_type: 户型 :param area: 总面积 \"\"\" self.house_type = house_type self.area = area # 剩余面积默认和总面积一致 self.free_area = area # 默认没有任何的家具 self.item_list = [] def __str__(self): # Python 能够自动的将一对括号内部的代码连接在一起 return (\"户型：%s\\n总面积：%.2f[剩余：%.2f]\\n家具：%s\" % (self.house_type, self.area, self.free_area, self.item_list)) def add_item(self, item): print(\"要添加 %s\" % item)...# 2. 创建房子对象my_home = House(\"两室一厅\", 60)my_home.add_item(bed)my_home.add_item(chest)my_home.add_item(table)print(my_home) 小结 创建了一个 房子类，使用到 __init__ 和 __str__ 两个内置方法 准备了一个 add_item 方法 准备添加家具 使用 房子类 创建了 一个房子对象 让 房子对象 调用了三次 add_item 方法，将 三件家具 以实参传递到 add_item 内部 3.3 添加家具需求 1&gt; 判断 家具的面积 是否 超过剩余面积，如果超过，提示不能添加这件家具 2&gt; 将 家具的名称 追加到 家具名称列表 中 3&gt; 用 房子的剩余面积 - 家具面积 1234567891011121314def add_item(self, item): print(\"要添加 %s\" % item) # 1. 判断家具面积是否大于剩余面积 if item.area &gt; self.free_area: print(\"%s 的面积太大，不能添加到房子中\" % item.name) return # 2. 将家具的名称追加到名称列表中 self.item_list.append(item.name) # 3. 计算剩余面积 self.free_area -= item.area 3.4 小结 主程序只负责创建 房子 对象和 家具 对象 让 房子 对象调用 add_item 方法 将家具添加到房子中 面积计算、剩余面积、家具列表 等处理都被 封装 到 房子类的内部","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"3-面相对象基础语法","slug":"3-面相对象基础语法","date":"2020-02-08T07:18:30.000Z","updated":"2020-02-08T08:57:35.252Z","comments":true,"path":"2020/02/08/3-面相对象基础语法/","link":"","permalink":"http://yoursite.com/2020/02/08/3-%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"面相对象基础语法目标 dir 内置函数 定义简单的类（只包含方法） 方法中的 self 参数 初始化方法 内置方法和属性","text":"面相对象基础语法目标 dir 内置函数 定义简单的类（只包含方法） 方法中的 self 参数 初始化方法 内置方法和属性 01. dir 内置函数（知道） 在 Python 中 对象几乎是无所不在的，我们之前学习的 变量、数据、函数 都是对象 在 Python 中可以使用以下两个方法验证： 在 标识符 / 数据 后输入一个 .，然后按下 TAB 键，iPython 会提示该对象能够调用的 方法列表 使用内置函数 dir 传入 标识符 / 数据，可以查看对象内的 所有属性及方法 提示 __方法名__ 格式的方法是 Python 提供的 内置方法 / 属性，稍后会给大家介绍一些常用的 内置方法 / 属性 序号 方法名 类型 作用 01 __new__ 方法 创建对象时，会被 自动 调用 02 __init__ 方法 对象被初始化时，会被 自动 调用 03 __del__ 方法 对象被从内存中销毁前，会被 自动 调用 04 __str__ 方法 返回对象的描述信息，print 函数输出使用 提示 利用好 dir() 函数，在学习时很多内容就不需要死记硬背了 02. 定义简单的类（只包含方法） 面向对象 是 更大 的 封装，在 一个类中 封装 多个方法，这样 通过这个类创建出来的对象，就可以直接调用这些方法了！ 2.1 定义只包含方法的类 在 Python 中要定义一个只包含方法的类，语法格式如下： 1234567class 类名: def 方法1(self, 参数列表): pass def 方法2(self, 参数列表): pass 方法 的定义格式和之前学习过的函数 几乎一样 区别在于第一个参数必须是 self，大家暂时先记住，稍后介绍 self 注意：类名 的 命名规则 要符合 大驼峰命名法 2.2 创建对象 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下： 1对象变量 = 类名() 2.3 第一个面向对象程序需求 小猫 爱 吃 鱼，小猫 要 喝 水 分析 定义一个猫类 Cat 定义两个方法 eat 和 drink 按照需求 —— 不需要定义属性 ￼ 123456789101112class Cat: \"\"\"这是一个猫类\"\"\" def eat(self): print(\"小猫爱吃鱼\") def drink(self): print(\"小猫在喝水\")tom = Cat()tom.drink()tom.eat() 引用概念的强调 在面向对象开发中，引用的概念是同样适用的！ 在 Python 中使用类 创建对象之后，tom 变量中 仍然记录的是 对象在内存中的地址 也就是 tom 变量 引用 了 新建的猫对象 使用 print 输出 对象变量，默认情况下，是能够输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示） 提示：在计算机中，通常使用 十六进制 表示 内存地址 十进制 和 十六进制 都是用来表达数字的，只是表示的方式不一样 十进制 和 十六进制 的数字之间可以来回转换 %d 可以以 10 进制 输出数字 %x 可以以 16 进制 输出数字 案例进阶 —— 使用 Cat 类再创建一个对象123lazy_cat = Cat()lazy_cat.eat()lazy_cat.drink() 提问：tom 和 lazy_cat 是同一个对象吗？ 03. 方法中的 self 参数3.1 案例改造 —— 给对象增加属性 在Python中，要给对象设置属性，非常的容易，但是不推荐使用 因为：对象属性的封装应该封装在类的内部 只需要在 类的外部的代码 中直接通过 . 设置一个属性即可 注意：这种方式虽然简单，但是不推荐使用！ 1234tom.name = \"Tom\"...lazy_cat.name = \"大懒猫\" 3.2 使用 self 在方法内部输出每一只猫的名字 由 哪一个对象 调用的方法，方法内的 self 就是 哪一个对象的引用 在类封装的方法内部，self 就表示 当前调用方法的对象自己 调用方法时，程序员不需要传递 self 参数 在方法内部 可以通过 self. 访问对象的属性 也可以通过 self. 调用其他的对象方法 改造代码如下： 123456789101112class Cat: def eat(self): print(\"%s 爱吃鱼\" % self.name)tom = Cat()tom.name = \"Tom\"tom.eat()lazy_cat = Cat()lazy_cat.name = \"大懒猫\"lazy_cat.eat() ￼ 在 类的外部，通过 变量名. 访问对象的 属性和方法 在 类封装的方法中，通过 self. 访问对象的 属性和方法 04. 初始化方法4.1 之前代码存在的问题 —— 在类的外部给对象增加属性 将案例代码进行调整，先调用方法 再设置属性，观察一下执行效果 12345tom = Cat()tom.drink()tom.eat()tom.name = \"Tom\"print(tom) 程序执行报错如下： 12AttributeError: &#39;Cat&#39; object has no attribute &#39;name&#39;属性错误：&#39;Cat&#39; 对象没有 &#39;name&#39; 属性 提示 在日常开发中，不推荐在类的外部给对象增加属性 如果在运行时，没有找到属性，程序会报错 对象应该包含有哪些属性，应该 封装在类的内部 4.2 初始化方法 当使用类名()创建对象时，会自动执行以下操作： 为对象在内存中 分配空间 —— 创建对象 为对象的属性 设置初始值 —— 初始化方法(init) 这个 初始化方法 就是 __init__ 方法，__init__ 是对象的内置方法 __init__ 方法是 专门 用来定义一个类 具有哪些属性的方法！ 在 Cat 中增加 __init__ 方法，验证该方法在创建对象时会被自动调用 12345class Cat: \"\"\"这是一个猫类\"\"\" def __init__(self): print(\"初始化方法\") 4.3 在初始化方法内部定义属性 在 __init__ 方法内部使用 self.属性名 = 属性的初始值 就可以 定义属性 定义属性之后，再使用 Cat 类创建的对象，都会拥有该属性 12345678910111213141516class Cat: def __init__(self): print(\"这是一个初始化方法\") # 定义用 Cat 类创建的猫对象都有一个 name 的属性 self.name = \"Tom\" def eat(self): print(\"%s 爱吃鱼\" % self.name)# 使用类名()创建对象的时候，会自动调用初始化方法 __init__tom = Cat()tom.eat() 4.4 改造初始化方法 —— 初始化的同时设置初始值 在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对__init__方法进行改造 把希望设置的属性值，定义成 __init__ 方法的参数 在方法内部使用 self.属性 = 形参 接收外部传递的参数 在创建对象时，使用 类名(属性1, 属性2...) 调用 123456789101112class Cat: def __init__(self, name): print(\"初始化方法 %s\" % name) self.name = name ... tom = Cat(\"Tom\")...lazy_cat = Cat(\"大懒猫\")... 05. 内置方法和属性 序号 方法名 类型 作用 01 __del__ 方法 对象被从内存中销毁前，会被 自动 调用 02 __str__ 方法 返回对象的描述信息，print 函数输出使用 5.1 __del__ 方法（知道） 在 Python 中 当使用 类名() 创建对象时，为对象 分配完空间后，自动 调用 __init__ 方法 当一个 对象被从内存中销毁 前，会 自动 调用 __del__ 方法 应用场景 __init__ 改造初始化方法，可以让创建对象更加灵活 __del__ 如果希望在对象被销毁前，再做一些事情，可以考虑一下 __del__ 方法 生命周期 一个对象从调用 类名() 创建，生命周期开始 一个对象的 __del__ 方法一旦被调用，生命周期结束 在对象的生命周期内，可以访问对象属性，或者让对象调用方法 1234567891011121314151617181920class Cat: def __init__(self, new_name): self.name = new_name print(\"%s 来了\" % self.name) def __del__(self): print(\"%s 去了\" % self.name)# tom 是一个全局变量tom = Cat(\"Tom\")print(tom.name)# del 关键字可以删除一个对象del tomprint(\"-\" * 50) 5.2 __str__ 方法 在 Python 中，使用 print 输出 对象变量，默认情况下，会输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示） 如果在开发中，希望使用 print 输出 对象变量 时，能够打印 自定义的内容，就可以利用 __str__ 这个内置方法了 注意：__str__ 方法必须返回一个字符串 1234567891011121314151617class Cat: def __init__(self, new_name): self.name = new_name print(\"%s 来了\" % self.name) def __del__(self): print(\"%s 去了\" % self.name) def __str__(self): return \"我是小猫：%s\" % self.nametom = Cat(\"Tom\")print(tom)","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"2-类和对象","slug":"2-类和对象","date":"2020-02-08T07:13:52.000Z","updated":"2020-02-08T08:57:46.807Z","comments":true,"path":"2020/02/08/2-类和对象/","link":"","permalink":"http://yoursite.com/2020/02/08/2-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"类和对象目标 类和对象的概念 类和对象的关系 类的设计","text":"类和对象目标 类和对象的概念 类和对象的关系 类的设计 01. 类和对象的概念类 和 对象 是 面向对象编程的 两个 核心概念 1.1 类 类是对一群具有相同 特征或者行为的事物的一个统称，是抽象的， 不能直接使用 特征 被称为 属性 行为 被称为 方法 类 就相当于制造飞机时的图纸，是一个 模板，是 负责创建对象的 ￼ 1.2 对象 对象 是 由类创建出来的一个具体存在，可以直接使用 由哪一个类创建出来的对象，就拥有在哪一个类中定义的： 属性 方法 对象 就相当于用 图纸 制造 的飞机 在程序开发中，应该 先有类，再有对象 ￼ 02. 类和对象的关系 类是模板，对象 是根据 类 这个模板创建出来的，应该 先有类，再有对象 类只有一个，而对象可以有很多个 不同的对象 之间 属性 可能会各不相同 类 中定义了什么 属性和方法，对象 中就有什么属性和方法，不可能多，也不可能少 03. 类的设计在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！ ￼ 在程序开发中，要设计一个类，通常需要满足一下三个要素： 类名 这类事物的名字，满足大驼峰命名法 属性 这类事物具有什么样的特征 方法 这类事物具有什么样的行为 大驼峰命名法1CapWords 每一个单词的首字母大写 单词与单词之间没有下划线 3.1 类名的确定名词提炼法 分析 整个业务流程，出现的 名词，通常就是找到的类 3.2 属性和方法的确定 对 对象的特征描述，通常可以定义成 属性 对象具有的行为（动词），通常可以定义成 方法 提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑 练习 1需求 小明 今年 18 岁，身高 1.75，每天早上 跑 完步，会去 吃 东西 小美 今年 17 岁，身高 1.65，小美不跑步，小美喜欢 吃 东西 ￼ 练习 2需求 一只 黄颜色 的 狗狗 叫 大黄 看见生人 汪汪叫 看见家人 摇尾巴 ￼","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"1-面向对象(OOP)基本概念","slug":"1-面向对象-OOP-基本概念","date":"2020-02-08T07:11:27.000Z","updated":"2020-02-08T08:58:04.060Z","comments":true,"path":"2020/02/08/1-面向对象-OOP-基本概念/","link":"","permalink":"http://yoursite.com/2020/02/08/1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-OOP-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"面向对象(OOP)基本概念面向对象编程 —— Object Oriented Programming 简写 OOP 目标 了解 面向对象 基本概念","text":"面向对象(OOP)基本概念面向对象编程 —— Object Oriented Programming 简写 OOP 目标 了解 面向对象 基本概念 01. 面向对象基本概念 我们之前学习的编程方式就是 面向过程 的 面相过程 和 面相对象，是两种不同的 编程方式 对比 面向过程 的特点，可以更好地了解什么是 面向对象 1.1 过程和函数（科普） 过程 是早期的一个编程概念 过程 类似于函数，只能执行，但是没有返回值 函数 不仅能执行，还可以返回结果 1.2 面相过程 和 面相对象 基本概念1) 面相过程 —— 怎么做？ 把完成某一个需求的 所有步骤 从头到尾 逐步实现 根据开发需求，将某些 功能独立 的代码 封装 成一个又一个 函数 最后完成的代码，就是顺序地调用 不同的函数 特点 注重 步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 开发复杂项目，没有固定的套路，开发难度很大！ ￼ 2) 面向对象 —— 谁来做？ 相比较函数，面向对象 是 更大 的 封装，根据 职责 在 一个对象中 封装 多个方法 在完成某一个需求前，首先确定 职责 —— 要做的事情（方法） 根据 职责 确定不同的 对象，在 对象 内部封装不同的 方法（多个） 最后完成的代码，就是顺序地让 不同的对象 调用 不同的方法 特点 注重 对象和职责，不同的对象承担不同的职责 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路 需要在面向过程基础上，再学习一些面向对象的语法 ￼","categories":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"17-函数进阶","slug":"17-函数进阶","date":"2020-02-08T07:08:34.000Z","updated":"2020-02-08T09:00:17.472Z","comments":true,"path":"2020/02/08/17-函数进阶/","link":"","permalink":"http://yoursite.com/2020/02/08/17-%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/","excerpt":"函数进阶目标 函数参数和返回值的作用 函数的返回值 进阶 函数的参数 进阶 递归函数","text":"函数进阶目标 函数参数和返回值的作用 函数的返回值 进阶 函数的参数 进阶 递归函数 01. 函数参数和返回值的作用函数根据 有没有参数 以及 有没有返回值，可以 相互组合，一共有 4 种 组合形式 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的！ 如果函数 内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部 如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值 1.1 无参数，无返回值此类函数，不接收参数，也没有返回值，应用场景如下： 只是单纯地做一件事情，例如 显示菜单 在函数内部 针对全局变量进行操作，例如：新建名片，最终结果 记录在全局变量 中 注意： 如果全局变量的数据类型是一个 可变类型，在函数内部可以使用 方法 修改全局变量的内容 —— 变量的引用不会改变 在函数内部，使用赋值语句 才会 修改变量的引用 1.2 无参数，有返回值此类函数，不接收参数，但是有返回值，应用场景如下： 采集数据，例如 温度计，返回结果就是当前的温度，而不需要传递任何的参数 1.3 有参数，无返回值此类函数，接收参数，没有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据 例如 名片管理系统 针对 找到的名片 做 修改、删除 操作 1.4 有参数，有返回值此类函数，接收参数，同时有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据，并且 返回期望的处理结果 例如 名片管理系统 使用 字典默认值 和 提示信息 提示用户输入内容 如果输入，返回输入内容 如果没有输入，返回字典默认值 02. 函数的返回值 进阶 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 问题：一个函数执行后能否返回多个结果？ 示例 —— 温度和湿度测量 假设要开发一个函数能够同时返回当前的温度和湿度 先完成返回温度的功能如下： 1234567891011def measure(): \"\"\"返回当前的温度\"\"\" print(\"开始测量...\") temp = 39 print(\"测量结束...\") return tempresult = measure()print(result) 在利用 元组 在返回温度的同时，也能够返回 湿度 改造如下： 123456789def measure(): \"\"\"返回当前的温度\"\"\" print(\"开始测量...\") temp = 39 wetness = 10 print(\"测量结束...\") return (temp, wetness) 提示：如果一个函数返回的是元组，括号可以省略 技巧 在 Python 中，可以 将一个元组 使用 赋值语句 同时赋值给 多个变量 注意：变量的数量需要和元组中的元素数量保持一致 1result = temp, wetness = measure() 面试题 —— 交换两个数字题目要求 有两个整数变量 a = 6, b = 100 不使用其他变量，交换两个变量的值 解法 1 —— 使用其他变量1234# 解法 1 - 使用临时变量c = bb = aa = c 解法 2 —— 不使用临时变量1234# 解法 2 - 不使用临时变量a = a + bb = a - ba = a - b 解法 3 —— Python 专有，利用元组1a, b = b, a 03. 函数的参数 进阶3.1. 不可变和可变的参数 问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？ —— 不会！ 无论传递的参数是 可变 还是 不可变 只要 针对参数 使用 赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到 外部变量的引用 12345678910111213141516171819def demo(num, num_list): print(\"函数内部\") # 赋值语句 num = 200 num_list = [1, 2, 3] print(num) print(num_list) print(\"函数代码完成\")gl_num = 99gl_list = [4, 5, 6]demo(gl_num, gl_list)print(gl_num)print(gl_list) 问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据 12345678910def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list)gl_list = [6, 7, 8]mutable(gl_list)print(gl_list) 面试题 —— += 在 python 中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用 1234567891011121314151617181920def demo(num, num_list): print(\"函数内部代码\") # num = num + num num += num # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用 # 函数执行结束后，外部数据同样会发生变化 num_list += num_list print(num) print(num_list) print(\"函数代码完成\")gl_num = 9gl_list = [1, 2, 3]demo(gl_num, gl_list)print(gl_num)print(gl_list) 3.2 缺省参数 定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值 函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用 例如：对列表排序的方法 123456789gl_num_list = [6, 3, 9]# 默认就是升序排序，因为这种应用需求更多gl_num_list.sort()print(gl_num_list)# 只有当需要降序排序时，才需要传递 `reverse` 参数gl_num_list.sort(reverse=True)print(gl_num_list) 指定函数的缺省参数 在参数后使用赋值语句，可以指定参数的缺省值 1234567def print_info(name, gender=True): gender_text = \"男生\" if not gender: gender_text = \"女生\" print(\"%s 是 %s\" % (name, gender_text)) 提示 缺省参数，需要使用 最常见的值 作为默认值！ 如果一个参数的值 不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ 缺省参数的注意事项1) 缺省参数的定义位置 必须保证 带有默认值的缺省参数 在参数列表末尾 所以，以下定义是错误的！ 1def print_info(name, gender=True, title): 2) 调用带有多个缺省参数的函数 在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ 1234567891011121314151617181920def print_info(name, title=\"\", gender=True): \"\"\" :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 \"\"\" gender_text = \"男生\" if not gender: gender_text = \"女生\" print(\"%s%s 是 %s\" % (title, name, gender_text))# 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！print_info(\"小明\")print_info(\"老王\", title=\"班长\")print_info(\"小美\", gender=False) 3.3 多值参数（知道）定义支持多值参数的函数 有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组 参数名前增加 两个 * 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * args 是 arguments 的缩写，有变量的含义 kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数 12345678def demo(num, *args, **kwargs): print(num) print(args) print(kwargs)demo(1, 2, 3, 4, 5, name=\"小明\", age=18, gender=True) 提示：多值参数 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码 多值参数案例 —— 计算任意多个数字的和需求 定义一个函数 sum_numbers，可以接收的 任意多个整数 功能要求：将传递的 所有数字累加 并且返回累加结果 12345678910def sum_numbers(*args): num = 0 # 遍历 args 元组顺序求和 for n in args: num += n return numprint(sum_numbers(1, 2, 3)) 元组和字典的拆包（知道） 在调用带有多值参数的函数时，如果希望： 将一个 元组变量，直接传递给 args 将一个 字典变量，直接传递给 kwargs 就可以使用 拆包，简化参数的传递，拆包 的方式是： 在 元组变量前，增加 一个 * 在 字典变量前，增加 两个 * 12345678910111213def demo(*args, **kwargs): print(args) print(kwargs)# 需要将一个元组变量/字典变量传递给函数对应的参数gl_nums = (1, 2, 3)gl_xiaoming = &#123;\"name\": \"小明\", \"age\": 18&#125;# 会把 num_tuple 和 xiaoming 作为元组传递个 args# demo(gl_nums, gl_xiaoming)demo(*gl_nums, **gl_xiaoming) 04. 函数的递归 函数调用自身的 编程技巧 称为递归 4.1 递归函数的特点特点 一个函数 内部 调用自己 函数内部可以调用其他函数，当然在函数内部也可以调用自己 代码特点 函数内部的 代码 是相同的，只是针对 参数 不同，处理的结果不同 当 参数满足一个条件 时，函数不再执行 这个非常重要，通常被称为递归的出口，否则 会出现死循环！ 示例代码 1234567891011def sum_numbers(num): print(num) # 递归的出口很重要，否则会出现死循环 if num == 1: return sum_numbers(num - 1) sum_numbers(3) 4.2 递归案例 —— 计算数字累加需求 定义一个函数 sum_numbers 能够接收一个 num 的整数参数 计算 1 + 2 + … num 的结果 123456789101112def sum_numbers(num): if num == 1: return 1 # 假设 sum_numbers 能够完成 num - 1 的累加 temp = sum_numbers(num - 1) # 函数内部的核心算法就是 两个数字的相加 return num + tempprint(sum_numbers(2)) 提示：递归是一个 编程技巧，初次接触递归会感觉有些吃力！在处理 不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"16-变量进阶","slug":"16-变量进阶","date":"2020-02-08T07:05:34.000Z","updated":"2020-02-08T09:02:10.198Z","comments":true,"path":"2020/02/08/16-变量进阶/","link":"","permalink":"http://yoursite.com/2020/02/08/16-%E5%8F%98%E9%87%8F%E8%BF%9B%E9%98%B6/","excerpt":"变量进阶（理解）目标 变量的引用 可变和不可变类型 局部变量和全局变量","text":"变量进阶（理解）目标 变量的引用 可变和不可变类型 局部变量和全局变量 01. 变量的引用 变量 和 数据 都是保存在 内存 中的 在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 1.1 引用的概念在 Python 中 变量 和 数据 是分开存储的 数据 保存在内存中的一个位置 变量 中保存着数据在内存中的地址 变量 中 记录数据的地址，就叫做 引用 使用 id() 函数可以查看变量中保存数据所在的 内存地址 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 1.2 变量引用 的示例在 Python 中，变量的名字类似于 便签纸 贴在 数据 上 定义一个整数变量 a，并且赋值为 1 代码 图示 a = 1 将变量 a 赋值为 2 代码 图示 a = 2 ) 定义一个整数变量 b，并且将变量 a 的值赋值给 b 代码 图示 b = a 变量 b 是第 2 个贴在数字 2 上的标签 1.3 函数的参数和返回值的传递在 Python 中，函数的 实参/返回值 都是是靠 引用 来传递来的 12345678910111213141516171819def test(num): print(\"-\" * 50) print(\"%d 在函数内的内存地址是 %x\" % (num, id(num))) result = 100 print(\"返回值 %d 在内存中的地址是 %x\" % (result, id(result))) print(\"-\" * 50) return resulta = 10print(\"调用函数前 内存地址是 %x\" % id(a))r = test(a)print(\"调用函数后 实参内存地址是 %x\" % id(a))print(\"调用函数后 返回值内存地址是 %x\" % id(r)) 02. 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict 1234a = 1a = \"hello\"a = [1, 2, 3]a = [3, 2, 1] 1234567891011121314151617181920demo_list = [1, 2, 3]print(\"定义列表后的内存地址 %d\" % id(demo_list))demo_list.append(999)demo_list.pop(0)demo_list.remove(2)demo_list[0] = 10print(\"修改数据后的内存地址 %d\" % id(demo_list))demo_dict = &#123;\"name\": \"小明\"&#125;print(\"定义字典后的内存地址 %d\" % id(demo_dict))demo_dict[\"age\"] = 18demo_dict.pop(\"name\")demo_dict[\"name\"] = \"老王\"print(\"修改数据后的内存地址 %d\" % id(demo_dict)) 注意：字典的 key 只能使用不可变类型的数据 注意 可变类型的数据变化，是通过 方法 来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 接收一个 不可变类型 的数据作为 参数 返回 结果是一个 整数 哈希 是一种 算法，其作用就是提取数据的 特征码（指纹） 相同的内容 得到 相同的结果 不同的内容 得到 不同的结果 在 Python 中，设置字典的 键值对 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便 后续 对字典的操作：增、删、改、查 键值对的 key 必须是不可变类型数据 键值对的 value 可以是任意类型的数据 03. 局部变量和全局变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 3.1 局部变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 函数执行结束后，函数内部的局部变量，会被系统回收 不同的函数，可以定义相同的名字的局部变量，但是 彼此之间 不会产生影响 局部变量的作用 在函数内部使用，临时 保存 函数内部需要使用的数据 123456789101112131415161718192021def demo1(): num = 10 print(num) num = 20 print(\"修改后 %d\" % num)def demo2(): num = 100 print(num)demo1()demo2()print(\"over\") 局部变量的生命周期 所谓 生命周期 就是变量从 被创建 到 被系统回收 的过程 局部变量 在 函数执行时 才会被创建 函数执行结束后 局部变量 被系统回收 局部变量在生命周期 内，可以用来存储 函数内部临时使用到的数据 3.2 全局变量 全局变量 是在 函数外部定义 的变量，所有函数内部都可以使用这个变量 1234567891011121314151617# 定义一个全局变量num = 10def demo1(): print(num)def demo2(): print(num)demo1()demo2()print(\"over\") 注意：函数执行时，需要处理变量时 会： 首先 查找 函数内部 是否存在 指定名称 的局部变量，如果有，直接使用 如果没有，查找 函数外部 是否存在 指定名称 的全局变量，如果有，直接使用 如果还没有，程序报错！ 1) 函数不能直接修改 全局变量的引用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 在函数内部，可以 通过全局变量的引用获取对应的数据 但是，不允许直接修改全局变量的引用 —— 使用赋值语句修改全局变量的值 123456789101112131415161718192021num = 10def demo1(): print(\"demo1\" + \"-\" * 50) # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print(\"demo2\" + \"-\" * 50) print(num)demo1()demo2()print(\"over\") 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值 2) 在函数内部修改全局变量的值 如果在函数中需要修改全局变量，需要使用 global 进行声明 1234567891011121314151617181920212223num = 10def demo1(): print(\"demo1\" + \"-\" * 50) # global 关键字，告诉 Python 解释器 num 是一个全局变量 global num # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num)def demo2(): print(\"demo2\" + \"-\" * 50) print(num)demo1()demo2()print(\"over\") 3) 全局变量定义的位置 为了保证所有的函数都能够正确使用到全局变量，应该 将全局变量定义在其他函数的上方 1234567891011a = 10def demo(): print(\"%d\" % a) print(\"%d\" % b) print(\"%d\" % c)b = 20demo()c = 30 注意 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！ 代码结构示意图如下 4) 全局变量命名的建议 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如： 全局变量名前应该增加 g_ 或者 gl_ 的前缀 提示：具体的要求格式，各公司要求可能会有些差异","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"15-综合应用 —— 名片管理系统","slug":"15-综合应用-——-名片管理系统","date":"2020-02-08T07:03:31.000Z","updated":"2020-02-08T09:02:00.075Z","comments":true,"path":"2020/02/08/15-综合应用-——-名片管理系统/","link":"","permalink":"http://yoursite.com/2020/02/08/15-%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94-%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"综合应用 —— 名片管理系统目标综合应用已经学习过的知识点： 变量 流程控制 函数 模块 开发 名片管理系统","text":"综合应用 —— 名片管理系统目标综合应用已经学习过的知识点： 变量 流程控制 函数 模块 开发 名片管理系统 系统需求 程序启动，显示名片管理系统欢迎界面，并显示功能菜单 123456789**************************************************欢迎使用【名片管理系统】V1.01. 新建名片2. 显示全部3. 查询名片0. 退出系统************************************************** 用户用数字选择不同的功能 根据功能选择，执行不同的功能 用户名片需要记录用户的 姓名、电话、QQ、邮件 如果查询到指定的名片，用户可以选择 修改 或者 删除 名片 步骤 框架搭建 新增名片 显示所有名片 查询名片 查询成功后修改、删除名片 让 Python 程序能够直接运行 01. 框架搭建目标 搭建名片管理系统 框架结构 准备文件，确定文件名，保证能够 在需要的位置 编写代码 编写 主运行循环，实现基本的 用户输入和判断 1.1 文件准备 新建 cards_main.py 保存 主程序功能代码 程序的入口 每一次启动名片管理系统都通过 main 这个文件启动 新建 cards_tools.py 保存 所有名片功能函数 将对名片的 新增、查询、修改、删除 等功能封装在不同的函数中 1.2 编写主运行循环 在 cards_main 中添加一个 无限循环 1234567891011121314151617while True: # TODO(小明) 显示系统菜单 action = input(\"请选择操作功能：\") print(\"您选择的操作是：%s\" % action) # 根据用户输入决定后续的操作 if action in [\"1\", \"2\", \"3\"]: pass elif action == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入\") 字符串判断1if action in [\"1\", \"2\", \"3\"]: 1if action == \"1\" or action == \"2\" or action == \"3\": 使用 in 针对 列表 判断，避免使用 or 拼接复杂的逻辑条件 没有使用 int 转换用户输入，可以避免 一旦用户输入的不是数字，导致程序运行出错 pass pass 就是一个空语句，不做任何事情，一般用做占位语句 是为了保持程序结构的完整性 无限循环 在开发软件时，如果 不希望程序执行后 立即退出 可以在程序中增加一个 无限循环 由用户来决定 退出程序的时机 TODO 注释 在 # 后跟上 TODO，用于标记需要去做的工作 1# TODO(作者/邮件) 显示系统菜单 1.3 在 cards_tools 中增加四个新函数12345678910111213141516171819202122232425262728def show_menu(): \"\"\"显示菜单 \"\"\" passdef new_card(): \"\"\"新建名片 \"\"\" print(\"-\" * 50) print(\"功能：新建名片\")def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\")def search_card(): \"\"\"搜索名片 \"\"\" print(\"-\" * 50) print(\"功能：搜索名片\") 1.4 导入模块 在 cards_main.py 中使用 import 导入 cards_tools 模块 1import cards_tools 修改 while 循环的代码如下： 12345678910111213141516171819202122232425262728import cards_toolswhile True: cards_tools.show_menu() action = input(\"请选择操作功能：\") print(\"您选择的操作是：%s\" % action) # 根据用户输入决定后续的操作 if action in [\"1\", \"2\", \"3\"]: if action == \"1\": cards_tools.new_card() elif action == \"2\": cards_tools.show_all() elif action == \"3\": cards_tools.search_card() elif action == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入：\") 至此：cards_main 中的所有代码全部开发完毕！ 1.5 完成 show_menu 函数12345678910111213def show_menu(): \"\"\"显示菜单 \"\"\" print(\"*\" * 50) print(\"欢迎使用【菜单管理系统】V1.0\") print(\"\") print(\"1. 新建名片\") print(\"2. 显示全部\") print(\"3. 查询名片\") print(\"\") print(\"0. 退出系统\") print(\"*\" * 50) 02. 保存名片数据的结构程序就是用来处理数据的，而变量就是用来存储数据的 使用 字典 记录 每一张名片 的详细信息 使用 列表 统一记录所有的 名片字典 定义名片列表变量 在 cards_tools 文件的顶部增加一个 列表变量 12# 所有名片记录的列表card_list = [] 注意 所有名片相关操作，都需要使用这个列表，所以应该 定义在程序的顶部 程序刚运行时，没有数据，所以是 空列表 03. 新增名片3.1 功能分析 提示用户依次输入名片信息 将名片信息保存到一个字典 将字典添加到名片列表 提示名片添加完成 3.2 实现 new_card 方法 根据步骤实现代码 1234567891011121314151617181920212223242526def new_card(): \"\"\"新建名片 \"\"\" print(\"-\" * 50) print(\"功能：新建名片\") # 1. 提示用户输入名片信息 name = input(\"请输入姓名：\") phone = input(\"请输入电话：\") qq = input(\"请输入 QQ 号码：\") email = input(\"请输入邮箱：\") # 2. 将用户信息保存到一个字典 card_dict = &#123;\"name\": name, \"phone\": phone, \"qq\": qq, \"email\": email&#125; # 3. 将用户字典添加到名片列表 card_list.append(card_dict) print(card_list) # 4. 提示添加成功信息 print(\"成功添加 %s 的名片\" % card_dict[\"name\"]) 技巧：在 PyCharm 中，可以使用 SHIFT + F6 统一修改变量名 04. 显示所有名片4.1 功能分析 循环遍历名片列表，顺序显示每一个字典的信息 4.2 基础代码实现12345678910def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") for card_dict in card_list: print(card_dict) 显示效果不好！ 4.3 增加标题和使用 \\t 显示123456789101112131415161718192021def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") # 打印表头 for name in [\"姓名\", \"电话\", \"QQ\", \"邮箱\"]: print(name, end=\"\\t\\t\") print(\"\") # 打印分隔线 print(\"=\" * 50) for card_dict in card_list: print(\"%s\\t\\t%s\\t\\t%s\\t\\t%s\" % (card_dict[\"name\"], card_dict[\"phone\"], card_dict[\"qq\"], card_dict[\"email\"])) 4.4 增加没有名片记录判断1234567891011def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") # 1. 判断是否有名片记录 if len(card_list) == 0: print(\"提示：没有任何名片记录\") return 注意 在函数中使用 return 表示返回 如果在 return 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码 05. 查询名片5.1 功能分析 提示用户要搜索的姓名 根据用户输入的姓名遍历列表 搜索到指定的名片后，再执行后续的操作 5.2 代码实现 查询功能实现 12345678910111213141516171819202122232425262728293031def search_card(): \"\"\"搜索名片 \"\"\" print(\"-\" * 50) print(\"功能：搜索名片\") # 1. 提示要搜索的姓名 find_name = input(\"请输入要搜索的姓名：\") # 2. 遍历字典 for card_dict in card_list: if card_dict[\"name\"] == find_name: print(\"姓名\\t\\t\\t电话\\t\\t\\tQQ\\t\\t\\t邮箱\") print(\"-\" * 40) print(\"%s\\t\\t\\t%s\\t\\t\\t%s\\t\\t\\t%s\" % ( card_dict[\"name\"], card_dict[\"phone\"], card_dict[\"qq\"], card_dict[\"email\"])) print(\"-\" * 40) # TODO(小明) 针对找到的字典进行后续操作：修改/删除 break else: print(\"没有找到 %s\" % find_name) 增加名片操作函数：修改/删除/返回主菜单 123456789101112131415def deal_card(find_dict): \"\"\"操作搜索到的名片字典 :param find_dict:找到的名片字典 \"\"\" print(find_dict) action_str = input(\"请选择要执行的操作 \" \"[1] 修改 [2] 删除 [0] 返回上级菜单\") if action == \"1\": print(\"修改\") elif action == \"2\": print(\"删除\") 06. 修改和删除6.1 查询成功后删除名片 由于找到的字典记录已经在列表中保存 要删除名片记录，只需要把列表中对应的字典删除即可 1234elif action == \"2\": card_list.remove(find_dict) print(\"删除成功\") 6.2 修改名片 由于找到的字典记录已经在列表中保存 要修改名片记录，只需要把列表中对应的字典中每一个键值对的数据修改即可 12345678if action == \"1\": find_dict[\"name\"] = input(\"请输入姓名：\") find_dict[\"phone\"] = input(\"请输入电话：\") find_dict[\"qq\"] = input(\"请输入QQ：\") find_dict[\"email\"] = input(\"请输入邮件：\") print(\"%s 的名片修改成功\" % find_dict[\"name\"]) 修改名片细化 如果用户在使用时，某些名片内容并不想修改，应该如何做呢？—— 既然系统提供的 input 函数不能满足需求，那么就新定义一个函数 input_card_info 对系统的 input 函数进行扩展 12345678910111213141516171819def input_card_info(dict_value, tip_message): \"\"\"输入名片信息 :param dict_value: 字典原有值 :param tip_message: 输入提示信息 :return: 如果输入，返回输入内容，否则返回字典原有值 \"\"\" # 1. 提示用户输入内容 result_str = input(tip_message) # 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果 if len(result_str) &gt; 0: return result_str # 3. 如果用户没有输入内容，返回 `字典中原有的值` else: return dict_value 07. LINUX 上的 Shebang 符号(#!) #!这个符号叫做 Shebang 或者 Sha-bang Shebang 通常在 Unix 系统脚本的中 第一行开头 使用 指明 执行这个脚本文件 的 解释程序 使用 Shebang 的步骤 使用 which 查询 python3 解释器所在路径 1$ which python3 修改要运行的 主 python 文件，在第一行增加以下内容 1#! /usr/bin/python3 修改 主 python 文件 的文件权限，增加执行权限 1$ chmod +x cards_main.py 在需要时执行程序即可 1./cards_main.py","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"14-高级变量类型","slug":"14-高级变量类型","date":"2020-02-08T07:00:12.000Z","updated":"2020-02-08T08:59:41.788Z","comments":true,"path":"2020/02/08/14-高级变量类型/","link":"","permalink":"http://yoursite.com/2020/02/08/14-%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/","excerpt":"高级变量类型目标 列表 元组 字典 字符串 公共方法 变量高级","text":"高级变量类型目标 列表 元组 字典 字符串 公共方法 变量高级 知识点回顾 Python 中数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 在 Python 中，所有 非数字型变量 都支持以下特点： 都是一个 序列 sequence，也可以理解为 容器 取值 [] 遍历 for in 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 01. 列表1.1 列表的定义 List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组 专门用于存储 一串 信息 列表用 [] 定义，数据 之间使用 , 分隔 列表的 索引 从 0 开始 索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标 注意：从列表中取值时，如果 超出索引范围，程序会报错 1name_list = [\"zhangsan\", \"lisi\", \"wangwu\"] 1.2 列表常用操作 在 ipython3 中定义一个 列表，例如：name_list = [] 输入 name_list. 按下 TAB 键，ipython 会提示 列表 能够使用的 方法 如下： 1234In [1]: name_list.name_list.append name_list.count name_list.insert name_list.reversename_list.clear name_list.extend name_list.pop name_list.sortname_list.copy name_list.index name_list.remove 序号 分类 关键字 / 函数 / 方法 说明 1 增加 列表.insert(索引, 数据) 在指定位置插入数据 | | | 列表.append(数据) | 在末尾追加数据| | | 列表.extend(列表2) | 将列表2 的数据追加到列表 || 2 | 修改 | 列表[索引] = 数据 | 修改指定索引的数据 || 3 | 删除 | del 列表[索引] | 删除指定索引的数据 || | | 列表.remove[数据] | 删除第一个出现的指定数据 || | | 列表.pop | 删除末尾数据 || | | 列表.pop(索引) | 删除指定索引数据 || | | 列表.clear | 清空列表 || 4 | 统计 | len(列表) | 列表长度 || | | 列表.count(数据) | 数据在列表中出现的次数 || 5 | 排序 | 列表.sort() | 升序排序 || | | 列表.sort(reverse=True) | 降序排序 || | | 列表.reverse() | 逆序、反转 | del 关键字（科普） 使用 del 关键字(delete) 同样可以删除列表中元素 del 关键字本质上是用来 将一个变量从内存中删除的 如果使用 del 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了 1del name_list[1] 在日常开发中，要从列表删除数据，建议 使用列表提供的方法 关键字、函数和方法（科普） 关键字 是 Python 内置的、具有特殊意义的标识符 123In [1]: import keywordIn [2]: print(keyword.kwlist)In [3]: print(len(keyword.kwlist)) 关键字后面不需要使用括号 函数 封装了独立功能，可以直接调用 1函数名(参数) 函数需要死记硬背 方法 和函数类似，同样是封装了独立的功能 方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作 1对象.方法名(参数) 在变量后面输入 .，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多 1.3 循环遍历 遍历 就是 从头到尾 依次 从 列表 中获取数据 在 循环体内部 针对 每一个元素，执行相同的操作 在 Python 中为了提高列表的遍历效率，专门提供的 迭代 iteration 遍历 使用 for 就能够实现迭代遍历 12345# for 循环内部使用的变量 in 列表for name in name_list: 循环内部针对列表元素进行操作 print(name) 1.4 应用场景 尽管 Python 的 列表 中可以 存储不同类型的数据 但是在开发中，更多的应用场景是 列表 存储相同类型的数据 通过 迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作 02. 元组2.1 元组的定义 Tuple（元组）与列表类似，不同之处在于元组的 元素不能修改 元组 表示多个元素组成的序列 元组 在 Python 开发中，有特定的应用场景 用于存储 一串 信息，数据 之间使用 , 分隔 元组用 () 定义 元组的 索引 从 0 开始 索引 就是数据在 元组 中的位置编号 1info_tuple = (\"zhangsan\", 18, 1.75) 创建空元组1info_tuple = () 元组中 只包含一个元素 时，需要 在元素后面添加逗号1info_tuple = (50, ) 2.2 元组常用操作 在 ipython3 中定义一个 元组，例如：info = () 输入 info. 按下 TAB 键，ipython 会提示 元组 能够使用的函数如下： 1info.count info.index 有关 元组 的 常用操作 可以参照上图练习 2.3 循环遍历 取值 就是从 元组 中获取存储在指定位置的数据 遍历 就是 从头到尾 依次 从 元组 中获取数据 12345# for 循环内部使用的变量 in 元组for item in info: 循环内部针对元组元素进行操作 print(item) 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典 以及 字符串 提示：在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多 2.4 应用场景 尽管可以使用 for in 遍历 元组 但是在开发中，更多的应用场景是： 函数的 参数 和 返回值，一个函数可以接收 任意多个参数，或者 一次返回多个数据 有关 函数的参数 和 返回值，在后续 函数高级 给大家介绍 格式字符串，格式化字符串后面的 () 本质上就是一个元组 让列表不可以被修改，以保护数据安全 123info = (\"zhangsan\", 18)print(\"%s 的年龄是 %d\" % info) 元组和列表之间的转换 使用 list 函数可以把元组转换成列表 1list(元组) 使用 tuple 函数可以把列表转换成元组 1tuple(列表) 03. 字典3.1 字典的定义 dictionary（字典） 是 除列表以外 Python 之中 最灵活 的数据类型 字典同样可以用来 存储多个数据 通常用于存储 描述一个 物体 的相关信息 和列表的区别 列表 是 有序 的对象集合 字典 是 无序 的对象集合 字典用 {} 定义 字典使用 键值对 存储数据，键值对之间使用 , 分隔 键 key 是索引 值 value 是数据 键 和 值 之间使用 : 分隔 键必须是唯一的 值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组 1234xiaoming = &#123;\"name\": \"小明\", \"age\": 18, \"gender\": True, \"height\": 1.75&#125; 3.2 字典常用操作 在 ipython3 中定义一个 字典，例如：xiaoming = {} 输入 xiaoming. 按下 TAB 键，ipython 会提示 字典 能够使用的函数如下： 12345In [1]: xiaoming.xiaoming.clear xiaoming.items xiaoming.setdefaultxiaoming.copy xiaoming.keys xiaoming.updatexiaoming.fromkeys xiaoming.pop xiaoming.valuesxiaoming.get xiaoming.popitem 有关 字典 的 常用操作 可以参照上图练习 3.3 循环遍历 遍历 就是 依次 从 字典 中获取所有键值对 1234# for 循环内部使用的 `key 的变量` in 字典for k in xiaoming: print(\"%s: %s\" % (k, xiaoming[k])) 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 3.4 应用场景 尽管可以使用 for in 遍历 字典 但是在开发中，更多的应用场景是： 使用 多个键值对，存储 描述一个 物体 的相关信息 —— 描述更复杂的数据信息 将 多个字典 放在 一个列表 中，再进行遍历，在循环体内部针对每一个字典进行 相同的处理 1234567card_list = [&#123;\"name\": \"张三\", \"qq\": \"12345\", \"phone\": \"110\"&#125;, &#123;\"name\": \"李四\", \"qq\": \"54321\", \"phone\": \"10086\"&#125; ] 04. 字符串4.1 字符串的定义 字符串 就是 一串字符，是编程语言中表示文本的数据类型 在 Python 中可以使用 一对双引号 &quot; 或者 一对单引号 &#39; 定义一个字符串 虽然可以使用 \\&quot; 或者 \\&#39; 做字符串的转义，但是在实际开发中： 如果字符串内部需要使用 &quot;，可以使用 &#39; 定义字符串 如果字符串内部需要使用 &#39;，可以使用 &quot; 定义字符串 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始 也可以使用 for 循环遍历 字符串中每一个字符 大多数编程语言都是用 &quot; 来定义字符串 1234string = \"Hello Python\"for c in string: print(c) 4.2 字符串的常用操作 在 ipython3 中定义一个 字符串，例如：hello_str = &quot;&quot; 输入 hello_str. 按下 TAB 键，ipython 会提示 字符串 能够使用的 方法 如下： 12345678910111213141516In [1]: hello_str.hello_str.capitalize hello_str.isidentifier hello_str.rindexhello_str.casefold hello_str.islower hello_str.rjusthello_str.center hello_str.isnumeric hello_str.rpartitionhello_str.count hello_str.isprintable hello_str.rsplithello_str.encode hello_str.isspace hello_str.rstriphello_str.endswith hello_str.istitle hello_str.splithello_str.expandtabs hello_str.isupper hello_str.splitlineshello_str.find hello_str.join hello_str.startswithhello_str.format hello_str.ljust hello_str.striphello_str.format_map hello_str.lower hello_str.swapcasehello_str.index hello_str.lstrip hello_str.titlehello_str.isalnum hello_str.maketrans hello_str.translatehello_str.isalpha hello_str.partition hello_str.upperhello_str.isdecimal hello_str.replace hello_str.zfillhello_str.isdigit hello_str.rfind 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！ 1) 判断类型 - 9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字 string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 2) 查找和替换 - 7 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 3) 大小写转换 - 5 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 4) 文本对齐 - 3 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 5) 去除空白字符 - 3 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 6) 拆分和连接 - 5 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\\r’, ‘\\t’, ‘\\n’ 和空格 string.splitlines() 按照行(‘\\r’, ‘\\n’, ‘\\r\\n’)分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 4.3 字符串的切片 切片 方法适用于 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 1字符串[开始索引:结束索引:步长] 注意： 指定的区间属于 左闭右开 型 [开始索引, 结束索引) =&gt; 开始索引 &gt;= 范围 &lt; 结束索引 从 起始 位开始，到 结束位的前一位 结束（不包含结束位本身) 从头开始，开始索引 数字可以省略，冒号不能省略 到末尾结束，结束索引 数字可以省略，冒号不能省略 步长默认为 1，如果连续切片，数字和冒号都可以省略 索引的顺序和倒序 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引 所谓倒序索引就是 从右向左 计算索引 最右边的索引值是 -1，依次递减 演练需求 截取从 2 ~ 5 位置 的字符串 截取从 2 ~ 末尾 的字符串 截取从 开始 ~ 5 位置 的字符串 截取完整的字符串 从开始位置，每隔一个字符截取字符串 从索引 1 开始，每隔一个取一个 截取从 2 ~ 末尾 - 1 的字符串 截取字符串末尾两个字符 字符串的逆序（面试题） 答案 1234567891011121314151617181920212223242526272829303132num_str &#x3D; &quot;0123456789&quot;# 1. 截取从 2 ~ 5 位置 的字符串print(num_str[2:6])# 2. 截取从 2 ~ &#96;末尾&#96; 的字符串print(num_str[2:])# 3. 截取从 &#96;开始&#96; ~ 5 位置 的字符串print(num_str[:6])# 4. 截取完整的字符串print(num_str[:])# 5. 从开始位置，每隔一个字符截取字符串print(num_str[::2])# 6. 从索引 1 开始，每隔一个取一个print(num_str[1::2])# 倒序切片# -1 表示倒数第一个字符print(num_str[-1])# 7. 截取从 2 ~ &#96;末尾 - 1&#96; 的字符串print(num_str[2:-1])# 8. 截取字符串末尾两个字符print(num_str[-2:])# 9. 字符串的逆序（面试题）print(num_str[::-1]) 05. 公共方法5.1 Python 内置函数Python 包含了以下内置函数： 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 cmp(item1, item2) 比较两个值，-1 小于/0 相等/1 大于 Python 3.x 取消了 cmp 函数 注意 字符串 比较符合以下规则： “0” &lt; “A” &lt; “a” 5.2 切片 描述 Python 表达式 结果 支持的数据类型 切片 “0123456789”[::-2] “97531” 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 5.3 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * [“Hi!”] * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 重复 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 &gt; &gt;= == &lt; &lt;= (1, 2, 3) &lt; (2, 2, 3) True 元素比较 字符串、列表、元组 注意 in 在对 字典 操作时，判断的是 字典的键 in 和 not in 被称为 成员运算符 成员运算符成员运算符用于 测试 序列中是否包含指定的 成员 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意：在对 字典 操作时，判断的是 字典的键 5.4 完整的 for 循环语法 在 Python 中完整的 for 循环 的语法如下： 12345for 变量 in 集合: 循环体代码else: 没有通过 break 退出循环，循环结束后，会执行的代码 应用场景 在 迭代遍历 嵌套的数据类型时，例如 一个列表包含了多个字典 需求：要判断 某一个字典中 是否存在 指定的 值 如果 存在，提示并且退出循环 如果 不存在，在 循环整体结束 后，希望 得到一个统一的提示 123456789101112131415161718192021222324252627282930students = [ &#123;\"name\": \"阿土\", \"age\": 20, \"gender\": True, \"height\": 1.7, \"weight\": 75.0&#125;, &#123;\"name\": \"小美\", \"age\": 19, \"gender\": False, \"height\": 1.6, \"weight\": 45.0&#125;,]find_name = \"阿土\"for stu_dict in students: print(stu_dict) # 判断当前遍历的字典中姓名是否为find_name if stu_dict[\"name\"] == find_name: print(\"找到了\") # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较 breakelse: print(\"没有找到\")print(\"循环结束\")","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"13-函数基础","slug":"13-函数基础","date":"2020-02-08T04:57:16.000Z","updated":"2020-02-08T09:02:26.003Z","comments":true,"path":"2020/02/08/13-函数基础/","link":"","permalink":"http://yoursite.com/2020/02/08/13-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/","excerpt":"函数基础目标 函数的快速体验 函数的基本使用 函数的参数 函数的返回值 函数的嵌套调用 在模块中定义函数","text":"函数基础目标 函数的快速体验 函数的基本使用 函数的参数 函数的返回值 函数的嵌套调用 在模块中定义函数 01. 函数的快速体验1.1 快速体验 所谓函数，就是把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的使用包含两个步骤： 定义函数 —— 封装 独立的功能 调用函数 —— 享受 封装 的成果 函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的 重用 演练步骤 新建 04_函数 项目 复制之前完成的 乘法表 文件 修改文件，增加函数定义 multiple_table(): 新建另外一个文件，使用 import 导入并且调用函数 02. 函数基本使用2.1 函数的定义定义函数的格式如下： 1234def 函数名(): 函数封装的代码 …… def 是英文 define 的缩写 函数名称 应该能够表达 函数封装代码 的功能，方便后续的调用 函数名称 的命名应该 符合 标识符的命名规则 可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 2.2 函数调用调用函数很简单的，通过 函数名() 即可完成对函数的调用 2.3 第一个函数演练需求 编写一个打招呼 say_hello 的函数，封装三行打招呼的代码 在函数下方调用打招呼的代码 123456789101112131415name = \"小明\"# 解释器知道这里定义了一个函数def say_hello(): print(\"hello 1\") print(\"hello 2\") print(\"hello 3\")print(name)# 只有在调用函数时，之前定义的函数才会被执行# 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码say_hello()print(name) 用 单步执行 F8 和 F7 观察以下代码的执行过程 定义好函数之后，只表示这个函数封装了一段代码而已 如果不主动调用函数，函数是不会主动执行的 思考 能否将 函数调用 放在 函数定义 的上方？ 不能！ 因为在 使用函数名 调用函数之前，必须要保证 Python 已经知道函数的存在 否则控制台会提示 NameError: name &#39;say_hello&#39; is not defined (名称错误：say_hello 这个名字没有被定义) 2.4 PyCharm 的调试工具 F8 Step Over 可以单步执行代码，会把函数调用看作是一行代码直接执行 F7 Step Into 可以单步执行代码，如果是函数，会进入函数内部 2.5 函数的文档注释 在开发中，如果希望给函数添加注释，应该在 定义函数 的下方，使用 连续的三对引号 在 连续的三对引号 之间编写对函数的说明文字 在 函数调用 位置，使用快捷键 CTRL + Q 可以查看函数的说明信息 注意：因为 函数体相对比较独立，函数定义的上方，应该和其他代码（包括注释）保留 两个空行 03. 函数的参数演练需求 开发一个 sum_2_num 的函数 函数能够实现 两个数字的求和 功能 演练代码如下： 123456789def sum_2_num(): num1 = 10 num2 = 20 result = num1 + num2 print(\"%d + %d = %d\" % (num1, num2, result))sum_2_num() 思考一下存在什么问题 函数只能处理 固定数值 的相加 如何解决？ 如果能够把需要计算的数字，在调用函数时，传递到函数内部就好了！ 3.1 函数参数的使用 在函数名的后面的小括号内部填写 参数 多个参数之间使用 , 分隔 1234567def sum_2_num(num1, num2): result = num1 + num2 print(\"%d + %d = %d\" % (num1, num2, result))sum_2_num(50, 20) 3.2 参数的作用 函数，把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的参数，增加函数的 通用性，针对 相同的数据处理逻辑，能够 适应更多的数据 在函数 内部，把参数当做 变量 使用，进行需要的数据处理 函数调用时，按照函数定义的参数顺序，把 希望在函数内部处理的数据，通过参数 传递 3.3 形参和实参 形参：定义 函数时，小括号中的参数，是用来接收参数用的，在函数内部 作为变量使用 实参：调用 函数时，小括号中的参数，是用来把数据传递到 函数内部 用的 04. 函数的返回值 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 注意：return 表示返回，后续的代码都不会被执行 123456789def sum_2_num(num1, num2): \"\"\"对两个数字的求和\"\"\" return num1 + num2# 调用函数，并使用 result 变量接收计算结果result = sum_2_num(10, 20)print(\"计算结果是 %d\" % result) 05. 函数的嵌套调用 一个函数里面 又调用 了 另外一个函数，这就是 函数嵌套调用 如果函数 test2 中，调用了另外一个函数 test1 那么执行到调用 test1 函数时，会先把函数 test1 中的任务都执行完 才会回到 test2 中调用函数 test1 的位置，继续执行后续的代码 1234567891011121314151617def test1(): print(\"*\" * 50) print(\"test 1\") print(\"*\" * 50)def test2(): print(\"-\" * 50) print(\"test 2\") test1() print(\"-\" * 50)test2() 函数嵌套的演练 —— 打印分隔线 体会一下工作中 需求是多变 的 需求 1 定义一个 print_line 函数能够打印 * 组成的 一条分隔线 123def print_line(char): print(\"*\" * 50) 需求 2 定义一个函数能够打印 由任意字符组成 的分隔线 123def print_line(char): print(char * 50) 需求 3 定义一个函数能够打印 任意重复次数 的分隔线 123def print_line(char, times): print(char * times) 需求 4 定义一个函数能够打印 5 行 的分隔线，分隔线要求符合需求 3 提示：工作中针对需求的变化，应该冷静思考，不要轻易修改之前已经完成的，能够正常执行的函数！ 12345678910111213def print_line(char, times): print(char * times)def print_lines(char, times): row = 0 while row &lt; 5: print_line(char, times) row += 1 06. 使用模块中的函数 模块是 Python 程序架构的一个核心概念 模块 就好比是 工具包，要想使用这个工具包中的工具，就需要 导入 import 这个模块 每一个以扩展名 py 结尾的 Python 源代码文件都是一个 模块 在模块中定义的 全局变量 、 函数 都是模块能够提供给外界直接使用的工具 6.1 第一个模块体验步骤 新建 hm_10_分隔线模块.py 复制 hm_09_打印多条分隔线.py 中的内容，最后一行 print 代码除外 增加一个字符串变量 1name = \"黑马程序员\" 新建 hm_10_体验模块.py 文件，并且编写以下代码： 1234import hm_10_分隔线模块hm_10_分隔线模块.print_line(\"-\", 80)print(hm_10_分隔线模块.name) 体验小结 可以 在一个 Python 文件 中 定义 变量 或者 函数 然后在 另外一个文件中 使用 import 导入这个模块 导入之后，就可以使用 模块名.变量 / 模块名.函数 的方式，使用这个模块中定义的变量或者函数 模块可以让 曾经编写过的代码 方便的被 复用！ 6.2 模块名也是一个标识符 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 注意：如果在给 Python 文件起名时，以数字开头 是无法在 PyCharm 中通过导入这个模块的 6.3 Pyc 文件（了解） C 是 compiled 编译过 的意思 操作步骤 浏览程序目录会发现一个 __pycache__ 的目录 目录下会有一个 hm_10_分隔线模块.cpython-35.pyc 文件，cpython-35 表示 Python 解释器的版本 这个 pyc 文件是由 Python 解释器将 模块的源码 转换为 字节码 Python 这样保存 字节码 是作为一种启动 速度的优化 字节码 Python 在解释源程序时是分成两个步骤的 首先处理源代码，编译 生成一个二进制 字节码 再对 字节码 进行处理，才会生成 CPU 能够识别的 机器码 有了模块的字节码文件之后，下一次运行程序时，如果在 上次保存字节码之后 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤 当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建 提示：有关模块以及模块的其他导入方式，后续课程还会逐渐展开！ 模块是 Python 程序架构的一个核心概念","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"12-循环","slug":"12-循环","date":"2020-02-08T04:52:50.000Z","updated":"2020-02-08T08:59:16.377Z","comments":true,"path":"2020/02/08/12-循环/","link":"","permalink":"http://yoursite.com/2020/02/08/12-%E5%BE%AA%E7%8E%AF/","excerpt":"循环目标 程序的三大流程 while 循环基本使用 break 和 continue while 循环嵌套","text":"循环目标 程序的三大流程 while 循环基本使用 break 和 continue while 循环嵌套 01. 程序的三大流程 在程序开发中，一共有三种流程方式： 顺序 —— 从上向下，顺序执行代码 分支 —— 根据条件判断，决定执行代码的 分支 循环 —— 让 特定代码 重复 执行 02. while 循环基本使用 循环的作用就是让 指定的代码 重复的执行 while 循环最常用的应用场景就是 让执行的代码 按照 指定的次数 重复 执行 需求 —— 打印 5 遍 Hello Python 思考 —— 如果要求打印 100 遍怎么办？ 2.1 while 语句基本语法123456789初始条件设置 —— 通常是重复执行的 计数器while 条件(判断 计数器 是否达到 目标次数): 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件(计数器 + 1) 注意： while 语句以及缩进部分是一个 完整的代码块 第一个 while 循环需求 打印 5 遍 Hello Python 123456789101112# 1. 定义重复次数计数器i &#x3D; 1# 2. 使用 while 判断条件while i &lt;&#x3D; 5: # 要重复执行的代码 print(&quot;Hello Python&quot;) # 处理计数器 i i &#x3D; i + 1print(&quot;循环结束后的 i &#x3D; %d&quot; % i) 注意：循环结束后，之前定义的计数器条件的数值是依旧存在的 死循环 由于程序员的原因，忘记 在循环内部 修改循环的判断条件，导致循环持续执行，程序无法终止！ 2.2 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c *= a 等效于 c = c * a 2.3 Python 中的计数方法常见的计数方法有两种，可以分别称为： 自然计数法（从 1 开始）—— 更符合人类的习惯 程序计数法（从 0 开始）—— 几乎所有的程序语言都选择从 0 开始计数 因此，大家在编写程序时，应该尽量养成习惯：除非需求的特殊要求，否则 循环 的计数都从 0 开始 2.4 循环计算 在程序开发中，通常会遇到 利用循环 重复计算 的需求 遇到这种需求，可以： 在 while 上方定义一个变量，用于 存放最终计算结果 在循环体内部，每次循环都用 最新的计算结果，更新 之前定义的变量 需求 计算 0 ~ 100 之间所有数字的累计求和结果 123456789101112131415161718# 计算 0 ~ 100 之间所有数字的累计求和结果# 0. 定义最终结果的变量result = 0# 1. 定义一个整数的变量记录循环的次数i = 0# 2. 开始循环while i &lt;= 100: print(i) # 每一次循环，都让 result 这个变量和 i 这个计数器相加 result += i # 处理计数器 i += 1print(\"0~100之间的数字求和结果 = %d\" % result) 需求进阶 计算 0 ~ 100 之间 所有 偶数 的累计求和结果 开发步骤 编写循环 确认 要计算的数字 添加 结果 变量，在循环内部 处理计算结果 123456789101112131415161718# 0. 最终结果result = 0# 1. 计数器i = 0# 2. 开始循环while i &lt;= 100: # 判断偶数 if i % 2 == 0: print(i) result += i # 处理计数器 i += 1print(\"0~100之间偶数求和结果 = %d\" % result) 03. break 和 continue break 和 continue 是专门在循环中使用的关键字 break 某一条件满足时，退出循环，不再执行后续重复的代码 continue 某一条件满足时，不执行后续重复的代码 break 和 continue 只针对 当前所在循环 有效 3.1 break 在循环过程中，如果 某一个条件满足后，不 再希望 循环继续执行，可以使用 break 退出循环 1234567891011121314i = 0while i &lt; 10: # break 某一条件满足时，退出循环，不再执行后续重复的代码 # i == 3 if i == 3: break print(i) i += 1print(\"over\") break 只针对当前所在循环有效 3.2 continue 在循环过程中，如果 某一个条件满足后，不 希望 执行循环代码，但是又不希望退出循环，可以使用 continue 也就是：在整个循环中，只有某些条件，不需要执行循环代码，而其他条件都需要执行 12345678910111213141516i = 0while i &lt; 10: # 当 i == 7 时，不希望执行需要重复执行的代码 if i == 7: # 在使用 continue 之前，同样应该修改计数器 # 否则会出现死循环 i += 1 continue # 重复执行的代码 print(i) i += 1 需要注意：使用 continue 时，条件处理部分的代码，需要特别注意，不小心会出现 死循环 continue 只针对当前所在循环有效 04. while 循环嵌套4.1 循环嵌套 while 嵌套就是：while 里面还有 while 123456789101112131415while 条件 1: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... while 条件 2: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件 2 处理条件 1 4.2 循环嵌套演练 —— 九九乘法表第 1 步：用嵌套打印小星星需求 在控制台连续输出五行 *，每一行星号的数量依次递增 12345*************** 使用字符串 * 打印 12345678# 1. 定义一个计数器变量，从数字1开始，循环会比较方便row = 1while row &lt;= 5: print(\"*\" * row) row += 1 第 2 步：使用循环嵌套打印小星星知识点 对 print 函数的使用做一个增强 在默认情况下，print 函数输出内容之后，会自动在内容末尾增加换行 如果不希望末尾增加换行，可以在 print 函数输出内容的后面增加 , end=&quot;&quot; 其中 &quot;&quot; 中间可以指定 print 函数输出内容之后，继续希望显示的内容 语法格式如下： 12345# 向控制台输出内容结束之后，不会换行print(\"*\", end=\"\")# 单纯的换行print(\"\") end=&quot;&quot; 表示向控制台输出内容结束之后，不会换行 假设 Python 没有提供 字符串的 * 操作 拼接字符串 需求 在控制台连续输出五行 *，每一行星号的数量依次递增 12345*************** 开发步骤 1&gt; 完成 5 行内容的简单输出 2&gt; 分析每行内部的 * 应该如何处理？ 每行显示的星星和当前所在的行数是一致的 嵌套一个小的循环，专门处理每一行中 列 的星星显示 1234567891011121314151617row = 1while row &lt;= 5: # 假设 python 没有提供字符串 * 操作 # 在循环内部，再增加一个循环，实现每一行的 星星 打印 col = 1 while col &lt;= row: print(\"*\", end=\"\") col += 1 # 每一行星号输出完成后，再增加一个换行 print(\"\") row += 1 第 3 步： 九九乘法表需求 输出 九九乘法表，格式如下： 1234567891 * 1 &#x3D; 1 1 * 2 &#x3D; 2 2 * 2 &#x3D; 4 1 * 3 &#x3D; 3 2 * 3 &#x3D; 6 3 * 3 &#x3D; 9 1 * 4 &#x3D; 4 2 * 4 &#x3D; 8 3 * 4 &#x3D; 12 4 * 4 &#x3D; 16 1 * 5 &#x3D; 5 2 * 5 &#x3D; 10 3 * 5 &#x3D; 15 4 * 5 &#x3D; 20 5 * 5 &#x3D; 25 1 * 6 &#x3D; 6 2 * 6 &#x3D; 12 3 * 6 &#x3D; 18 4 * 6 &#x3D; 24 5 * 6 &#x3D; 30 6 * 6 &#x3D; 36 1 * 7 &#x3D; 7 2 * 7 &#x3D; 14 3 * 7 &#x3D; 21 4 * 7 &#x3D; 28 5 * 7 &#x3D; 35 6 * 7 &#x3D; 42 7 * 7 &#x3D; 49 1 * 8 &#x3D; 8 2 * 8 &#x3D; 16 3 * 8 &#x3D; 24 4 * 8 &#x3D; 32 5 * 8 &#x3D; 40 6 * 8 &#x3D; 48 7 * 8 &#x3D; 56 8 * 8 &#x3D; 64 1 * 9 &#x3D; 9 2 * 9 &#x3D; 18 3 * 9 &#x3D; 27 4 * 9 &#x3D; 36 5 * 9 &#x3D; 45 6 * 9 &#x3D; 54 7 * 9 &#x3D; 63 8 * 9 &#x3D; 72 9 * 9 &#x3D; 81 开发步骤 打印 9 行小星星 123456789********************************************* 将每一个 * 替换成对应的行与列相乘 1234567891011121314151617181920212223# 定义起始行row = 1# 最大打印 9 行while row &lt;= 9: # 定义起始列 col = 1 # 最大打印 row 列 while col &lt;= row: # end = \"\"，表示输出结束后，不换行 # \"\\t\" 可以在控制台输出一个制表符，协助在输出文本时对齐 print(\"%d * %d = %d\" % (col, row, row * col), end=\"\\t\") # 列数 + 1 col += 1 # 一行打印完成的换行 print(\"\") # 行数 + 1 row += 1 字符串中的转义字符 \\t 在控制台输出一个 制表符，协助在输出文本时 垂直方向 保持对齐 \\n 在控制台输出一个 换行符 制表符 的功能是在不使用表格的情况下在 垂直方向 按列对齐文本 转义字符 描述 \\\\ 反斜杠符号 \\‘ 单引号 \\“ 双引号 \\n 换行 \\t 横向制表符 \\r 回车","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"11-运算符","slug":"11-运算符","date":"2020-02-08T04:51:44.000Z","updated":"2020-02-08T08:59:02.256Z","comments":true,"path":"2020/02/08/11-运算符/","link":"","permalink":"http://yoursite.com/2020/02/08/11-%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"运算符目标 算数运算符 比较（关系）运算符 逻辑运算符 赋值运算符 运算符的优先级","text":"运算符目标 算数运算符 比较（关系）运算符 逻辑运算符 赋值运算符 运算符的优先级 数学符号表链接：https://zh.wikipedia.org/wiki/数学符号表 01. 算数运算符 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 12In [1]: \"-\" * 50Out[1]: '----------------------------------------' 02. 比较（关系）运算符 运算符 描述 == 检查两个操作数的值是否 相等，如果是，则条件成立，返回 True != 检查两个操作数的值是否 不相等，如果是，则条件成立，返回 True &gt; 检查左操作数的值是否 大于 右操作数的值，如果是，则条件成立，返回 True &lt; 检查左操作数的值是否 小于 右操作数的值，如果是，则条件成立，返回 True &gt;= 检查左操作数的值是否 大于或等于 右操作数的值，如果是，则条件成立，返回 True &lt;= 检查左操作数的值是否 小于或等于 右操作数的值，如果是，则条件成立，返回 True Python 2.x 中判断 不等于 还可以使用 &lt;&gt; 运算符 != 在 Python 2.x 中同样可以用来判断 不等于 03. 逻辑运算符 运算符 逻辑表达式 描述 and x and y 只有 x 和 y 的值都为 True，才会返回 True否则只要 x 或者 y 有一个值为 False，就返回 False or x or y 只要 x 或者 y 有一个值为 True，就返回 True只有 x 和 y 的值都为 False，才会返回 False not not x 如果 x 为 True，返回 False如果 x 为 False，返回 True 04. 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c *= a 等效于 c = c * a 05. 运算符的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 &lt;= &lt; &gt; &gt;= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 not or and 逻辑运算符","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"10-判断if语句","slug":"10-判断if语句","date":"2020-02-08T04:49:30.000Z","updated":"2020-02-08T08:58:45.205Z","comments":true,"path":"2020/02/08/10-判断if语句/","link":"","permalink":"http://yoursite.com/2020/02/08/10-%E5%88%A4%E6%96%ADif%E8%AF%AD%E5%8F%A5/","excerpt":"判断（if）语句目标 开发中的应用场景 if 语句体验 if 语句进阶 综合应用","text":"判断（if）语句目标 开发中的应用场景 if 语句体验 if 语句进阶 综合应用 01. 开发中的应用场景生活中的判断几乎是无所不在的，我们每天都在做各种各样的选择，如果这样？如果那样？…… 程序中的判断 1234567891011121314if 今天发工资: 先还信用卡的钱 if 有剩余: 又可以happy了，O(∩_∩)O哈哈~ else: 噢，no。。。还的等30天else: 盼着发工资 判断的定义 如果 条件满足，才能做某件事情， 如果 条件不满足，就做另外一件事情，或者什么也不做 正是因为有了判断，才使得程序世界丰富多彩，充满变化！ 判断语句 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支 02. if 语句体验2.1 if 判断语句基本语法在 Python 中，if 语句 就是用来进行判断的，格式如下： 123if 要判断的条件: 条件成立时，要做的事情 …… 注意：代码的缩进为一个 tab 键，或者 4 个空格 —— 建议使用空格 在 Python 开发中，Tab 和空格不要混用！ 我们可以把整个 if 语句看成一个完整的代码块 2.2 判断语句演练 —— 判断年龄需求 定义一个整数变量记录年龄 判断是否满 18 岁 （&gt;=） 如果满 18 岁，允许进网吧嗨皮 12345678910# 1. 定义年龄变量age = 18# 2. 判断是否满 18 岁# if 语句以及缩进部分的代码是一个完整的代码块if age &gt;= 18: print(\"可以进网吧嗨皮……\")# 3. 思考！- 无论条件是否满足都会执行print(\"这句代码什么时候执行?\") 注意： if 语句以及缩进部分是一个 完整的代码块 2.3 else 处理条件不满足的情况思考 在使用 if 判断时，只能做到满足条件时要做的事情。那如果需要在 不满足条件的时候，做某些事情，该如何做呢？ 答案 else，格式如下： 123456if 要判断的条件: 条件成立时，要做的事情 ……else: 条件不成立时，要做的事情 …… 注意： if 和 else 语句以及各自的缩进部分共同是一个 完整的代码块 2.4 判断语句演练 —— 判断年龄改进需求 输入用户年龄 判断是否满 18 岁 （&gt;=） 如果满 18 岁，允许进网吧嗨皮 如果未满 18 岁，提示回家写作业 123456789101112# 1. 输入用户年龄age = int(input(\"今年多大了？\"))# 2. 判断是否满 18 岁# if 语句以及缩进部分的代码是一个完整的语法块if age &gt;= 18: print(\"可以进网吧嗨皮……\")else: print(\"你还没长大，应该回家写作业！\")# 3. 思考！- 无论条件是否满足都会执行print(\"这句代码什么时候执行?\") 03. 逻辑运算 在程序开发中，通常 在判断条件时，会需要同时判断多个条件 只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 逻辑运算符 逻辑运算符 可以把 多个条件 按照 逻辑 进行 连接，变成 更复杂的条件 Python 中的 逻辑运算符 包括：与 and／或 or／非 not 三种 3.1 and1条件1 and 条件2 与／并且 两个条件同时满足，返回 True 只要有一个不满足，就返回 False 条件 1 条件 2 结果 成立 成立 成立 成立 不成立 不成立 不成立 成立 不成立 不成立 不成立 不成立 3.2 or1条件1 or 条件2 或／或者 两个条件只要有一个满足，返回 True 两个条件都不满足，返回 False 条件 1 条件 2 结果 成立 成立 成立 成立 不成立 成立 不成立 成立 成立 不成立 不成立 不成立 3.3 not1not 条件 非／不是 条件 结果 成立 不成立 不成立 成立 逻辑运算演练 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确 要求人的年龄在 0-120 之间 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩 要求只要有一门成绩 &gt; 60 分就算合格 练习3: 定义一个布尔型变量 is_employee，编写代码判断是否是本公司员工 如果不是提示不允许入内 答案 1： 12345678# 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确age = 100# 要求人的年龄在 0-120 之间if age &gt;= 0 and age &lt;= 120: print(\"年龄正确\")else: print(\"年龄不正确\") 答案 2： 123456789# 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩python_score = 50c_score = 50# 要求只要有一门成绩 &gt; 60 分就算合格if python_score &gt; 60 or c_score &gt; 60: print(\"考试通过\")else: print(\"再接再厉！\") 答案 3： 123456# 练习3: 定义一个布尔型变量 `is_employee`，编写代码判断是否是本公司员工is_employee = True# 如果不是提示不允许入内if not is_employee: print(\"非公勿内\") 04. if 语句进阶4.1 elif 在开发中，使用 if 可以 判断条件 使用 else 可以处理 条件不成立 的情况 但是，如果希望 再增加一些条件，条件不同，需要执行的代码也不同 时，就可以使用 elif 语法格式如下： 123456789101112if 条件1: 条件1满足执行的代码 ……elif 条件2: 条件2满足时，执行的代码 ……elif 条件3: 条件3满足时，执行的代码 ……else: 以上条件都不满足时，执行的代码 …… 对比逻辑运算符的代码 123if 条件1 and 条件2: 条件1满足 并且 条件2满足 执行的代码 …… 注意 elif 和 else 都必须和 if 联合使用，而不能单独使用 可以将 if、elif 和 else 以及各自缩进的代码，看成一个 完整的代码块 elif 演练 —— 女友的节日需求 定义 holiday_name 字符串变量记录节日名称 如果是 情人节 应该 买玫瑰／看电影 如果是 平安夜 应该 买苹果／吃大餐 如果是 生日 应该 买蛋糕 其他的日子每天都是节日啊…… 123456789101112holiday_name &#x3D; &quot;平安夜&quot;if holiday_name &#x3D;&#x3D; &quot;情人节&quot;: print(&quot;买玫瑰&quot;) print(&quot;看电影&quot;)elif holiday_name &#x3D;&#x3D; &quot;平安夜&quot;: print(&quot;买苹果&quot;) print(&quot;吃大餐&quot;)elif holiday_name &#x3D;&#x3D; &quot;生日&quot;: print(&quot;买蛋糕&quot;)else: print(&quot;每天都是节日啊……&quot;) 4.2 if 的嵌套 elif 的应用场景是：同时 判断 多个条件，所有的条件是 平级 的 在开发中，使用 if 进行条件判断，如果希望 在条件成立的执行语句中 再 增加条件判断，就可以使用 if 的嵌套 if 的嵌套 的应用场景就是：在之前条件满足的前提下，再增加额外的判断 if 的嵌套 的语法格式，除了缩进之外 和之前的没有区别 语法格式如下： 12345678910111213141516if 条件 1: 条件 1 满足执行的代码 …… if 条件 1 基础上的条件 2: 条件 2 满足时，执行的代码 …… # 条件 2 不满足的处理 else: 条件 2 不满足时，执行的代码 # 条件 1 不满足的处理else: 条件1 不满足时，执行的代码 …… if 的嵌套 演练 —— 火车站安检需求 定义布尔型变量 has_ticket 表示是否有车票 定义整型变量 knife_length 表示刀的长度，单位：厘米 首先检查是否有车票，如果有，才允许进行 安检 安检时，需要检查刀的长度，判断是否超过 20 厘米 如果超过 20 厘米，提示刀的长度，不允许上车 如果不超过 20 厘米，安检通过 如果没有车票，不允许进门 123456789101112131415161718192021# 定义布尔型变量 has_ticket 表示是否有车票has_ticket = True# 定义整数型变量 knife_length 表示刀的长度，单位：厘米knife_length = 20# 首先检查是否有车票，如果有，才允许进行 安检if has_ticket: print(\"有车票，可以开始安检...\") # 安检时，需要检查刀的长度，判断是否超过 20 厘米 # 如果超过 20 厘米，提示刀的长度，不允许上车 if knife_length &gt;= 20: print(\"不允许携带 %d 厘米长的刀上车\" % knife_length) # 如果不超过 20 厘米，安检通过 else: print(\"安检通过，祝您旅途愉快……\")# 如果没有车票，不允许进门else: print(\"大哥，您要先买票啊\") 05. 综合应用 —— 石头剪刀布目标 强化 多个条件 的 逻辑运算 体会 import 导入模块（“工具包”）的使用 需求 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3） 电脑 随机 出拳 —— 先假定电脑只会出石头，完成整体代码功能 比较胜负 序号 规则 1 石头 胜 剪刀 2 剪刀 胜 布 3 布 胜 石头 5.1 基础代码实现 先 假定电脑就只会出石头，完成整体代码功能 123456789101112131415161718# 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3）player = int(input(\"请出拳 石头（1）／剪刀（2）／布（3）：\"))# 电脑 随机 出拳 - 假定电脑永远出石头computer = 1# 比较胜负# 如果条件判断的内容太长，可以在最外侧的条件增加一对大括号# 再在每一个条件之间，使用回车，PyCharm 可以自动增加 8 个空格if ((player == 1 and computer == 2) or (player == 2 and computer == 3) or (player == 3 and computer == 1)): print(\"噢耶！！！电脑弱爆了！！！\")elif player == computer: print(\"心有灵犀，再来一盘！\")else: print(\"不行，我要和你决战到天亮！\") 5.2 随机数的处理 在 Python 中，要使用随机数，首先需要导入 随机数 的 模块 —— “工具包” 1import random 导入模块后，可以直接在 模块名称 后面敲一个 . 然后按 Tab 键，会提示该模块中包含的所有函数 random.randint(a, b) ，返回 [a, b] 之间的整数，包含 a 和 b 例如： 123random.randint(12, 20) # 生成的随机数n: 12 &lt;= n &lt;= 20 random.randint(20, 20) # 结果永远是 20 random.randint(20, 10) # 该语句是错误的，下限必须小于上限","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"9-变量的命名","slug":"9-变量的命名","date":"2020-02-08T04:46:20.000Z","updated":"2020-02-08T09:02:38.135Z","comments":true,"path":"2020/02/08/9-变量的命名/","link":"","permalink":"http://yoursite.com/2020/02/08/9-%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D/","excerpt":"变量的命名目标 标识符和关键字 变量的命名规则","text":"变量的命名目标 标识符和关键字 变量的命名规则 0.1 标识符和关键字1.1 标识符 标示符就是程序员定义的 变量名、函数名 名字 需要有 见名知义 的效果，见下图： 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 思考：下面的标示符哪些是正确的，哪些不正确为什么？ 123456789101112131415fromNo12from#12my_Booleanmy-BooleanObj22ndObjmyIntMy_tExt_testtest!32haha(da)ttjack_rosejack&amp;roseGUIG.U.I 1.2 关键字 关键字 就是在 Python 内部已经使用的标识符 关键字 具有特殊的功能和含义 开发者 不允许定义和关键字相同的名字的标示符 通过以下命令可以查看 Python 中的关键字 12In [1]: import keywordIn [2]: print(keyword.kwlist) 提示：关键字的学习及使用，会在后面的课程中不断介绍 import 关键字 可以导入一个 “工具包” 在 Python 中不同的工具包，提供有不同的工具 02. 变量的命名规则 命名规则 可以被视为一种 惯例，并无绝对与强制目的是为了 增加代码的识别和可读性 注意 Python 中的 标识符 是 区分大小写的 在定义变量时，为了保证代码格式，= 的左右应该各保留一个空格 在 Python 中，如果 变量名 需要由 二个 或 多个单词 组成时，可以按照以下方式命名 每个单词都使用小写字母 单词与单词之间使用 _下划线 连接 例如：first_name、last_name、qq_number、qq_password 驼峰命名法 当 变量名 是由二个或多个单词组成时，还可以利用驼峰命名法来命名 小驼峰式命名法 第一个单词以小写字母开始，后续单词的首字母大写 例如：firstName、lastName 大驼峰式命名法 每一个单词的首字母都采用大写字母 例如：FirstName、LastName、CamelCase","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"8-变量的基本使用","slug":"8-变量的基本使用","date":"2020-02-07T12:01:31.000Z","updated":"2020-02-08T08:50:47.150Z","comments":true,"path":"2020/02/07/8-变量的基本使用/","link":"","permalink":"http://yoursite.com/2020/02/07/8-%E5%8F%98%E9%87%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"变量的基本使用 程序就是用来处理数据的，而变量就是用来存储数据的 目标 变量定义 变量的类型 变量的命名","text":"变量的基本使用 程序就是用来处理数据的，而变量就是用来存储数据的 目标 变量定义 变量的类型 变量的命名 01. 变量定义 在 Python 中，每个变量 在使用前都必须赋值，变量 赋值以后 该变量 才会被创建 等号（=）用来给变量赋值 = 左边是一个变量名 = 右边是存储在变量中的值 1变量名 = 值 变量定义之后，后续就可以直接使用了 1) 变量演练1 —— iPython12345678910111213# 定义 qq_number 的变量用来保存 qq 号码In [1]: qq_number = \"1234567\"# 输出 qq_number 中保存的内容In [2]: qq_numberOut[2]: '1234567'# 定义 qq_password 的变量用来保存 qq 密码In [3]: qq_password = \"123\"# 输出 qq_password 中保存的内容In [4]: qq_passwordOut[4]: '123' 使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用 print 函数 2) 变量演练 2 —— PyCharm123456789# 定义 qq 号码变量qq_number = \"1234567\"# 定义 qq 密码变量qq_password = \"123\"# 在程序中，如果要输出变量的内容，需要使用 print 函数print(qq_number)print(qq_password) 使用解释器执行，如果要输出变量的内容，必须要要使用 print 函数 3) 变量演练 3 —— 超市买苹果 可以用 其他变量的计算结果 来定义变量 变量定义之后，后续就可以直接使用了 需求 苹果的价格是 8.5 元/斤 买了 7.5 斤 苹果 计算付款金额 12345678910# 定义苹果价格变量price = 8.5# 定义购买重量weight = 7.5# 计算金额money = price * weightprint(money) 思考题 如果 只要买苹果，就返 5 块钱 请重新计算购买金额 123456789101112# 定义苹果价格变量price = 8.5# 定义购买重量weight = 7.5# 计算金额money = price * weight# 只要买苹果就返 5 元money = money - 5print(money) 提问 上述代码中，一共定义有几个变量？ 三个：price／weight／money money = money - 5 是在定义新的变量还是在使用变量？ 直接使用之前已经定义的变量 变量名 只有在 第一次出现 才是 定义变量 变量名 再次出现，不是定义变量，而是直接使用之前定义过的变量 在程序开发中，可以修改之前定义变量中保存的值吗？ 可以 变量中存储的值，就是可以 变 的 02. 变量的类型 在内存中创建一个变量，会包括： 变量的名称 变量保存的数据 变量存储数据的类型 变量的地址（标示） 2.1 变量类型的演练 —— 个人信息需求 定义变量保存小明的个人信息 姓名：小明 年龄：18 岁 性别：是男生 身高：1.75 米 体重：75.0 公斤 利用 单步调试 确认变量中保存数据的类型 提问 在演练中，一共有几种数据类型？ 4 种 str —— 字符串 bool —— 布尔（真假） int —— 整数 float —— 浮点数（小数） 在 Python 中定义变量时需要指定类型吗？ 不需要 Python 可以根据 = 等号右侧的值，自动推导出变量中存储数据的类型 2.2 变量的类型 在 Python 中定义变量是 不需要指定类型（在其他很多高级语言中都需要） 数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 提示：在 Python 2.x 中，整数 根据保存数值的长度还分为： int（整数） long（长整数） 使用 type 函数可以查看一个变量的类型 1In [1]: type(name) 2.3 不同类型变量之间的计算1) 数字型变量 之间可以直接计算 在 Python 中，两个数字型变量是可以直接进行 算数运算的 如果变量是 bool 型，在计算时 True 对应的数字是 1 False 对应的数字是 0 演练步骤 定义整数 i = 10 定义浮点数 f = 10.5 定义布尔型 b = True 在 iPython 中，使用上述三个变量相互进行算术运算 2) 字符串变量 之间使用 + 拼接字符串 在 Python 中，字符串之间可以使用 + 拼接生成新的字符串 123456In [1]: first_name = \"三\"In [2]: last_name = \"张\"In [3]: first_name + last_nameOut[3]: '三张' 3) 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串12In [1]: \"-\" * 50Out[1]: '--------------------------------------------------' 4) 数字型变量 和 字符串 之间 不能进行其他计算12345678In [1]: first_name = \"zhang\"In [2]: x = 10In [3]: x + first_name---------------------------------------------------------------------------TypeError: unsupported operand type(s) for +: 'int' and 'str'类型错误：`+` 不支持的操作类型：`int` 和 `str` 2.4 变量的输入 所谓 输入，就是 用代码 获取 用户通过 键盘 输入的信息 例如：去银行取钱，在 ATM 上输入密码 在 Python 中，如果要获取用户在 键盘 上的输入信息，需要使用到 input 函数 1) 关于函数 一个 提前准备好的功能(别人或者自己写的代码)，可以直接使用，而 不用关心内部的细节 目前已经学习过的函数 函数 说明 print(x) 将 x 输出到控制台 type(x) 查看 x 的变量类型 2) input 函数实现键盘输入 在 Python 中可以使用 input 函数从键盘等待用户的输入 用户输入的 任何内容 Python 都认为是一个 字符串 语法如下： 1字符串变量 = input(\"提示信息：\") 3) 类型转换函数 函数 说明 int(x) 将 x 转换为一个整数 float(x) 将 x 转换到一个浮点数 4) 变量输入演练 —— 超市买苹果增强版需求 收银员输入 苹果的价格，单位：元／斤 收银员输入 用户购买苹果的重量，单位：斤 计算并且 输出 付款金额 演练方式 11234567891011121314151617# 1. 输入苹果单价price_str = input(\"请输入苹果价格：\")# 2. 要求苹果重量weight_str = input(\"请输入苹果重量：\")# 3. 计算金额# 1&gt; 将苹果单价转换成小数price = float(price_str)# 2&gt; 将苹果重量转换成小数weight = float(weight_str)# 3&gt; 计算付款金额money = price * weightprint(money) 提问 演练中，针对 价格 定义了几个变量？ 两个 price_str 记录用户输入的价格字符串 price 记录转换后的价格数值 思考 —— 如果开发中，需要用户通过控制台 输入 很多个 数字，针对每一个数字都要定义两个变量，方便吗？ 演练方式 2 —— 买苹果改进版 定义 一个 浮点变量 接收用户输入的同时，就使用 float 函数进行转换 1price = float(input(\"请输入价格:\")) 改进后的好处： 节约空间，只需要为一个变量分配空间 起名字方便，不需要为中间变量起名字 改进后的“缺点”： 初学者需要知道，两个函数能够嵌套使用，稍微有一些难度 提示 如果输入的不是一个数字，程序执行时会出错，有关数据转换的高级话题，后续会讲！ 2.5 变量的格式化输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元 在 Python 中可以使用 print 函数将信息输出到控制台 如果希望输出文字信息的同时，一起输出 数据，就需要使用到 格式化操作符 % 被称为 格式化操作符，专门用于处理字符串中的格式 包含 % 的字符串，被称为 格式化字符串 % 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全 %f 浮点数，%.2f 表示小数点后只显示两位 %% 输出 % 语法格式如下： 123print(\"格式化字符串\" % 变量1)print(\"格式化字符串\" % (变量1, 变量2...)) 格式化输出演练 —— 基本练习需求 定义字符串变量 name，输出 我的名字叫 小明，请多多关照！ 定义整数变量 student_no，输出 我的学号是 000001 定义小数 price、weight、money，输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元 定义一个小数 scale，输出 数据比例是 10.00% 1234print(\"我的名字叫 %s，请多多关照！\" % name)print(\"我的学号是 %06d\" % student_no)print(\"苹果单价 %.02f 元／斤，购买 %.02f 斤，需要支付 %.02f 元\" % (price, weight, money))print(\"数据比例是 %.02f%%\" % (scale * 100)) 课后练习 —— 个人名片需求 在控制台依次提示用户输入：姓名、公司、职位、电话、邮箱 按照以下格式输出： 12345678**************************************************公司名称姓名 (职位)电话：电话邮箱：邮箱************************************************** 实现代码如下： 1234567891011121314151617\"\"\"在控制台依次提示用户输入：姓名、公司、职位、电话、电子邮箱\"\"\"name = input(\"请输入姓名：\")company = input(\"请输入公司：\")title = input(\"请输入职位：\")phone = input(\"请输入电话：\")email = input(\"请输入邮箱：\")print(\"*\" * 50)print(company)print()print(\"%s (%s)\" % (name, title))print()print(\"电话：%s\" % phone)print(\"邮箱：%s\" % email)print(\"*\" * 50)","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"7-程序执行原理","slug":"7-程序执行原理","date":"2020-02-07T11:57:54.000Z","updated":"2020-02-08T08:50:22.262Z","comments":true,"path":"2020/02/07/7-程序执行原理/","link":"","permalink":"http://yoursite.com/2020/02/07/7-%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/","excerpt":"程序执行原理（科普）目标 计算机中的 三大件 程序执行的原理 程序的作用","text":"程序执行原理（科普）目标 计算机中的 三大件 程序执行的原理 程序的作用 01. 计算机中的三大件计算机中包含有较多的硬件，但是一个程序要运行，有 三个 核心的硬件，分别是： CPU 中央处理器，是一块超大规模的集成电路 负责 处理数据／计算 内存 临时 存储数据（断电之后，数据会消失） 速度快 空间小（单位价格高） 硬盘 永久 存储数据 速度慢 空间大（单位价格低） CPU 内存 硬盘 思考题 计算机中哪一个硬件设备负责执行程序？ CPU 内存 的速度快还是 硬盘 的速度快？ 内存 我们的程序是安装在内存中的，还是安装在硬盘中的？ 硬盘 我买了一个内存条，有 500G 的空间！！！，这句话对吗？ 不对，内存条通常只有 4G / 8G / 16G / 32G 计算机关机之后，内存中的数据都会消失，这句话对吗？ 正确 02. 程序执行的原理 程序 运行之前，程序是 保存在硬盘 中的 当要运行一个程序时 操作系统会首先让 CPU 把程序复制到 内存 中 CPU 执行 内存 中的 程序代码 程序要执行，首先要被加载到内存 2.1 Python 程序执行原理 操作系统会首先让 CPU 把 Python 解释器 的程序复制到 内存 中 Python 解释器 根据语法规则，从上向下 让 CPU 翻译 Python 程序中的代码 CPU 负责执行翻译完成的代码 Python 的解释器有多大？ 执行以下终端命令可以查看 Python 解释器的大小 12345678# 1. 确认解释器所在位置$ which python# 2. 查看 python 文件大小(只是一个软链接)$ ls -lh /usr/bin/python# 3. 查看具体文件大小$ ls -lh /usr/bin/python2.7 提示：建立 软链接 的目的，是为了方便使用者不用记住使用的解释器是 哪一个具体版本 03. 程序的作用 程序就是 用来处理数据 的！ 新闻软件 提供的 新闻内容、评论…… 是数据 电商软件 提供的 商品信息、配送信息…… 是数据 运动类软件 提供的 运动数据…… 是数据 地图类软件 提供的 地图信息、定位信息、车辆信息…… 是数据 即时通讯软件 提供的 聊天信息、好友信息…… 是数据 …… 3.1 思考 QQ 程序的启动过程 QQ 在运行之前，是保存在 硬盘 中的 运行之后，QQ 程序就会被加载到 内存 中了 3.2 思考 QQ 程序的 登录 过程 读取用户输入的 QQ 号码 读取用户输入的 QQ 密码 将 QQ 号码 和 QQ 密码 发送给腾讯的服务器，等待服务器确认用户信息 思考 1 在 QQ 这个程序将 QQ 号码 和 QQ 密码 发送给服务器之前，是否需要先存储一下 QQ 号码 和 密码? 答案 肯定需要！—— 否则 QQ 这个程序就不知道把什么内容发送给服务器了！ 思考 2 QQ 这个程序把 QQ 号码 和 QQ 密码 保存在哪里？ 答案 保存在 内存 中，因为 QQ 程序自己就在内存中 思考 3 QQ 这个程序是怎么保存用户的 QQ 号码 和 QQ 密码 的？ 答案 在内存中为 QQ 号码 和 QQ 密码 各自分配一块空间 在 QQ 程序结束之前，这两块空间是由 QQ 程序负责管理的，其他任何程序都不允许使用 在 QQ 自己使用完成之前，这两块空间始终都只负责保存 QQ 号码 和 QQ 密码 使用一个 别名 标记 QQ 号码 和 QQ 密码 在内存中的位置 在程序内部，为 QQ 号码 和 QQ 密码 在内存中分配的空间就叫做 变量 程序就是用来处理数据的，而变量就是用来存储数据的","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"6-算数运算符","slug":"6-算数运算符","date":"2020-02-07T11:56:51.000Z","updated":"2020-02-08T08:50:34.158Z","comments":true,"path":"2020/02/07/6-算数运算符/","link":"","permalink":"http://yoursite.com/2020/02/07/6-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"算数运算符计算机，顾名思义就是负责进行 数学计算 并且 存储计算结果 的电子设备 目标 算术运算符的基本使用","text":"算数运算符计算机，顾名思义就是负责进行 数学计算 并且 存储计算结果 的电子设备 目标 算术运算符的基本使用 01. 算数运算符 算数运算符是 运算符的一种 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 12In [1]: \"-\" * 50Out[1]: '----------------------------------------' 02. 算数运算符的优先级 和数学中的运算符的优先级一致，在 Python 中进行数学计算时，同样也是： 先乘除后加减 同级运算符是 从左至右 计算 可以使用 () 调整计算的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 例如： 2 + 3 * 5 = 17 (2 + 3) * 5 = 25 2 * 3 + 5 = 11 2 * (3 + 5) = 16","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"5--注释","slug":"5-注释","date":"2020-02-07T11:55:19.000Z","updated":"2020-02-08T08:50:10.513Z","comments":true,"path":"2020/02/07/5-注释/","link":"","permalink":"http://yoursite.com/2020/02/07/5-%E6%B3%A8%E9%87%8A/","excerpt":"注释目标 注释的作用 单行注释（行注释） 多行注释（块注释）","text":"注释目标 注释的作用 单行注释（行注释） 多行注释（块注释） 01. 注释的作用 使用用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性 02. 单行注释(行注释) 以 # 开头，# 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用 示例代码如下： 12# 这是第一个单行注释print(\"hello python\") 为了保证代码的可读性，# 后面建议先添加一个空格，然后再编写相应的说明文字 在代码后面增加的单行注释 在程序开发时，同样可以使用 # 在代码的后面（旁边）增加说明性的文字 但是，需要注意的是，为了保证代码的可读性，注释和代码之间 至少要有 两个空格 示例代码如下： 1print(\"hello python\") # 输出 `hello python` 03. 多行注释（块注释） 如果希望编写的 注释信息很多，一行无法显示，就可以使用多行注释 要在 Python 程序中使用多行注释，可以用 一对 连续的 三个 引号(单引号和双引号都可以) 示例代码如下： 123456\"\"\"这是一个多行注释在多行注释之间，可以写很多很多的内容……\"\"\" print(\"hello python\") 什么时候需要使用注释？ 注释不是越多越好，对于一目了然的代码，不需要添加注释 对于 复杂的操作，应该在操作开始前写上若干行注释 对于 不是一目了然的代码，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格） 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么 在一些正规的开发团队，通常会有 代码审核 的惯例，就是一个团队中彼此阅读对方的代码 关于代码规范 Python 官方提供有一系列 PEP（Python Enhancement Proposals） 文档 其中第 8 篇文档专门针对 Python 的代码格式 给出了建议，也就是俗称的 PEP 8 文档地址：https://www.python.org/dev/peps/pep-0008/ 谷歌有对应的中文文档：http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/ 任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"4-多文件项目的演练","slug":"4-多文件项目的演练","date":"2020-02-07T11:51:40.000Z","updated":"2020-02-08T08:50:01.765Z","comments":true,"path":"2020/02/07/4-多文件项目的演练/","link":"","permalink":"http://yoursite.com/2020/02/07/4-%E5%A4%9A%E6%96%87%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%BC%94%E7%BB%83/","excerpt":"多文件项目的演练 开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每 一个项目 就具有一个 独立专属的目录，用于保存 所有和项目相关的文件 一个项目通常会包含 很多源文件 目标 在项目中添加多个文件，并且设置文件的执行","text":"多文件项目的演练 开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每 一个项目 就具有一个 独立专属的目录，用于保存 所有和项目相关的文件 一个项目通常会包含 很多源文件 目标 在项目中添加多个文件，并且设置文件的执行 多文件项目演练 在 01_Python基础 项目中新建一个 hm_02_第2个Python程序.py 在 hm_02_第2个Python程序.py 文件中添加一句 print(&quot;hello&quot;) 点击右键执行 hm_02_第2个Python程序.py 提示 在 PyCharm 中，要想让哪一个 Python 程序能够执行，必须首先通过 鼠标右键的方式执行 一下 对于初学者而言，在一个项目中设置多个程序可以执行，是非常方便的，可以方便对不同知识点的练习和测试 对于商业项目而言，通常在一个项目中，只有一个 可以直接执行的 Python 源程序","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"3-第一个Python程序3","slug":"3-PyCharm 的初始设置","date":"2020-02-07T11:47:52.000Z","updated":"2020-02-08T08:49:46.295Z","comments":true,"path":"2020/02/07/3-PyCharm 的初始设置/","link":"","permalink":"http://yoursite.com/2020/02/07/3-PyCharm%20%E7%9A%84%E5%88%9D%E5%A7%8B%E8%AE%BE%E7%BD%AE/","excerpt":"PyCharm 的初始设置（知道）目标 恢复 PyCharm 的初始设置 第一次启动 PyCharm 新建一个 Python 项目 设置 PyCharm 的字体显示 PyCharm 的升级以及其他 PyCharm 的官方网站地址是：https://www.jetbrains.com/pycharm/","text":"PyCharm 的初始设置（知道）目标 恢复 PyCharm 的初始设置 第一次启动 PyCharm 新建一个 Python 项目 设置 PyCharm 的字体显示 PyCharm 的升级以及其他 PyCharm 的官方网站地址是：https://www.jetbrains.com/pycharm/ 01. 恢复 PyCharm 的初始设置PyCharm 的 配置信息 是保存在 用户家目录下 的 .PyCharmxxxx.x 目录下的，xxxx.x 表示当前使用的 PyCharm 的版本号 如果要恢复 PyCharm 的初始设置，可以按照以下步骤进行： 关闭正在运行的 PyCharm 在终端中执行以下终端命令，删除 PyCharm 的配置信息目录： 1$ rm -r ~/.PyCharm2016.3 重新启动 PyCharm 02. 第一次启动 PyCharm 导入配置信息 选择许可协议 配置初始界面 2.1 导入配置信息 在第一次启动 PyCharm 时，会首先提示用户是否导入 之前的配置信息 如果是第一次使用，直接点击 OK 按钮 2.2 选择许可协议 PyCharm 是一个付费软件，购买费用为 199$ / 年 或者 19.90$ ／ 月 不过 PyCharm 提供了对 学生和教师免费使用的版本 下载地址是：https://www.jetbrains.com/pycharm-edu/download/#section=linux 商业版本会提示输入注册信息，或者选择免费评估 2.3 PyCharm 的配置初始界面 在初始配置界面，可以通过 Editor colors and fonts 选择 编辑器的配色方案 2.4 欢迎界面 所有基础配置工作结束之后，就可以看到 PyCharm 的 欢迎界面了，通过 欢迎界面 就可以开始开发 Python 项目了 03. 新建/打开一个 Python 项目3.1 项目简介 开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每 一个项目 就具有一个 独立专属的目录，用于保存 所有和项目相关的文件 一个项目通常会包含 很多源文件 3.2 打开 Python 项目 直接点击 Open 按钮，然后浏览到之前保存 Python 文件的目录，既可以打开项目 打开之后，会在目录下新建一个 .idea 的目录，用于保存 项目相关的信息，例如：解释器版本、项目包含的文件等等 第一次打开项目，需要耐心等待 PyCharm 对项目进行初始设置 设置项目使用的解释器版本 打开的目录如果不是由 PyCharm 建立的项目目录，有的时候 使用的解释器版本是 Python 2.x 的，需要单独设置解释器的版本 通过 File / Settings… 可以打开设置窗口，如下图所示： 3.3 新建项目1) 命名规则 以后 项目名 前面都以 数字编号，随着知识点递增，编号递增 例如：01_Python 基础、02_分支、03_循环… 每个项目下的 文件名 都以 hm_xx_知识点 方式来命名 其中 xx 是演练文件的序号 注意 命名文件名时建议只使用 小写字母、数字 和 下划线 文件名不能以数字开始 通过 欢迎界面 或者菜单 File / New Project 可以新建项目 2) 演练步骤 新建 01_Python基础 项目，使用 Python 3.x 解释器 在项目下新建 hm_01_hello.py Python 文件 编写 print(&quot;Hello Python&quot;) 代码 04. 设置 PyCharm 的字体显示 05. PyCharm 的升级以及其他 PyCharm 提供了对 学生和教师免费使用的版本 教育版下载地址：https://www.jetbrains.com/pycharm-edu/download/#section=linux 专业版下载地址：https://www.jetbrains.com/pycharm/download/#section=linux 5.1 安装和启动步骤 执行以下终端命令，解压缩下载后的安装包 1$ tar -zxvf pycharm-professional-2017.1.3.tar.gz 将解压缩后的目录移动到 /opt 目录下，可以方便其他用户使用 /opt 目录用户存放给主机额外安装的软件 1$ sudo mv pycharm-2017.1.3/ /opt/ 切换工作目录 1$ cd /opt/pycharm-2017.1.3/bin 启动 PyCharm 1$ ./pycharm.sh 5.2 设置专业版启动图标 在专业版中，选择菜单 Tools / Create Desktop Entry… 可以设置任务栏启动图标 注意：设置图标时，需要勾选 Create the entry for all users 5.3 卸载之前版本的 PyCharm1) 程序安装 程序文件目录 将安装包解压缩，并且移动到 /opt 目录下 所有的相关文件都保存在解压缩的目录中 配置文件目录 启动 PyCharm 后，会在用户家目录下建立一个 .PyCharmxxx 的隐藏目录 保存 PyCharm 相关的配置信息 快捷方式文件 /usr/share/applications/jetbrains-pycharm.desktop 在 ubuntu 中，应用程序启动的快捷方式通常都保存在 /usr/share/applications 目录下 2) 程序卸载 要卸载 PyCharm 只需要做以下两步工作： 删除解压缩目录 1$ sudo rm -r /opt/pycharm-2016.3.1/ 删除家目录下用于保存配置信息的隐藏目录 1$ rm -r ~/.PyCharm2016.3/ 如果不再使用 PyCharm 还需要将 /usr/share/applications/ 下的 jetbrains-pycharm.desktop 删掉 5.4 教育版安装演练12345678# 1. 解压缩下载后的安装包$ tar -zxvf pycharm-edu-3.5.1.tar.gz# 2. 将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用$ sudo mv pycharm-edu-3.5.1/ /opt/# 3. 启动 `PyCharm`/opt/pycharm-edu-3.5.1/bin/pycharm.sh 后续课程都使用专业版本演练 设置启动图标 编辑快捷方式文件 1$ sudo gedit /usr/share/applications/jetbrains-pycharm.desktop 按照以下内容修改文件内容，需要注意指定正确的 pycharm 目录 12345678910[Desktop Entry]Version&#x3D;1.0Type&#x3D;ApplicationName&#x3D;PyCharmIcon&#x3D;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.pngExec&#x3D;&quot;&#x2F;opt&#x2F;pycharm-edu-3.5.1&#x2F;bin&#x2F;pycharm.sh&quot; %fComment&#x3D;The Drive to DevelopCategories&#x3D;Development;IDE;Terminal&#x3D;falseStartupWMClass&#x3D;jetbrains-pycharm","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"2-第一个Python程序","slug":"2-第一个Python程序","date":"2020-02-07T11:44:40.000Z","updated":"2020-02-08T08:49:34.444Z","comments":true,"path":"2020/02/07/2-第一个Python程序/","link":"","permalink":"http://yoursite.com/2020/02/07/2-%E7%AC%AC%E4%B8%80%E4%B8%AAPython%E7%A8%8B%E5%BA%8F/","excerpt":"第一个 Python 程序目标 第一个 HelloPython 程序 Python 2.x 与 3​​.x 版本简介 执行 Python 程序的三种方式 解释器 —— python / python3 交互式 —— ipython 集成开发环境 —— PyCharm","text":"第一个 Python 程序目标 第一个 HelloPython 程序 Python 2.x 与 3​​.x 版本简介 执行 Python 程序的三种方式 解释器 —— python / python3 交互式 —— ipython 集成开发环境 —— PyCharm 01. 第一个 HelloPython 程序1.1 Python 源程序的基本概念 Python 源程序就是一个特殊格式的文本文件，可以使用任意文本编辑软件做 Python 的开发 Python 程序的 文件扩展名 通常都是 .py 1.2 演练步骤 在桌面下，新建 认识Python 目录 在 认识Python 目录下新建 01-HelloPython.py 文件 使用 gedit 编辑 01-HelloPython.py 并且输入以下内容： 12print(\"hello python\")print(\"hello world\") 在终端中输入以下命令执行 01-HelloPython.py 1$ python 01-HelloPython.py print 是 python 中我们学习的第一个 函数 print 函数的作用，可以把 “” 内部的内容，输出到屏幕上 1.3 演练扩展 —— 认识错误（BUG）关于错误 编写的程序不能正常执行，或者执行的结果不是我们期望的 俗称 BUG，是程序员在开发时非常常见的，初学者常见错误的原因包括： 手误 对已经学习过的知识理解还存在不足 对语言还有需要学习和提升的内容 在学习语言时，不仅要学会语言的语法，而且还要学会如何认识错误和解决错误的方法 每一个程序员都是在不断地修改错误中成长的 第一个演练中的常见错误 1&gt; 手误，例如使用 pirnt(&quot;Hello world&quot;) 123NameError: name &#39;pirnt&#39; is not defined名称错误：&#39;pirnt&#39; 名字没有定义 2&gt; 将多条 print 写在一行 123SyntaxError: invalid syntax语法错误：语法无效 每行代码负责完成一个动作 3&gt; 缩进错误 123IndentationError: unexpected indent缩进错误：不期望出现的缩进 Python 是一个格式非常严格的程序设计语言 目前而言，大家记住每行代码前面都不要增加空格 4&gt; python 2.x 默认不支持中文 目前市场上有两个 Python 的版本并存着，分别是 Python 2.x 和 Python 3.x Python 2.x 默认不支持中文，具体原因，等到介绍 字符编码 时给大家讲解 Python 2.x 的解释器名称是 python Python 3.x 的解释器名称是 python3 123456SyntaxError: Non-ASCII character &#39;\\xe4&#39; in file 01-HelloPython.py on line 3, but no encoding declared; see http:&#x2F;&#x2F;python.org&#x2F;dev&#x2F;peps&#x2F;pep-0263&#x2F; for details语法错误： 在 01-HelloPython.py 中第 3 行出现了非 ASCII 字符 &#39;\\xe4&#39;，但是没有声明文件编码请访问 http:&#x2F;&#x2F;python.org&#x2F;dev&#x2F;peps&#x2F;pep-0263&#x2F; 了解详细信息 ASCII 字符只包含 256 个字符，不支持中文 有关字符编码的问题，后续会讲 单词列表12345678910111213* error 错误* name 名字* defined 已经定义* syntax 语法* invalid 无效* Indentation 索引* unexpected 意外的，不期望的* character 字符* line 行* encoding 编码* declared 声明* details 细节，详细信息* ASCII 一种字符编码 02. Python 2.x 与 3​​.x 版本简介目前市场上有两个 Python 的版本并存着，分别是 Python 2.x 和 Python 3.x 新的 Python 程序建议使用 Python 3.0 版本的语法 Python 2.x 是 过去的版本 解释器名称是 python Python 3.x 是 现在和未来 主流的版本 解释器名称是 python3 相对于 Python 的早期版本，这是一个 较大的升级 为了不带入过多的累赘，Python 3.0 在设计的时候 没有考虑向下兼容 许多早期 Python 版本设计的程序都无法在 Python 3.0 上正常执行 Python 3.0 发布于 2008 年 到目前为止，Python 3.0 的稳定版本已经有很多年了 Python 3.3 发布于 2012 Python 3.4 发布于 2014 Python 3.5 发布于 2015 Python 3.6 发布于 2016 为了照顾现有的程序，官方提供了一个过渡版本 —— Python 2.6 基本使用了 Python 2.x 的语法和库 同时考虑了向 Python 3.0 的迁移，允许使用部分 Python 3.0 的语法与函数 2010 年中推出的 Python 2.7 被确定为 最后一个Python 2.x 版本 提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议 先使用 Python 3.0 版本进行开发 然后使用 Python 2.6、Python 2.7 来执行，并且做一些兼容性的处理 03. 执行 Python 程序的三种方式3.1. 解释器 python / python3Python 的解释器12345# 使用 python 2.x 解释器$ python xxx.py# 使用 python 3.x 解释器$ python3 xxx.py 其他解释器（知道）Python 的解释器 如今有多个语言的实现，包括： CPython —— 官方版本的 C 语言实现 Jython —— 可以运行在 Java 平台 IronPython —— 可以运行在 .NET 和 Mono 平台 PyPy —— Python 实现的，支持 JIT 即时编译 3.2. 交互式运行 Python 程序 直接在终端中运行解释器，而不输入要执行的文件名 在 Python 的 Shell 中直接输入 Python 的代码，会立即看到程序执行结果 1) 交互式运行 Python 的优缺点优点 适合于学习/验证 Python 语法或者局部代码 缺点 代码不能保存 不适合运行太大的程序 2) 退出 官方的解释器1&gt; 直接输入 exit()1&gt;&gt;&gt; exit() 2&gt; 使用热键退出在 python 解释器中，按热键 ctrl + d 可以退出解释器 3) IPython IPython 中 的 “I” 代表 交互 interactive 特点 IPython 是一个 python 的 交互式 shell，比默认的 python shell 好用得多 支持自动补全 自动缩进 支持 bash shell 命令 内置了许多很有用的功能和函数 IPython 是基于 BSD 开源的 版本 Python 2.x 使用的解释器是 ipython Python 3.x 使用的解释器是 ipython3 要退出解释器可以有以下两种方式： 1&gt; 直接输入 exit1In [1]: exit 2&gt; 使用热键退出在 IPython 解释器中，按热键 ctrl + d，IPython 会询问是否退出解释器 IPython 的安装1$ sudo apt install ipython 3.3. Python 的 IDE —— PyCharm1） 集成开发环境（IDE）集成开发环境（IDE，Integrated Development Environment）—— 集成了开发软件需要的所有工具，一般包括以下工具： 图形用户界面 代码编辑器（支持 代码补全／自动缩进） 编译器／解释器 调试器（断点／单步执行） …… 2）PyCharm 介绍 PyCharm 是 Python 的一款非常优秀的集成开发环境 PyCharm 除了具有一般 IDE 所必备功能外，还可以在 Windows、Linux、macOS 下使用 PyCharm 适合开发大型项目 一个项目通常会包含 很多源文件 每个 源文件 的代码行数是有限的，通常在几百行之内 每个 源文件 各司其职，共同完成复杂的业务功能 3）PyCharm 快速体验 文件导航区域 能够 浏览／定位／打开 项目文件 文件编辑区域 能够 编辑 当前打开的文件 控制台区域 能够： 输出程序执行内容 跟踪调试代码的执行 右上角的 工具栏 能够 执行(SHIFT + F10) / 调试(SHIFT + F9) 代码 通过控制台上方的单步执行按钮(F8)，可以单步执行代码","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"1-认识 Python","slug":"1-认识-Python","date":"2020-02-07T11:41:51.000Z","updated":"2020-02-08T08:49:23.994Z","comments":true,"path":"2020/02/07/1-认识-Python/","link":"","permalink":"http://yoursite.com/2020/02/07/1-%E8%AE%A4%E8%AF%86-Python/","excerpt":"认识 Python 人生苦短，我用 Python —— Life is short, you need Python 目标 Python 的起源 为什么要用 Python？ Python 的特点 Python 的优缺点","text":"认识 Python 人生苦短，我用 Python —— Life is short, you need Python 目标 Python 的起源 为什么要用 Python？ Python 的特点 Python 的优缺点 01. Python 的起源 Python 的创始人为吉多·范罗苏姆（Guido van Rossum） 1989 年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的解释程序，作为 ABC 语言的一种继承（感觉下什么叫牛人） ABC 是由吉多参加设计的一种教学语言，就吉多本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是 ABC 语言并没有成功，究其原因，吉多认为是非开放造成的。吉多决心在 Python 中避免这一错误，并获取了非常好的效果 之所以选中 Python（蟒蛇） 作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python’s Flying Circus）的爱好者 1991 年，第一个 Python 解释器 诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件 1.1 解释器（科普）计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为编译器 编译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译时间点的不同。当编译器以解释方式运行的时候，也称之为解释器 编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++ 解释型语言：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行 编译型语言和解释型语言对比 速度 —— 编译型语言比解释型语言执行速度快 跨平台性 —— 解释型语言比编译型语言跨平台性好 1.2 Python 的设计目标1999 年，吉多·范罗苏姆向 DARPA 提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标： 一门简单直观的语言并与主要竞争者一样强大 开源，以便任何人都可以为它做贡献 代码像纯英语那样容易理解 适用于短期开发的日常任务 这些想法中的基本都已经成为现实，Python 已经成为一门流行的编程语言 1.3 Python 的设计哲学 优雅 明确 简单 Python 开发者的哲学是：用一种方法，最好是只有一种方法来做一件事 如果面临多种选择，Python 开发者一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法 在 Python 社区，吉多被称为“仁慈的独裁者” 02. 为什么选择 Python？ 代码量少 …… 同一样问题，用不同的语言解决，代码量差距还是很多的，一般情况下 Python 是 Java 的 1/5，所以说 人生苦短，我用 Python 03. Python 特点 Python 是完全面向对象的语言 函数、模块、数字、字符串都是对象，在 Python 中一切皆对象 完全支持继承、重载、多重继承 支持重载运算符，也支持泛型设计 Python 拥有一个强大的标准库，Python 语言的核心只包含 数字、字符串、列表、字典、文件 等常见类型和函数，而由 Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理 等额外的功能 Python 社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统 多个领域 面向对象的思维方式 面向对象 是一种 思维方式，也是一门 程序设计技术 要解决一个问题前，首先考虑 由谁 来做，怎么做事情是 谁 的职责，最后把事情做好就行！ 对象 就是 谁 要解决复杂的问题，就可以找多个不同的对象，各司其职，共同实现，最终完成需求 04. Python 的优缺点4.1 优点 简单、易学 免费、开源 面向对象 丰富的库 可扩展性 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 C 或 C++ 编写，然后在 Python 程序中使用它们 …… 4.2 缺点 运行速度 国内市场较小 中文资料匮乏","categories":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python基础","slug":"python基础","permalink":"http://yoursite.com/tags/python%E5%9F%BA%E7%A1%80/"}]},{"title":"11-其他命令","slug":"11-其他命令","date":"2020-02-06T08:15:33.000Z","updated":"2020-02-08T08:54:38.976Z","comments":true,"path":"2020/02/06/11-其他命令/","link":"","permalink":"http://yoursite.com/2020/02/06/11-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/","excerpt":"其他命令目标 查找文件 find 软链接 ln 打包和压缩 tar 软件安装 apt-get","text":"其他命令目标 查找文件 find 软链接 ln 打包和压缩 tar 软件安装 apt-get 01. 查找文件 find 命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件 序号 命令 作用 01 find [路径] -name “*.py” 查找指定路径下扩展名是 .py 的文件，包括子目录 如果省略路径，表示在当前文件夹下查找 之前学习的通配符，在使用 find 命令时同时可用 有关 find 的高级使用，在就业班会讲 演练目标 搜索桌面目录下，文件名包含 1 的文件 1find -name \"*1*\" 搜索桌面目录下，所有以 .txt 为扩展名的文件 1find -name \"*.txt\" 搜索桌面目录下，以数字 1 开头的文件 1find -name \"1*\" 02. 软链接 序号 命令 作用 01 ln -s 被链接的源文件 链接文件 建立文件的软链接，用通俗的方式讲类似于 Windows 下的快捷方式 注意： 没有-s选项建立的是一个硬链接文件 两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接 源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用 演练目标 将桌面目录下的 01.py 移动到 demo/b/c 目录下 在桌面目录下新建 101.py的软链接FirstPython 分别使用 相对路径 和 绝对路径 建立 FirstPython 的软链接 将 FirstPython 移动到 demo 目录下，对比使用 相对路径 和 绝对路径 的区别 硬链接简介（知道） 在使用 ln 创建链接时，如果没有 -s 选项，会创建一个 硬链接，而不是软链接 硬链接演练 在 ~/Desktop/demo 目录下建立 ~/Desktop/demo/b/c/01.py 的硬链接 01_hard 使用 ls -l 查看文件的硬链接数（硬链接——有多少种方式可以访问文件或者目录） 删除 ~/Desktop/demo/b/c/01.py，并且使用 tree 来确认 demo 目录下的三个链接文件 文件软硬链接的示意图￼ 在 Linux 中，文件名 和 文件的数据 是分开存储的 提示： 在 Linux 中，只有文件的 硬链接数 == 0 才会被删除 使用 ls -l 可以查看一个文件的硬链接的数量 在日常工作中，几乎不会建立文件的硬链接，知道即可 03. 打包压缩 打包压缩 是日常工作中备份文件的一种方式 在不同操作系统中，常用的打包压缩方式是不同的 Windows 常用 rar Mac 常用 zip Linux 常用 tar.gz 3.1 打包 ／ 解包 tar 是 Linux 中最常用的 备份工具，此命令可以 把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件 tar 的命令格式如下： 12345# 打包文件tar -cvf 打包文件.tar 被打包的文件／路径...# 解包文件tar -xvf 打包文件.tar tar 选项说明 选项 含义 c 生成档案文件，创建打包文件 x 解开档案文件 v 列出归档解档的详细过程，显示进度 f 指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后 注意：f 选项必须放在最后，其他选项顺序可以随意 打包解包演练 删除桌面下的所有内容 在桌面下新建三个空白文件 01.py、02.py、03.py 将这三个文件打一个 py.tar 的包 新建 tar 目录，并且将 py.tar 移动到 tar 目录下 解包 py.tar 3.2 压缩／解压缩1) gzip tar与tar命令结合可以使用实现文件打包和压缩 tar 只负责打包文件，但不压缩 用 gzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.gz 在 Linux 中，最常见的压缩文件格式就是 xxx.tar.gz 在 tar 命令中有一个选项 -z 可以调用 gzip，从而可以方便的实现压缩和解压缩的功能 命令格式如下： 12345678# 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 目标路径 选项 含义 -C 解压缩到指定目录，注意：要解压缩的目录必须存在 2) bzip2(two) tar 与 bzip2 命令结合可以使用实现文件 打包和压缩（用法和 gzip 一样） tar 只负责打包文件，但不压缩， 用 bzip2 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2 在 tar 命令中有一个选项 -j 可以调用 bzip2，从而可以方便的实现压缩和解压缩的功能 命令格式如下： 12345# 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...# 解压缩文件tar -jxvf 打包文件.tar.bz2 04. 软件安装4.1 通过 apt 安装／卸载软件 apt 是 Advanced Packaging Tool，是 Linux 下的一款安装包管理工具 可以在终端中方便的 安装／卸载／更新软件包 12345678# 1. 安装软件$ sudo apt install 软件包# 2. 卸载软件$ sudo apt remove 软件名# 3. 更新已安装的包$ sudo apt upgrade 安装演练12345# 一个小火车提示$ sudo apt install sl# 一个比较漂亮的查看当前进程排名的软件$ sudo apt install htop 4.2 配置软件源 如果希望在 ubuntu 中安装软件，更加快速，可以通过设置镜像源，选择一个访问网速更快的服务器，来提供软件下载／安装服务 提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了 所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据所在位置不同，国内服务器通常速度会更快一些！ ￼ ￼","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"10-系统信息相关命令","slug":"10-系统信息相关命令","date":"2020-02-06T08:14:02.000Z","updated":"2020-02-08T08:54:32.062Z","comments":true,"path":"2020/02/06/10-系统信息相关命令/","link":"","permalink":"http://yoursite.com/2020/02/06/10-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","excerpt":"系统信息相关命令 本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 系统日期和时间 ／ 磁盘空间占用情况 ／ 程序执行情况 本小结学习的终端命令基本都是查询命令，通过这些命令对系统资源的使用情况有个了解","text":"系统信息相关命令 本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 系统日期和时间 ／ 磁盘空间占用情况 ／ 程序执行情况 本小结学习的终端命令基本都是查询命令，通过这些命令对系统资源的使用情况有个了解 目标 时间和日期 date cal 磁盘和目录空间 df du 进程信息 ps top kill 01. 时间和日期 序号 命令 作用 01 date 查看系统时间 02 cal calendar 查看日历，-y 选项可以查看一年的日历 02. 磁盘信息 序号 命令 作用 01 df -h disk free 显示磁盘剩余空间 02 du -h [目录名] disk usage 显示目录下的文件大小 选项说明 参数 含义 -h 以人性化的方式显示文件大小 03. 进程信息 所谓 进程，通俗地说就是 当前正在执行的一个程序 序号 命令 作用 01 ps aux process status 查看进程的详细状况 02 top 动态显示运行中的进程并且排序 03 kill [-9] 进程代号 终止指定代号的进程，-9 表示强行终止 ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明功能 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃 要退出 top 可以直接输入 q","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"9-用户权限相关命令","slug":"9-用户权限相关命令","date":"2020-02-06T08:11:31.000Z","updated":"2020-02-08T08:54:24.738Z","comments":true,"path":"2020/02/06/9-用户权限相关命令/","link":"","permalink":"http://yoursite.com/2020/02/06/9-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/","excerpt":"用户权限相关命令目标 用户 和 权限 的基本概念 用户管理 终端命令 组管理 终端命令 修改权限 终端命令","text":"用户权限相关命令目标 用户 和 权限 的基本概念 用户管理 终端命令 组管理 终端命令 修改权限 终端命令 01. 用户 和 权限 的基本概念 1.1 基本概念 用户 是 Linux 系统工作中重要的一环，用户管理包括 用户 与 组 管理 在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限 在 Linux 中，可以指定 每一个用户 针对 不同的文件或者目录 的 不同权限 对 文件／目录 的权限包括： 序号 权限 英文 缩写 数字代号 01 读 read r 4 02 写 write w 2 03 执行 excute x 1 1.2 组 为了方便用户管理，提出了 组 的概念，如下图所示 ￼ 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 1.3 ls -l 扩展 ls -l 可以查看文件夹下文件的详细信息，从左到右依次是： 权限，第 1 个字符如果是 d 表示目录 硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件 拥有者，家目录下 文件／目录 的拥有者通常都是当前用户 组，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲 大小 时间 名称 ￼ 1.4 chmod 简单使用（重要） chmod 可以修改 用户／组 对 文件／目录 的权限 命令格式如下： 1chmod +/-rwx 文件名|目录名 提示：以上方式会一次性修改 拥有者 / 组 权限，有关 chmod 的高级用法，后续会讲 1.5 超级用户 Linux 系统中的 root 账号通常 用于系统的维护和管理，对操作系统的所有资源 具有所有访问权限 在大多数版本的 Linux 中，都不推荐 直接使用 root 账号登录系统 在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户” sudo su 是 substitute user 的缩写，表示 使用另一个用户的身份 sudo 命令用来以其他身份来执行命令，预设的身份为 root 用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码 若其未经授权的用户企图使用 sudo，则会发出警告邮件给管理员 02. 组管理 终端命令 提示：创建组 / 删除组 的终端命令都需要通过 sudo 执行 序号 命令 作用 01 groupadd 组名 添加组 02 groupdel 组名 删除组 03 cat /etc/group 确认组信息 04 chgrp -R 组名 文件/目录名 递归修改文件/目录的所属组 提示： 组信息保存在 /etc/group 文件中 /etc 目录是专门用来保存 系统配置信息 的目录 ￼ 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 演练目标 在 python 用户的桌面文件夹下创建 Python学习 目录 新建 dev 组 将 Python学习 目录的组修改为 dev 03. 用户管理 终端命令 提示：创建用户 / 删除用户 / 修改其他用户密码 的终端命令都需要通过 sudo 执行 3.1 创建用户／设置密码／删除用户 序号 命令 作用 说明 01 useradd -m -g 组 新建用户名 添加新用户 -m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组 02 passwd 用户名 设置用户密码 如果是普通用户，直接用 passwd 可以修改自己的账户密码 03 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 04 cat /etc/passwd | grep 用户名 确认用户信息 新建用户后，用户信息会保存在 /etc/passwd 文件中 提示： 创建用户时，如果忘记添加 -m 选项指定新用户的家目录 —— 最简单的方法就是删除用户，重新创建 创建用户时，默认会创建一个和用户名同名的组名 用户信息保存在 /etc/passwd 文件中 3.2 查看用户信息 序号 命令 作用 01 id [用户名] 查看用户 UID 和 GID 信息 02 who 查看当前所有登录的用户列表 03 whoami 查看当前登录用户的账户名 passwd 文件/etc/passwd 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是 用户名 密码（x，表示加密的密码） UID（用户标识） GID（组标识） 用户全名或本地帐号 家目录 登录使用的 Shell，就是登录之后，使用的终端命令，ubuntu 默认是 dash usermod usermod 可以用来设置 用户 的 主组 ／ 附加组 和 登录 Shell，命令格式如下： 主组：通常在新建用户时指定，在 etc/passwd 的第 4 列 GID 对应的组 附加组：在 etc/group 中最后一列表示该组的用户列表，用于指定 用户的附加权限 提示：设置了用户的附加组之后，需要重新登录才能生效！ 12345678# 修改用户的主组（passwd 中的 GID）usermod -g 组 用户名# 修改用户的附加组usermod -G 组 用户名# 修改用户登录 Shellusermod -s /bin/bash 用户名 注意：默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中 1usermod -G sudo 用户名 which（重要） 提示 /etc/passwd 是用于保存用户信息的文件 /usr/bin/passwd 是用于修改用户密码的程序 which 命令可以查看执行命令所在位置，例如： 123456789which ls# 输出# /bin/lswhich useradd# 输出# /usr/sbin/useradd bin 和 sbin 在 Linux 中，绝大多数可执行文件都是保存在 /bin、/sbin、/usr/bin、/usr/sbin /bin（binary）是二进制执行文件目录，主要用于具体应用 /sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理 /usr/bin（user commands for applications）后期安装的一些软件 /usr/sbin（super user commands for applications）超级用户的一些管理程序 提示： cd 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 which 无法找到 cd 命令的位置 3.3 切换用户 序号 命令 作用 说明 01 su - 用户名 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 02 exit 退出当前登录账户 su 不接用户名，可以切换到 root，但是不推荐使用，因为不安全 exit 示意图如下： ￼ 04. 修改文件权限 序号 命令 作用 01 chown 修改拥有者 02 chgrp 修改组 03 chmod 修改权限 命令格式如下： 12345678# 修改文件|目录的拥有者chown 用户名 文件名|目录名# 递归修改文件|目录的组chgrp -R 组名 文件名|目录名# 递归修改文件权限chmod -R 755 文件名|目录名 chmod 在设置权限时，可以简单地使用三个数字分别对应 拥有者 ／ 组 和 其他 用户的权限 12# 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他chmod +/-rwx 文件名|目录名 ￼ 常见数字组合有（ 1u 表示用户／ 1g 表示组／ 1o 表示其他）： 777 ===&gt; u=rwx,g=rwx,o=rwx 755 ===&gt; u=rwx,g=rx,o=rx 644 ===&gt; u=rw,g=r,o=r chmod 演练目标 将 01.py 的权限修改为 u=rwx,g=rx,o=r 将 123.txt 的权限修改为 u=rw,g=r,o=- 将 test 目录以及目录下的 所有 文件权限修改为 u=rwx,g=rwx,o=rx","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"8-远程管理常用命令","slug":"8-远程管理常用命令","date":"2020-02-06T08:07:10.000Z","updated":"2020-02-08T08:54:16.934Z","comments":true,"path":"2020/02/06/8-远程管理常用命令/","link":"","permalink":"http://yoursite.com/2020/02/06/8-%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"远程管理常用命令目标 关机/重启 shutdown 查看或配置网卡信息 ifconfig ping 远程登录和复制文件 ssh scp","text":"远程管理常用命令目标 关机/重启 shutdown 查看或配置网卡信息 ifconfig ping 远程登录和复制文件 ssh scp 01. 关机/重启 序号 命令 对应英文 作用 01 shutdown 选项 时间 shutdown 关机／重新启动 1.1 shutdown shutdown 命令可以 安全 关闭 或者 重新启动系统 选项 含义 -r 重新启动 提示： 不指定选项和参数，默认表示 1 分钟之后 关闭电脑 远程维护服务器时，最好不要关闭系统，而应该重新启动系统 常用命令示例 1234567891011121314# 重新启动操作系统，其中 now 表示现在$ shutdown -r now# 立刻关机，其中 now 表示现在$ shutdown now# 系统在今天的 20:25 会关机$ shutdown 20:25# 系统再过十分钟后自动关机$ shutdown +10# 取消之前指定的关机计划$ shutdown -c 02. 查看或配置网卡信息 序号 命令 对应英文 作用 01 ifconfig configure a network interface 查看/配置计算机当前的网卡配置信息 02 ping ip地址 ping 检测到目标 ip地址 的连接是否正常 2.1 网卡 和 IP 地址网卡 网卡是一个专门负责网络通讯的硬件设备 IP 地址是设置在网卡上的地址信息 我们可以把 电脑 比作 电话，网卡 相当于 SIM 卡，IP 地址 相当于 电话号码 IP 地址 每台联网的电脑上都有 IP 地址，是保证电脑之间正常通讯的重要设置 注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯 提示：有关 IP 地址的详细内容，在就业班会详细讲解！ 2.2 ifconfig ifconfig 可以查看／配置计算机当前的网卡配置信息 12345# 查看网卡配置信息$ ifconfig# 查看网卡对应的 IP 地址$ ifconfig | grep inet 提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示 127.0.0.1 被称为 本地回环/环回地址，一般用来测试本机网卡是否正常 2.3 ping12345# 检测到目标主机是否连接正常$ ping IP地址# 检测本地网卡工作正常$ ping 127.0.0.1 ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅，数值越大，速度越慢 ping 的工作原理与潜水艇的声纳相似，ping 这个命令就是取自 声纳的声音 网络管理员之间也常将 ping 用作动词 —— ping 一下计算机X，看他是否开着 原理：网络上的机器都有 唯一确定的 IP 地址，我们给目标 IP 地址发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在 提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 CTRL + C 03. 远程登录和复制文件 序号 命令 对应英文 作用 01 ssh 用户名@ip secure shell 关机／重新启动 02 scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径 secure copy 远程复制文件 3.1 ssh 基础（重点）在 Linux 中 SSH 是 非常常用 的工具，通过 SSH 客户端 我们可以连接到运行了 SSH 服务器 的远程机器上 ￼ SSH 客户端是一种使用 Secure Shell（SSH） 协议连接到远程计算机的软件程序 SSH 123456789101112131415161718192021222324252627282930313233343536373839 是目前较可靠， 专为远程登录会话和其他网络服务 提供安全性的协议 - 利用 &#96;SSH 协议&#96; 可以有效**防止远程管理过程中的信息泄露** - 通过 &#96;SSH 协议&#96; 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗- &#96;SSH&#96; 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度#### 1) 域名 和 端口号##### 域名- 由一串 **用点分隔** 的名字组成，例如：&#96;www.itcast.cn&#96;- 是 **IP 地址** 的别名，方便用户记忆##### 端口号- **IP 地址**：通过 **IP 地址** 找到网络上的 **计算机**- **端口号**：通过 **端口号** 可以找到 **计算机上运行的应用程序** - **SSH 服务器** 的默认端口号是 &#96;22&#96;，如果是默认端口号，在连接的时候，可以省略- 常见服务端口号列表：| 序号 | 服务 | 端口号 || ---- | ---------- | ------ || 01 | SSH 服务器 | 22 || 02 | Web 服务器 | 80 || 03 | HTTPS | 443 || 04 | FTP 服务器 | 21 |&gt; 提示：有关 **端口号**的详细内容，在就业班会详细讲解！#### 2) SSH 客户端的简单使用&#96;&#96;&#96;bashssh [-p port] user@remote user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名 port 是 SSH Server 监听的端口，如果不指定，就为默认值 22 提示： 使用 exit 退出当前用户的登录 注意： ssh 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY 或者 XShell 客户端软件即可 提示： 在工作中，SSH 服务器的端口号很有可能不是 22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器 3) Windows 下 SSH 客户端的安装 Putty http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html XShell http://xshellcn.com 建议从官方网站下载正式的安装程序 3.2 scp（掌握） scp 就是 secure copy，是一个在 Linux 下用来进行 远程拷贝文件 的命令 它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的 ￼ 12345678910111213# 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop/01.py# 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.pyscp -P port user@remote:Desktop/01.py 01.py# 加上 -r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp -r demo user@remote:Desktop# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp -r user@remote:Desktop demo 选项 含义 -r 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -P 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口 注意： scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY，使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输 FileZilla 官方网站：https://www.filezilla.cn/download/client FileZilla 在传输文件时，使用的是 FTP 服务 而不是 SSH 服务，因此端口号应该设置为 21 3.3 SSH 高级（知道） 免密码登录 配置别名 提示：有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下 1）免密码登录步骤 配置公钥 执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥 示意图![003_SSH 免密码示意图](003_SSH 免密码示意图.png)￼ 非对称加密算法 使用 公钥 加密的数据，需要使用 私钥 解密 使用 私钥 加密的数据，需要使用 公钥 解密 2) 配置别名每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆 而 配置别名 可以让我们进一步偷懒，譬如用：ssh mac 来替代上面这么一长串，那么就在 ~/.ssh/config 里面追加以下内容： 1234Host mac HostName ip地址 User itheima Port 22 保存之后，即可用 ssh mac 实现远程登录了，scp 同样可以使用","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"7-文件和目录常用命令","slug":"7-文件和目录常用命令","date":"2020-02-06T08:05:13.000Z","updated":"2020-02-08T08:54:04.621Z","comments":true,"path":"2020/02/06/7-文件和目录常用命令/","link":"","permalink":"http://yoursite.com/2020/02/06/7-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"文件和目录常用命令目标 查看目录内容 ls 切换目录 cd 创建和删除操作 touch rm mkdir","text":"文件和目录常用命令目标 查看目录内容 ls 切换目录 cd 创建和删除操作 touch rm mkdir 拷贝和移动文件 cp mv 查看文件内容 cat more grep 其他 echo 重定向 &gt; 和 &gt;&gt; 管道 | 01. 查看目录内容1.1 终端实用技巧1&gt; 自动补全 在敲出 1文件 ／ 1目录 ／ 1命令 的前几个字母之后，按下 1tab 键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 2&gt; 曾经使用过的命令 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c 1.2 ls 命令说明 ls 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 DOS 下的 dir 命令 Linux 下文件和目录的特点 Linux 文件 或者 目录 名称最长可以有 256 个字符 以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示 . 代表当前目录 .. 代表上一级目录 1.3 ls 常用选项 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 计算机中文件大小的表示方式（科普） 单位 英文 含义 字节 B（Byte） 在计算机中作为一个数字单元，一般为 8 位二进制数 千 K（Kibibyte） 1 KB = 1024 B，千字节 （1024 = 2 ** 10） 兆 M（Mebibyte） 1 MB = 1024 KB，百万字节 千兆 G（Gigabyte） 1 GB = 1024 MB，十亿字节，千兆字节 太 T（Terabyte） 1 TB = 1024 GB，万亿字节，太字节 拍 P（Petabyte） 1 PB = 1024 TB，千万亿字节，拍字节 艾 E（Exabyte） 1 EB = 1024 PB，百亿亿字节，艾字节 泽 Z（Zettabyte） 1 ZB = 1024 EB，十万亿亿字节，泽字节 尧 Y（Yottabyte） 1 YB = 1024 ZB，一亿亿亿字节，尧字节 1.4 ls 通配符的使用 通配符 含义 * 代表任意个数个字符 ? 代表任意一个字符，至少 1 个 [] 表示可以匹配字符组中的任一一个 [abc] 匹配 a、b、c 中的任意一个 [a-f] 匹配从 a 到 f 范围内的的任意一个字符 02. 切换目录2.1 cd cd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一 注意：Linux 所有的 目录 和 文件名 都是大小写敏感的 命令 含义 cd 切换到当前用户的主目录(/home/用户目录) cd ~ 切换到当前用户的主目录(/home/用户目录) cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 2.2 相对路径和绝对路径 相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录 所在的目录位置 绝对路径 在输入路径时，最前面是 / 或者 ~，表示从 根目录/家目录 开始的具体目录位置 03. 创建和删除操作3.1 touch 创建文件或修改文件时间 如果文件 不存在，可以创建一个空白文件 如果文件 已经存在，可以修改文件的末次修改日期 3.2 mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 3.3 rm 删除文件或目录 使用 rm 命令要小心，因为文件删除后不能恢复 选项 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹 时必须加此参数 04. 拷贝和移动文件 序号 命令 对应英文 作用 01 tree [目录名] tree 以树状图列出文件目录结构 02 cp 源文件 目标文件 copy 复制文件或者目录 03 mv 源文件 目标文件 move 移动文件或者目录／文件或者目录重命名 4.1 tree tree 命令可以以树状图列出文件目录结构 选项 含义 -d 只显示目录 4.2 cp cp 命令的功能是将给出的 文件 或 目录 复制到另一个 文件 或 目录 中，相当于 DOS 下的 copy 命令 选项 含义 -i 覆盖文件前提示 -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 4.3 mv mv 命令可以用来 移动 文件 或 目录，也可以给 文件或目录重命名 选项 含义 -i 覆盖文件前提示 05. 查看文件内容 序号 命令 对应英文 作用 01 cat 文件名 concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能 02 more 文件名 more 分屏显示文件内容 03 grep 搜索文本 文件名 grep 搜索文本文件内容 5.1 cat cat 命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能 cat 会一次显示所有的内容，适合 查看内容较少 的文本文件 选项 含义 -b 对非空输出行编号 -n 对输出的所有行编号 Linux 中还有一个 nl 的命令和 cat -b 的效果等价 5.2 more more 命令可以用于分屏显示文件内容，每次只显示一页内容 适合于 查看内容较多的文本文件 使用 more 的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串 5.3 grep Linux 系统中 grep 命令是一种强大的文本搜索工具 grep允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解 选项 含义 -n 显示匹配行及行号 -v 显示不包含匹配文本的所有行（相当于求反） -i 忽略大小写 常用的两种模式查找 参数 含义 ^a 行首，搜寻以 a 开头的行 ke$ 行尾，搜寻以 ke 结束的行 06. 其他6.1 echo 文字内容 echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用 6.2 重定向 &gt; 和 &gt;&gt; Linux 允许将命令执行结果 重定向到一个 文件 将本应显示在终端上的内容 输出／追加 到指定文件中 其中 &gt; 表示输出，会覆盖文件原有的内容 &gt;&gt; 表示追加，会将内容追加到已有文件的末尾 6.3 管道 | Linux 允许将 一个命令的输出 可以通过管道 做为 另一个命令的输入 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读） 常用的管道命令有： more：分屏显示内容 grep：在命令执行结果的基础上查询指定的文本","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"6-Linux 终端命令格式","slug":"6-Linux-终端命令格式","date":"2020-02-06T08:03:36.000Z","updated":"2020-02-08T08:53:57.481Z","comments":true,"path":"2020/02/06/6-Linux-终端命令格式/","link":"","permalink":"http://yoursite.com/2020/02/06/6-Linux-%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F/","excerpt":"Linux 终端命令格式目标 了解终端命令格式 知道如何查阅终端命令帮助信息","text":"Linux 终端命令格式目标 了解终端命令格式 知道如何查阅终端命令帮助信息 01. 终端命令格式1command [-options] [parameter] 说明： command：命令名，相应功能的英文单词或单词的缩写 [-options]：选项，可用来对命令进行控制，也可以省略 parameter：传给命令的参数，可以是 零个、一个 或者 多个 [] 代表可选 02. 查阅命令帮助信息（知道） 提示 现阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息 先学习常用命令及常用选项的使用即可，工作中如果遇到问题可以借助 网络搜索 2.1 --help1command --help 说明： 显示 command 命令的帮助信息 2.2 man1man command 说明： 查阅 command 命令的使用手册 man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明 使用 man 时的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"5-常用 Linux 命令的基本使用","slug":"5-常用-Linux-命令的基本使用","date":"2020-02-06T07:55:35.000Z","updated":"2020-02-08T08:53:48.916Z","comments":true,"path":"2020/02/06/5-常用-Linux-命令的基本使用/","link":"","permalink":"http://yoursite.com/2020/02/06/5-%E5%B8%B8%E7%94%A8-Linux-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","excerpt":"常用 Linux 命令的基本使用目标 理解学习 Linux 终端命令的原因 常用 Linux 命令体验","text":"常用 Linux 命令的基本使用目标 理解学习 Linux 终端命令的原因 常用 Linux 命令体验 01. 学习 Linux 终端命令的原因 Linux 刚面世时并没有图形界面，所有的操作全靠命令完成，如 磁盘操作、文件存取、目录操作、进程管理、文件权限 设定等 在职场中，大量的 服务器维护工作 都是在 远程 通过 SSH 客户端 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成 在职场中，作为后端程序员，必须要或多或少的掌握一些 Linux 常用的终端命令 Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已 学习终端命令的技巧： 不需要死记硬背，对于常用命令，用的多了，自然就记住了 不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时百度就可以 02. 常用 Linux 命令的基本使用 序号 命令 对应英文 作用 01 ls list 查看当前文件夹下的内容 02 pwd print wrok directory 查看当前所在文件夹 03 cd [目录名] change directory 切换文件夹 04 touch [文件名] touch 如果文件不存在，新建文件 05 mkdir [目录名] make directory 创建目录 06 rm [文件名] remove 删除指定的文件名 07 clear clear 清屏 小技巧 ctrl + shift + = 放大终端窗口的字体显示 ctrl + - 缩小终端窗口的字体显示 03. 自动补全 在敲出 1文件／目录／命令的前几个字母之后，按下 tab键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 小技巧 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"4-Ubuntu 图形界面入门","slug":"4-Ubuntu-图形界面入门","date":"2020-02-06T07:53:20.000Z","updated":"2020-02-08T08:53:41.173Z","comments":true,"path":"2020/02/06/4-Ubuntu-图形界面入门/","link":"","permalink":"http://yoursite.com/2020/02/06/4-Ubuntu-%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%85%A5%E9%97%A8/","excerpt":"Ubuntu 图形界面入门目标 熟悉 Ubuntu 图形界面的基本使用","text":"Ubuntu 图形界面入门目标 熟悉 Ubuntu 图形界面的基本使用 01. Ubuntu 的任务栏￼ 02. 窗口操作按钮￼ 03. 窗口菜单条￼","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"3-文件和目录","slug":"3-文件和目录","date":"2020-02-06T07:50:34.000Z","updated":"2020-02-08T08:53:33.013Z","comments":true,"path":"2020/02/06/3-文件和目录/","link":"","permalink":"http://yoursite.com/2020/02/06/3-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/","excerpt":"文件和目录（理解）目标 理解 Linux 文件目录的结构","text":"文件和目录（理解）目标 理解 Linux 文件目录的结构 01. 单用户操作系统和多用户操作系统（科普） 单用户操作系统：指一台计算机在同一时间 只能由一个用户 使用，一个用户独自享用系统的全部硬件和软件资源 Windows XP 之前的版本都是单用户操作系统 多用户操作系统：指一台计算机在同一时间可以由 多个用户 使用，多个用户共同享用系统的全部硬件和软件资源 Unix 和 Linux 的设计初衷就是多用户操作系统 02. Windows 和 Linux 文件系统区别2.1 Windows 下的文件系统 在 Windows 下，打开 “计算机”，我们看到的是一个个的驱动器盘符： ￼ 每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示： ￼ 2.2 Linux 下的文件系统 在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）： ￼ Ubuntu 没有盘符这个概念，只有一个根目录 /，所有文件都在它下面 ￼ 2.3 用户目录位于 /home/user，称之为用户工作目录或家目录，表示方式： 12/home/user~ 2.4 Linux 主要目录速查表 /：根目录， 一般根目录下只存放目录 ，在 linux 下有且只有一个根目录，所有的东西都是从这里开始 当在终端里输入 /home，其实是在告诉电脑，先从 /（根目录）开始，再进入到 home 目录 /bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等 /boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab /etc/fstab /etc/init.d /etc/X11 /etc/sysconfig /etc/xinetd.d /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下 ~ 表示当前用户的家目录 ~edu 表示用户 edu 的家目录 /lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助 /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下 /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载 /opt：给主机额外安装软件所摆放的目录 /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等 /root：系统管理员root的家目录 /sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能”查看”而不能设置和使用 /tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下 /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内 /usr：应用程序存放目录 /usr/bin：存放应用程序 /usr/share：存放共享数据 /usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local：存放软件升级包 /usr/share/doc：系统说明文件存放目录 /usr/share/man：程序说明文件存放目录 /var：放置系统执行过程中经常变化的文件 /var/log：随时更改的日志文件 /var/spool/mail：邮件存放的目录 /var/run：程序或服务启动后，其 PID 存放在该目录下","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"2-操作系统的发展史","slug":"2-操作系统的发展史","date":"2020-02-06T07:43:07.000Z","updated":"2020-02-08T08:53:22.569Z","comments":true,"path":"2020/02/06/2-操作系统的发展史/","link":"","permalink":"http://yoursite.com/2020/02/06/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/","excerpt":"操作系统的发展史（科普章节）目标 了解操作系统的发展历史 知道 Linux 内核及发行版的区别 知道 Linux 的应用领域","text":"操作系统的发展史（科普章节）目标 了解操作系统的发展历史 知道 Linux 内核及发行版的区别 知道 Linux 的应用领域 01. 操作系统的发展历史1.1 Unix1965 年之前的时候，电脑并不像现在一样普遍，它可不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑 ￼ 为了解决数量不够用的问题 1965 年左后由 贝尔实验室 加入了 麻省理工学院 以及 通用电气 合作的计划 —— 该计划要建立一套 多使用者(multi－user)、多任务(multi－processor)、多层次(multi－level) 的 MULTICS 操作系统，想让大型主机支持 300 台终端 1969 年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究 1969 年从这个项目中退出的 Ken Thompson 当时在实验室无聊时，为了让一台空闲的电脑上能够运行 “星际旅行（Space Travel）” 游行，在 8 月份左右趁着其妻子探亲的时间，用了 1 个月的时间，使用汇编写出了 Unix 操作系统的原型 1970 年，美国贝尔实验室的 Ken Thompson，以 BCPL 语言为基础，设计出很简单且很接近硬件的 B 语言（取BCPL的首字母），并且他用 B 语言 写了第一个 UNIX 操作系统 1971 年，同样酷爱 “星际旅行（Space Travel）” 的 Dennis M.Ritchie 为了能早点儿玩上游戏，加入了 Thompson 的开发项目，合作开发 UNIX，他的主要工作是改造 B 语言，因为B 语言 的跨平台性较差 1972 年，Dennis M.Ritchie 在 B 语言 的基础上最终设计出了一种新的语言，他取了 BCPL 的第二个字母作为这种语言的名字，这就是 C 语言 1973 年初，C 语言的主体完成，Thompson 和 Ritchie 迫不及待地开始用它完全重写了现在大名鼎鼎的 Unix 操作系统 ￼ 肯·汤普逊（左）和丹尼斯·里奇（右） C 语言 在把 UNIX 移植到其他类型的计算机上使用时， C 语言 强大的移植性（Portability）在此显现 机器语言和汇编语言都不具有移植性，为 x86 开发的程序，不可能在 Alpha，SPARC 和 ARM 等机器上运行 而 C 语言程序则可以使用在任意架构的处理器上，只要那种架构的处理器具有对应的 C 语言编译器和库，然后将 C 源代码编译、连接成目标二进制文件之后即可运行 Unix 家谱￼ 1.2 Minix 因为 AT&amp;T（通用电气） 的政策改变，在 Version 7 Unix 推出之后，发布新的使用条款，将 UNIX 源代码私有化，在大学中不再能使用 UNIX 源代码 Andrew S. Tanenbaum（塔能鲍姆） 教授为了能 在课堂上教授学生操作系统运作的细节，决定在不使用任何 AT&amp;T 的源代码前提下，自行开发与 UNIX 兼容的操作系统，以避免版权上的争议 以 小型 UNIX（mini-UNIX）之意，将它称为 MINIX 1.3 Linux 1991 年 林纳斯（Linus） 就读于赫尔辛基大学期间，对 Unix 产生浓厚兴趣，尝试着在Minix 上做一些开发工作 因为 Minix 只是教学使用，因此功能并不强，林纳斯 经常要用他的终端 仿真器（Terminal Emulator） 去访问大学主机上的新闻组和邮件，为了方便读写和下载文件，他自己编写了磁盘驱动程序和文件系统，这些在后来成为了 Linux 第一个内核的雏形，当时，他年仅 21 岁！ 林纳斯 利用 GNU 的 bash 当做开发环境，gcc 当做编译工具，编写了 Linux 内核，一开始 Linux 并不能兼容 Unix 即 Unix 上跑的应用程序不能在 Linux 上跑，即应用程序与内核之间的接口不一致 一开始 Linux 只适用于 386，后来经过全世界的网友的帮助，最终能够兼容多种硬件 ￼ 02. Linux 内核及发行版2.1 Linux 内核版本 内核（kernel）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层 Linux 内核版本又分为 稳定版 和 开发版 ，两种版本是相互关联，相互循环 稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序 开发版：由于要试验各种解决方案，所以变化很快 内核源码网址：http://www.kernel.org 所有来自全世界的对 Linux 源码的修改最终都会汇总到这个网站，由 Linus 领导的开源社区对其进行甄别和修改最终决定是否进入到 Linux 主线内核源码中 2.2 Linux 发行版本 Linux 发行版（也被叫做 GNU/Linux 发行版）通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件 常见的发行版本如下： Ubuntu Redhat Fedora openSUSE Linux Mint Debian Manjaro Mageia CentOS Arch 十大 Linux 服务器发行版排行榜：http://os.51cto.com/art/201612/526126.htm 在几乎每一份与 Linux 有关的榜单上，基于 Debian 的 Ubuntu 都占有一席之位。Canonical 的Ubuntu 胜过其他所有的 Linux 服务器发行版 ―― 从简单安装、出色的硬件发现，到世界级的商业支持，Ubuntu确立了难以企及的严格标准 03. Linux 的应用领域3.1 服务器领域 Linux 在服务器领域的应用是其重要分支 Linux 免费、稳定、高效等特点在这里得到了很好的体现 早期因为维护、运行等原因同样受到了很大的限制 近些年来 Linux 服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛 3.2 嵌入式领域 近些年来 Linux 在嵌入式领域的应用得到了飞速的提高 Linux 运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百 KB 等特点，使其近些年来在嵌入式领域的应用得到非常大的提高 主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、等都是其应用领域，得到了 Google、三星、摩托罗拉、NEC 等公司的大力推广 3.3 个人桌面领域 此领域是传统 Linux 应用最薄弱的环节 传统 Linux 由于界面简单、操作复杂、应用软件少的缺点，一直被 Windows 所压制 近些年来随着 Ubuntu、Fedora 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，Linux 在个人桌面领域的占有率在逐渐的提高 在 Ubuntu 中玩 QQ ￼","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]},{"title":"1.操作系统","slug":"1-操作系统","date":"2020-02-06T07:23:09.000Z","updated":"2020-02-08T08:52:58.699Z","comments":true,"path":"2020/02/06/1-操作系统/","link":"","permalink":"http://yoursite.com/2020/02/06/1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"操作系统目标 了解操作系统及作用","text":"操作系统目标 了解操作系统及作用 1. 操作系统（Operation System，OS） 操作系统作为接口的示意图 没有安装操作系统的计算机，通常被称为 裸机 如果想在 裸机 上运行自己所编写的程序，就必须用机器语言书写程序 如果计算机上安装了操作系统，就可以在操作系统上安装支持的高级语言环境，用高级语言开发程序 1.1 操作系统的作用 是现代计算机系统中 最基本和最重要 的系统软件 是 配置在计算机硬件上的第一层软件，是对硬件系统的首次扩展 主要作用是管理好硬件设备，并为用户和应用程序提供一个简单的接口，以便于使用 而其他的诸如编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持 1.2 不同应用领域的主流操作系统 桌面操作系统 服务器操作系统 嵌入式操作系统 移动设备操作系统 1&gt; 桌面操作系统 Windows 系列 * 用户群体大 macOS * 适合于开发人员 Linux * 应用软件少 2&gt; 服务器操作系统 Linux * 安全、稳定、免费 占有率高 Windows Server * 付费 占有率低 ￼ 3&gt; 嵌入式操作系统 Linux 4&gt; 移动设备操作系统 iOS Android（基于 Linux） 1.3 虚拟机虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统 虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能 进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响 而且能够在现有系统与虚拟镜像之间灵活切换的一类操作系统","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/categories/Linux%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"http://yoursite.com/tags/Linux%E5%9F%BA%E7%A1%80/"}]}]}